{
  ObjectPair<PrimitiveObjectInspector,ExprNodeEvaluator> handle=PartExprEvalUtils.prepareExpr(prunerExpr,columnNames);
  boolean inPlace=partNames instanceof AbstractSequentialList<?>;
  List<String> partNamesSeq=inPlace ? partNames : new LinkedList<String>(partNames);
  ArrayList<String> values=new ArrayList<String>(columnNames.size());
  for (int i=0; i < columnNames.size(); ++i) {
    values.add(null);
  }
  boolean hasUnknownPartitions=false;
  Iterator<String> partIter=partNamesSeq.iterator();
  while (partIter.hasNext()) {
    String partName=partIter.next();
    Warehouse.makeValsFromName(partName,values);
    Boolean isNeeded=(Boolean)PartExprEvalUtils.evaluateExprOnPart(handle,values);
    boolean isUnknown=(isNeeded == null);
    if (!isUnknown && !isNeeded) {
      partIter.remove();
      continue;
    }
    if (isUnknown && values.contains(defaultPartitionName)) {
      LOG.debug("skipping default/bad partition: " + partName);
      partIter.remove();
      continue;
    }
    hasUnknownPartitions|=isUnknown;
    LOG.debug("retained " + (isUnknown ? "unknown " : "") + "partition: "+ partName);
  }
  if (!inPlace) {
    partNames.clear();
    partNames.addAll(partNamesSeq);
  }
  return hasUnknownPartitions;
}
