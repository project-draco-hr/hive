{
  this.outDir=outDir;
  this.logDir=logDir;
  if (confDir != null && !confDir.isEmpty()) {
    HiveConf.setHiveSiteLocation(new URL("file://" + new File(confDir).toURI().getPath() + "/hive-site.xml"));
    System.out.println("Setting hive-site: " + HiveConf.getHiveSiteLocation());
  }
  conf=new HiveConf(Driver.class);
  this.hadoopVer=getHadoopMainVersion(hadoopVer);
  qMap=new TreeMap<String,String>();
  qSkipSet=new HashSet<String>();
  qSortSet=new HashSet<String>();
  qSortQuerySet=new HashSet<String>();
  qHashQuerySet=new HashSet<String>();
  qSortNHashQuerySet=new HashSet<String>();
  qJavaVersionSpecificOutput=new HashSet<String>();
  QTestUtil.clusterType=clusterType;
  HadoopShims shims=ShimLoader.getHadoopShims();
  int numberOfDataNodes=4;
  if (clusterType != MiniClusterType.none && clusterType != MiniClusterType.spark) {
    FileSystem fs=null;
    if (clusterType == MiniClusterType.encrypted) {
      conf.set(SECURITY_KEY_PROVIDER_URI_NAME,getKeyProviderURI());
      conf.setInt("fs.trash.interval",50);
      dfs=shims.getMiniDfs(conf,numberOfDataNodes,true,null);
      fs=dfs.getFileSystem();
      hes=shims.createHdfsEncryptionShim(fs,conf);
      LOG.info("key provider is initialized");
    }
 else {
      dfs=shims.getMiniDfs(conf,numberOfDataNodes,true,null);
      fs=dfs.getFileSystem();
    }
    String uriString=WindowsPathUtil.getHdfsUriString(fs.getUri().toString());
    if (clusterType == MiniClusterType.tez) {
      mr=shims.getMiniTezCluster(conf,4,uriString);
    }
 else     if (clusterType == MiniClusterType.llap) {
      Configuration daemonConf;
      if (confDir != null && !confDir.isEmpty()) {
        URL llapDaemonConfURL=new URL("file://" + new File(confDir).toURI().getPath() + "/llap-daemon-site.xml");
        daemonConf=new LlapConfiguration(conf,llapDaemonConfURL);
      }
 else {
        daemonConf=new LlapConfiguration(conf);
      }
      final String clusterName="llap";
      final long maxMemory=LlapDaemon.getTotalHeapSize();
      final long memoryForCache=(long)(0.15f * maxMemory);
      final long totalExecutorMemory=(long)(0.75f * maxMemory);
      final int numExecutors=daemonConf.getInt(LlapConfiguration.LLAP_DAEMON_NUM_EXECUTORS,LlapConfiguration.LLAP_DAEMON_NUM_EXECUTORS_DEFAULT);
      final boolean asyncIOEnabled=true;
      final boolean directMemoryEnabled=false;
      final int numLocalDirs=1;
      LOG.info("MiniLlap Configs - maxMemory: " + maxMemory + " memoryForCache: "+ memoryForCache+ " totalExecutorMemory: "+ totalExecutorMemory+ " numExecutors: "+ numExecutors+ " asyncIOEnabled: "+ asyncIOEnabled+ " directMemoryEnabled: "+ directMemoryEnabled+ " numLocalDirs: "+ numLocalDirs);
      llapCluster=MiniLlapCluster.create(clusterName,numExecutors,totalExecutorMemory,asyncIOEnabled,directMemoryEnabled,memoryForCache,numLocalDirs);
      llapCluster.init(daemonConf);
      llapCluster.start();
      Configuration llapConf=llapCluster.getClusterSpecificConfiguration();
      Iterator<Entry<String,String>> confIter=llapConf.iterator();
      while (confIter.hasNext()) {
        Entry<String,String> entry=confIter.next();
        conf.set(entry.getKey(),entry.getValue());
      }
      mr=shims.getMiniTezCluster(conf,2,uriString);
    }
 else     if (clusterType == MiniClusterType.miniSparkOnYarn) {
      mr=shims.getMiniSparkCluster(conf,4,uriString,1);
    }
 else {
      mr=shims.getMiniMrCluster(conf,4,uriString,1);
    }
  }
  initConf();
  String dataDir=conf.get("test.data.files");
  if (dataDir == null) {
    dataDir=new File(".").getAbsolutePath() + "/data/files";
  }
  testFiles=dataDir;
  String scriptsDir=conf.get("test.data.scripts");
  if (scriptsDir == null) {
    scriptsDir=new File(".").getAbsolutePath() + "/data/scripts";
  }
  this.initScript=scriptsDir + File.separator + initScript;
  this.cleanupScript=scriptsDir + File.separator + cleanupScript;
  overWrite="true".equalsIgnoreCase(System.getProperty("test.output.overwrite"));
  setup=new QTestSetup();
  setup.preTest(conf);
  init();
}
