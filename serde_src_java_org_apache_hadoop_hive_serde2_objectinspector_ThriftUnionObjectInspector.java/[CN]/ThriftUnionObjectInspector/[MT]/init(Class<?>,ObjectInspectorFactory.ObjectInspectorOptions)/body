{
  verifyObjectClassType(objectClass);
  this.objectClass=objectClass;
  final Field fieldMetaData;
  try {
    fieldMetaData=objectClass.getDeclaredField(FIELD_METADATA_MAP);
    assert(Map.class.isAssignableFrom(fieldMetaData.getType()));
    fieldMetaData.setAccessible(true);
  }
 catch (  NoSuchFieldException e) {
    throw new RuntimeException("Unable to find field metadata for thrift union field ",e);
  }
  try {
    final Map<? extends TFieldIdEnum,FieldMetaData> fieldMap=(Map<? extends TFieldIdEnum,FieldMetaData>)fieldMetaData.get(null);
    fields=new ArrayList<StandardStructObjectInspector.MyField>(fieldMap.size());
    this.ois=new ArrayList<ObjectInspector>();
    for (    Map.Entry<? extends TFieldIdEnum,FieldMetaData> metadata : fieldMap.entrySet()) {
      int fieldId=metadata.getKey().getThriftFieldId();
      String fieldName=metadata.getValue().fieldName;
      final Type fieldType=ThriftObjectInspectorUtils.getFieldType(objectClass,fieldName);
      final ObjectInspector reflectionObjectInspector=ObjectInspectorFactory.getReflectionObjectInspector(fieldType,options);
      fields.add(new StandardStructObjectInspector.MyField(fieldId,fieldName,reflectionObjectInspector));
      this.ois.add(reflectionObjectInspector);
    }
  }
 catch (  IllegalAccessException e) {
    throw new RuntimeException("Unable to find field metadata for thrift union field ",e);
  }
}
