{
  fieldIndex++;
  if (fieldIndex >= fieldCount) {
    if (!readBeyondConfiguredFieldsWarned) {
      doReadBeyondConfiguredFieldsWarned();
    }
    return true;
  }
  if (inputByteBuffer.isEof()) {
    if (!readBeyondBufferRangeWarned) {
      doReadBeyondBufferRangeWarned();
    }
    return true;
  }
  byte isNullByte=inputByteBuffer.read(columnSortOrderIsDesc[fieldIndex]);
  if (isNullByte == 0) {
    return true;
  }
  boolean isNull=false;
switch (primitiveCategories[fieldIndex]) {
case BOOLEAN:
    currentBoolean=(inputByteBuffer.read(columnSortOrderIsDesc[fieldIndex]) == 2);
  break;
case BYTE:
currentByte=(byte)(inputByteBuffer.read(columnSortOrderIsDesc[fieldIndex]) ^ 0x80);
break;
case SHORT:
{
final boolean invert=columnSortOrderIsDesc[fieldIndex];
int v=inputByteBuffer.read(invert) ^ 0x80;
v=(v << 8) + (inputByteBuffer.read(invert) & 0xff);
currentShort=(short)v;
}
break;
case INT:
{
final boolean invert=columnSortOrderIsDesc[fieldIndex];
int v=inputByteBuffer.read(invert) ^ 0x80;
for (int i=0; i < 3; i++) {
v=(v << 8) + (inputByteBuffer.read(invert) & 0xff);
}
currentInt=v;
}
break;
case LONG:
{
final boolean invert=columnSortOrderIsDesc[fieldIndex];
long v=inputByteBuffer.read(invert) ^ 0x80;
for (int i=0; i < 7; i++) {
v=(v << 8) + (inputByteBuffer.read(invert) & 0xff);
}
currentLong=v;
}
break;
case DATE:
{
final boolean invert=columnSortOrderIsDesc[fieldIndex];
int v=inputByteBuffer.read(invert) ^ 0x80;
for (int i=0; i < 3; i++) {
v=(v << 8) + (inputByteBuffer.read(invert) & 0xff);
}
currentDateWritable.set(v);
}
break;
case TIMESTAMP:
{
if (tempTimestampBytes == null) {
tempTimestampBytes=new byte[TimestampWritable.BINARY_SORTABLE_LENGTH];
}
final boolean invert=columnSortOrderIsDesc[fieldIndex];
for (int i=0; i < tempTimestampBytes.length; i++) {
tempTimestampBytes[i]=inputByteBuffer.read(invert);
}
currentTimestampWritable.setBinarySortable(tempTimestampBytes,0);
}
break;
case FLOAT:
{
final boolean invert=columnSortOrderIsDesc[fieldIndex];
int v=0;
for (int i=0; i < 4; i++) {
v=(v << 8) + (inputByteBuffer.read(invert) & 0xff);
}
if ((v & (1 << 31)) == 0) {
v=~v;
}
 else {
v=v ^ (1 << 31);
}
currentFloat=Float.intBitsToFloat(v);
}
break;
case DOUBLE:
{
final boolean invert=columnSortOrderIsDesc[fieldIndex];
long v=0;
for (int i=0; i < 8; i++) {
v=(v << 8) + (inputByteBuffer.read(invert) & 0xff);
}
if ((v & (1L << 63)) == 0) {
v=~v;
}
 else {
v=v ^ (1L << 63);
}
currentDouble=Double.longBitsToDouble(v);
}
break;
case BINARY:
case STRING:
case CHAR:
case VARCHAR:
{
if (tempText == null) {
tempText=new Text();
}
BinarySortableSerDe.deserializeText(inputByteBuffer,columnSortOrderIsDesc[fieldIndex],tempText);
currentBytes=tempText.getBytes();
currentBytesStart=0;
currentBytesLength=tempText.getLength();
}
break;
case INTERVAL_YEAR_MONTH:
{
final boolean invert=columnSortOrderIsDesc[fieldIndex];
int v=inputByteBuffer.read(invert) ^ 0x80;
for (int i=0; i < 3; i++) {
v=(v << 8) + (inputByteBuffer.read(invert) & 0xff);
}
currentHiveIntervalYearMonthWritable.set(v);
}
break;
case INTERVAL_DAY_TIME:
{
final boolean invert=columnSortOrderIsDesc[fieldIndex];
long totalSecs=inputByteBuffer.read(invert) ^ 0x80;
for (int i=0; i < 7; i++) {
totalSecs=(totalSecs << 8) + (inputByteBuffer.read(invert) & 0xff);
}
int nanos=inputByteBuffer.read(invert) ^ 0x80;
for (int i=0; i < 3; i++) {
nanos=(nanos << 8) + (inputByteBuffer.read(invert) & 0xff);
}
currentHiveIntervalDayTimeWritable.set(totalSecs,nanos);
}
break;
case DECIMAL:
{
final boolean invert=columnSortOrderIsDesc[fieldIndex];
int b=inputByteBuffer.read(invert) - 1;
assert(b == 1 || b == -1 || b == 0);
boolean positive=b != -1;
int factor=inputByteBuffer.read(invert) ^ 0x80;
for (int i=0; i < 3; i++) {
factor=(factor << 8) + (inputByteBuffer.read(invert) & 0xff);
}
if (!positive) {
factor=-factor;
}
int start=inputByteBuffer.tell();
int length=0;
do {
b=inputByteBuffer.read(positive ? invert : !invert);
assert(b != 1);
if (b == 0) {
break;
}
length++;
}
 while (true);
if (tempDecimalBuffer == null || tempDecimalBuffer.length < length) {
tempDecimalBuffer=new byte[length];
}
inputByteBuffer.seek(start);
for (int i=0; i < length; ++i) {
tempDecimalBuffer[i]=inputByteBuffer.read(positive ? invert : !invert);
}
inputByteBuffer.read(positive ? invert : !invert);
String digits=new String(tempDecimalBuffer,0,length,BinarySortableSerDe.decimalCharSet);
BigInteger bi=new BigInteger(digits);
HiveDecimal bd=HiveDecimal.create(bi).scaleByPowerOfTen(factor - length);
if (!positive) {
bd=bd.negate();
}
currentHiveDecimalWritable.set(bd);
DecimalTypeInfo decimalTypeInfo=(DecimalTypeInfo)typeInfos[fieldIndex];
int precision=decimalTypeInfo.getPrecision();
int scale=decimalTypeInfo.getScale();
HiveDecimal decimal=currentHiveDecimalWritable.getHiveDecimal(precision,scale);
if (decimal == null) {
isNull=true;
}
 else {
currentHiveDecimalWritable.set(decimal);
}
}
break;
default :
throw new RuntimeException("Unexpected primitive type category " + primitiveCategories[fieldIndex]);
}
if (columnsToInclude != null && !columnsToInclude[fieldIndex]) {
isNull=true;
}
return isNull;
}
