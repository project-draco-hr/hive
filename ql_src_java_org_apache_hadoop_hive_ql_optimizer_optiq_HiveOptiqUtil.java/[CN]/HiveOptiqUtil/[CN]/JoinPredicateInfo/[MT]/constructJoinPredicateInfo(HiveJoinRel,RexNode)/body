{
  JoinPredicateInfo jpi=null;
  JoinLeafPredicateInfo jlpi=null;
  List<JoinLeafPredicateInfo> equiLPIList=new ArrayList<JoinLeafPredicateInfo>();
  List<JoinLeafPredicateInfo> nonEquiLPIList=new ArrayList<JoinLeafPredicateInfo>();
  Set<Integer> projsFromLeftPartOfJoinKeys=new HashSet<Integer>();
  Set<Integer> projsFromRightPartOfJoinKeys=new HashSet<Integer>();
  Set<Integer> projsFromRightPartOfJoinKeysInJoinSchema=new HashSet<Integer>();
  Map<Integer,List<JoinLeafPredicateInfo>> tmpMapOfProjIndxInJoinSchemaToLeafPInfo=new HashMap<Integer,List<JoinLeafPredicateInfo>>();
  Map<Integer,ImmutableList<JoinLeafPredicateInfo>> mapOfProjIndxInJoinSchemaToLeafPInfo=new HashMap<Integer,ImmutableList<JoinLeafPredicateInfo>>();
  List<JoinLeafPredicateInfo> tmpJLPILst=null;
  int rightOffSet=j.getLeft().getRowType().getFieldCount();
  int projIndxInJoin;
  List<RexNode> conjuctiveElements;
  conjuctiveElements=RelOptUtil.conjunctions(predicate);
  for (  RexNode ce : conjuctiveElements) {
    jlpi=JoinLeafPredicateInfo.constructJoinLeafPredicateInfo(j,ce);
    if (jlpi.m_comparisonType.equals(SqlKind.EQUALS)) {
      equiLPIList.add(jlpi);
    }
 else {
      nonEquiLPIList.add(jlpi);
    }
    projsFromLeftPartOfJoinKeys.addAll(jlpi.getProjsFromLeftPartOfJoinKeysInChildSchema());
    projsFromRightPartOfJoinKeys.addAll(jlpi.getProjsFromRightPartOfJoinKeysInChildSchema());
    projsFromRightPartOfJoinKeysInJoinSchema.addAll(jlpi.getProjsFromRightPartOfJoinKeysInJoinSchema());
    for (    Integer projIndx : jlpi.getProjsFromLeftPartOfJoinKeysInChildSchema()) {
      tmpJLPILst=tmpMapOfProjIndxInJoinSchemaToLeafPInfo.get(projIndx);
      if (tmpJLPILst == null)       tmpJLPILst=new ArrayList<JoinLeafPredicateInfo>();
      tmpJLPILst.add(jlpi);
      tmpMapOfProjIndxInJoinSchemaToLeafPInfo.put(projIndx,tmpJLPILst);
    }
    for (    Integer projIndx : jlpi.getProjsFromRightPartOfJoinKeysInChildSchema()) {
      projIndxInJoin=projIndx + rightOffSet;
      tmpJLPILst=tmpMapOfProjIndxInJoinSchemaToLeafPInfo.get(projIndxInJoin);
      if (tmpJLPILst == null)       tmpJLPILst=new ArrayList<JoinLeafPredicateInfo>();
      tmpJLPILst.add(jlpi);
      tmpMapOfProjIndxInJoinSchemaToLeafPInfo.put(projIndxInJoin,tmpJLPILst);
    }
  }
  for (  Entry<Integer,List<JoinLeafPredicateInfo>> e : tmpMapOfProjIndxInJoinSchemaToLeafPInfo.entrySet()) {
    mapOfProjIndxInJoinSchemaToLeafPInfo.put(e.getKey(),ImmutableList.copyOf(e.getValue()));
  }
  jpi=new JoinPredicateInfo(nonEquiLPIList,equiLPIList,projsFromLeftPartOfJoinKeys,projsFromRightPartOfJoinKeys,projsFromRightPartOfJoinKeysInJoinSchema,mapOfProjIndxInJoinSchemaToLeafPInfo);
  return jpi;
}
