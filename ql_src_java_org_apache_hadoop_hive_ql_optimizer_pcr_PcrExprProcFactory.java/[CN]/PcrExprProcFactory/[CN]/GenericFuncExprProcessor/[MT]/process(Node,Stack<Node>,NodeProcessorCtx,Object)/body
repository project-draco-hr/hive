{
  PcrExprProcCtx ctx=(PcrExprProcCtx)procCtx;
  ExprNodeGenericFuncDesc fd=(ExprNodeGenericFuncDesc)nd;
  if (FunctionRegistry.isOpNot(fd)) {
    assert(nodeOutputs.length == 1);
    NodeInfoWrapper wrapper=(NodeInfoWrapper)nodeOutputs[0];
    if (wrapper.state == WalkState.TRUE) {
      ExprNodeConstantDesc falseDesc=new ExprNodeConstantDesc(wrapper.outExpr.getTypeInfo(),Boolean.FALSE);
      return new NodeInfoWrapper(WalkState.FALSE,null,falseDesc);
    }
 else     if (wrapper.state == WalkState.FALSE) {
      ExprNodeConstantDesc trueDesc=new ExprNodeConstantDesc(wrapper.outExpr.getTypeInfo(),Boolean.TRUE);
      return new NodeInfoWrapper(WalkState.TRUE,null,trueDesc);
    }
 else     if (wrapper.state == WalkState.DIVIDED) {
      Boolean[] results=new Boolean[ctx.getPartList().size()];
      for (int i=0; i < ctx.getPartList().size(); i++) {
        results[i]=opNot(wrapper.ResultVector[i]);
      }
      return new NodeInfoWrapper(WalkState.DIVIDED,results,getOutExpr(fd,nodeOutputs));
    }
 else {
      return new NodeInfoWrapper(wrapper.state,null,getOutExpr(fd,nodeOutputs));
    }
  }
 else   if (FunctionRegistry.isOpAnd(fd)) {
    boolean anyUnknown=false;
    boolean allDivided=true;
    List<NodeInfoWrapper> newNodeOutputsList=new ArrayList<NodeInfoWrapper>(nodeOutputs.length);
    for (int i=0; i < nodeOutputs.length; i++) {
      NodeInfoWrapper c=(NodeInfoWrapper)nodeOutputs[i];
      if (c.state == WalkState.FALSE) {
        return c;
      }
      if (c.state == WalkState.UNKNOWN) {
        anyUnknown=true;
      }
      if (c.state != WalkState.DIVIDED) {
        allDivided=false;
      }
      if (c.state != WalkState.TRUE) {
        newNodeOutputsList.add(c);
      }
    }
    if (newNodeOutputsList.size() == 0) {
      return new NodeInfoWrapper(WalkState.TRUE,null,new ExprNodeConstantDesc(fd.getTypeInfo(),Boolean.TRUE));
    }
    if (newNodeOutputsList.size() == 1) {
      return newNodeOutputsList.get(0);
    }
    Object[] newNodeOutputs=newNodeOutputsList.toArray();
    if (anyUnknown) {
      return new NodeInfoWrapper(WalkState.UNKNOWN,null,getOutExpr(fd,newNodeOutputs));
    }
    if (allDivided) {
      Boolean[] results=new Boolean[ctx.getPartList().size()];
      for (int i=0; i < ctx.getPartList().size(); i++) {
        Boolean[] andArray=new Boolean[newNodeOutputs.length];
        for (int j=0; j < newNodeOutputs.length; j++) {
          andArray[j]=((NodeInfoWrapper)newNodeOutputs[j]).ResultVector[i];
        }
        results[i]=opAnd(andArray);
      }
      return getResultWrapFromResults(results,fd,newNodeOutputs);
    }
    return new NodeInfoWrapper(WalkState.UNKNOWN,null,getOutExpr(fd,newNodeOutputs));
  }
 else   if (FunctionRegistry.isOpOr(fd)) {
    boolean anyUnknown=false;
    boolean allDivided=true;
    List<NodeInfoWrapper> newNodeOutputsList=new ArrayList<NodeInfoWrapper>(nodeOutputs.length);
    for (int i=0; i < nodeOutputs.length; i++) {
      NodeInfoWrapper c=(NodeInfoWrapper)nodeOutputs[i];
      if (c.state == WalkState.TRUE) {
        return c;
      }
      if (c.state == WalkState.UNKNOWN) {
        anyUnknown=true;
      }
      if (c.state != WalkState.DIVIDED) {
        allDivided=false;
      }
      if (c.state != WalkState.FALSE) {
        newNodeOutputsList.add(c);
      }
    }
    if (newNodeOutputsList.size() == 0) {
      return new NodeInfoWrapper(WalkState.FALSE,null,new ExprNodeConstantDesc(fd.getTypeInfo(),Boolean.FALSE));
    }
    if (newNodeOutputsList.size() == 1) {
      return newNodeOutputsList.get(0);
    }
    Object[] newNodeOutputs=newNodeOutputsList.toArray();
    if (anyUnknown) {
      return new NodeInfoWrapper(WalkState.UNKNOWN,null,getOutExpr(fd,newNodeOutputs));
    }
    if (allDivided) {
      Boolean[] results=new Boolean[ctx.getPartList().size()];
      for (int i=0; i < ctx.getPartList().size(); i++) {
        Boolean[] orArray=new Boolean[newNodeOutputs.length];
        for (int j=0; j < newNodeOutputs.length; j++) {
          orArray[j]=((NodeInfoWrapper)newNodeOutputs[j]).ResultVector[i];
        }
        results[i]=opOr(orArray);
      }
      return getResultWrapFromResults(results,fd,newNodeOutputs);
    }
    return new NodeInfoWrapper(WalkState.UNKNOWN,null,getOutExpr(fd,newNodeOutputs));
  }
 else   if (!FunctionRegistry.isDeterministic(fd.getGenericUDF())) {
    return new NodeInfoWrapper(WalkState.UNKNOWN,null,getOutExpr(fd,nodeOutputs));
  }
 else {
    boolean has_part_col=false;
    for (    Object child : nodeOutputs) {
      NodeInfoWrapper wrapper=(NodeInfoWrapper)child;
      if (wrapper.state == WalkState.UNKNOWN) {
        return new NodeInfoWrapper(WalkState.UNKNOWN,null,getOutExpr(fd,nodeOutputs));
      }
 else       if (wrapper.state == WalkState.PART_COL) {
        has_part_col=true;
      }
    }
    if (has_part_col && fd.getTypeInfo().getCategory() == Category.PRIMITIVE) {
      if (fd.getTypeInfo().equals(TypeInfoFactory.booleanTypeInfo)) {
        Boolean[] results=new Boolean[ctx.getPartList().size()];
        for (int i=0; i < ctx.getPartList().size(); i++) {
          results[i]=(Boolean)evalExprWithPart(fd,ctx.getPartList().get(i),ctx.getVirtualColumns());
        }
        return getResultWrapFromResults(results,fd,nodeOutputs);
      }
      Object[] results=new Object[ctx.getPartList().size()];
      for (int i=0; i < ctx.getPartList().size(); i++) {
        results[i]=evalExprWithPart(fd,ctx.getPartList().get(i),ctx.getVirtualColumns());
      }
      Object result=ifResultsAgree(results);
      if (result == null) {
        return new NodeInfoWrapper(WalkState.UNKNOWN,null,getOutExpr(fd,nodeOutputs));
      }
      return new NodeInfoWrapper(WalkState.CONSTANT,null,new ExprNodeConstantDesc(fd.getTypeInfo(),result));
    }
    return new NodeInfoWrapper(WalkState.CONSTANT,null,getOutExpr(fd,nodeOutputs));
  }
}
