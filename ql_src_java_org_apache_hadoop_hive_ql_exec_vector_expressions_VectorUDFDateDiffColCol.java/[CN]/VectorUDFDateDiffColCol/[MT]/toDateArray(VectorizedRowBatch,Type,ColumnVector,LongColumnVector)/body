{
  int size=batch.size;
  if (colType == Type.DATE) {
    return (LongColumnVector)inputColVector;
  }
  if (size > dateVector.vector.length) {
    if (dateVector1 == dateVector) {
      dateVector1=new LongColumnVector(size * 2);
      dateVector=dateVector1;
    }
 else {
      dateVector2=new LongColumnVector(size * 2);
      dateVector=dateVector2;
    }
  }
switch (colType) {
case TIMESTAMP:
    LongColumnVector lcv=(LongColumnVector)inputColVector;
  lcv.copySelected(batch.selectedInUse,batch.selected,batch.size,dateVector);
if (dateVector.isRepeating) {
  date.setTime(dateVector.vector[0] / 1000000);
  dateVector.vector[0]=DateWritable.dateToDays(date);
}
 else {
  if (batch.selectedInUse) {
    for (int j=0; j != size; j++) {
      int i=batch.selected[j];
      if (!dateVector.isNull[i]) {
        date.setTime(dateVector.vector[i] / 1000000);
        dateVector.vector[i]=DateWritable.dateToDays(date);
      }
    }
  }
 else {
    for (int i=0; i != size; i++) {
      if (!dateVector.isNull[i]) {
        date.setTime(dateVector.vector[i] / 1000000);
        dateVector.vector[i]=DateWritable.dateToDays(date);
      }
    }
  }
}
return dateVector;
case STRING:
case CHAR:
case VARCHAR:
BytesColumnVector bcv=(BytesColumnVector)inputColVector;
copySelected(bcv,batch.selectedInUse,batch.selected,batch.size,dateVector);
return dateVector;
default :
throw new Error("Unsupported input type " + colType.name());
}
}
