{
  DAG dag=DAG.create(work.getName());
  dag.setCredentials(job.getCredentials());
  DagUtils utils=DagUtils.getInstance();
  Context ctx=new Context(job);
  MapWork mapWork=(MapWork)work.getAllWork().get(0);
  JobConf wxConf=utils.initializeVertexConf(job,ctx,mapWork);
  Path scratchDir=utils.createTezDir(ctx.getMRScratchDir(),job);
  FileSystem fs=scratchDir.getFileSystem(job);
  try {
    LocalResource appJarLr=createJarLocalResource(utils.getExecJarPathLocal(),utils,job);
    Vertex wx=utils.createVertex(wxConf,mapWork,scratchDir,appJarLr,new ArrayList<LocalResource>(),fs,ctx,false,work,work.getVertexType(mapWork));
    dag.addVertex(wx);
    utils.addCredentials(mapWork,dag);
    HiveSplitGenerator splitGenerator=new HiveSplitGenerator(null);
    splitGenerator.initializeSplitGenerator(wxConf,mapWork);
    List<Event> eventList=splitGenerator.initialize();
    InputSplit[] result=new InputSplit[eventList.size()];
    int i=0;
    ByteArrayOutputStream bos=new ByteArrayOutputStream(10240);
    InputConfigureVertexTasksEvent configureEvent=(InputConfigureVertexTasksEvent)eventList.remove(0);
    List<TaskLocationHint> hints=configureEvent.getLocationHint().getTaskLocationHints();
    for (    Event event : eventList) {
      TaskLocationHint hint=hints.remove(0);
      Set<String> hosts=hint.getHosts();
      SplitLocationInfo[] locations=new SplitLocationInfo[hosts.size()];
      int j=0;
      for (      String host : hosts) {
        locations[j++]=new SplitLocationInfo(host,false);
      }
      bos.reset();
      Kryo kryo=SerializationUtilities.borrowKryo();
      SerializationUtilities.serializeObjectByKryo(kryo,event,bos);
      SerializationUtilities.releaseKryo(kryo);
      result[i++]=new LlapInputSplit(bos.toByteArray(),locations,schema);
    }
    return result;
  }
 catch (  Exception e) {
    throw new IOException(e);
  }
}
