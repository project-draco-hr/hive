{
  getStream();
  if (buildIndex && rowsInIndex != 0) {
    createRowIndexEntry();
  }
  if (rowsInStripe != 0) {
    if (callback != null) {
      callback.preStripeWrite(callbackContext);
    }
    int requiredIndexEntries=rowIndexStride == 0 ? 0 : (int)((rowsInStripe + rowIndexStride - 1) / rowIndexStride);
    OrcProto.StripeFooter.Builder builder=OrcProto.StripeFooter.newBuilder();
    treeWriter.writeStripe(builder,requiredIndexEntries);
    long indexSize=0;
    long dataSize=0;
    for (    Map.Entry<StreamName,BufferedStream> pair : streams.entrySet()) {
      BufferedStream stream=pair.getValue();
      if (!stream.isSuppressed()) {
        stream.flush();
        StreamName name=pair.getKey();
        long streamSize=pair.getValue().getOutputSize();
        builder.addStreams(OrcProto.Stream.newBuilder().setColumn(name.getColumn()).setKind(name.getKind()).setLength(streamSize));
        if (StreamName.Area.INDEX == name.getArea()) {
          indexSize+=streamSize;
        }
 else {
          dataSize+=streamSize;
        }
      }
    }
    OrcProto.StripeFooter footer=builder.build();
    long start=rawWriter.getPos();
    final long currentStripeSize=indexSize + dataSize + footer.getSerializedSize();
    final long available=blockSize - (start % blockSize);
    final long overflow=currentStripeSize - adjustedStripeSize;
    final float availRatio=(float)available / (float)defaultStripeSize;
    if (availRatio > 0.0f && availRatio < 1.0f && availRatio > paddingTolerance) {
      float correction=overflow > 0 ? (float)overflow / (float)adjustedStripeSize : 0.0f;
      correction=correction > paddingTolerance ? paddingTolerance : correction;
      adjustedStripeSize=(long)((1.0f - correction) * (availRatio * defaultStripeSize));
    }
 else     if (availRatio >= 1.0) {
      adjustedStripeSize=defaultStripeSize;
    }
    if (availRatio < paddingTolerance && addBlockPadding) {
      long padding=blockSize - (start % blockSize);
      byte[] pad=new byte[(int)Math.min(HDFS_BUFFER_SIZE,padding)];
      LOG.info(String.format("Padding ORC by %d bytes (<=  %.2f * %d)",padding,availRatio,defaultStripeSize));
      start+=padding;
      while (padding > 0) {
        int writeLen=(int)Math.min(padding,pad.length);
        rawWriter.write(pad,0,writeLen);
        padding-=writeLen;
      }
      adjustedStripeSize=defaultStripeSize;
    }
 else     if (currentStripeSize < blockSize && (start % blockSize) + currentStripeSize > blockSize) {
      adjustedStripeSize=defaultStripeSize;
    }
    for (    Map.Entry<StreamName,BufferedStream> pair : streams.entrySet()) {
      BufferedStream stream=pair.getValue();
      if (!stream.isSuppressed()) {
        stream.spillTo(rawWriter);
      }
      stream.clear();
    }
    footer.writeTo(protobufWriter);
    protobufWriter.flush();
    writer.flush();
    long footerLength=rawWriter.getPos() - start - dataSize- indexSize;
    OrcProto.StripeInformation dirEntry=OrcProto.StripeInformation.newBuilder().setOffset(start).setNumberOfRows(rowsInStripe).setIndexLength(indexSize).setDataLength(dataSize).setFooterLength(footerLength).build();
    stripes.add(dirEntry);
    rowCount+=rowsInStripe;
    rowsInStripe=0;
  }
}
