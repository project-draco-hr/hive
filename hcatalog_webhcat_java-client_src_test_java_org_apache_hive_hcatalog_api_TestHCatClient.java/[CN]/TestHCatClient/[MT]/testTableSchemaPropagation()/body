{
  try {
    startReplicationTargetMetaStoreIfRequired();
    HCatClient sourceMetaStore=HCatClient.create(new Configuration(hcatConf));
    final String dbName="myDb";
    final String tableName="myTable";
    sourceMetaStore.dropDatabase(dbName,true,HCatClient.DropDBMode.CASCADE);
    sourceMetaStore.createDatabase(HCatCreateDBDesc.create(dbName).build());
    List<HCatFieldSchema> columnSchema=Arrays.asList(new HCatFieldSchema("foo",Type.INT,""),new HCatFieldSchema("bar",Type.STRING,""));
    List<HCatFieldSchema> partitionSchema=Arrays.asList(new HCatFieldSchema("dt",Type.STRING,""),new HCatFieldSchema("grid",Type.STRING,""));
    HCatTable sourceTable=new HCatTable(dbName,tableName).cols(columnSchema).partCols(partitionSchema);
    sourceMetaStore.createTable(HCatCreateTableDesc.create(sourceTable).build());
    sourceTable=sourceMetaStore.getTable(dbName,tableName);
    assertNotNull("Table couldn't be queried for. ",sourceTable);
    String tableStringRep=sourceMetaStore.serializeTable(sourceTable);
    HCatClient targetMetaStore=HCatClient.create(new Configuration(replicationTargetHCatConf));
    targetMetaStore.dropDatabase(dbName,true,HCatClient.DropDBMode.CASCADE);
    targetMetaStore.createDatabase(HCatCreateDBDesc.create(dbName).build());
    HCatTable targetTable=targetMetaStore.deserializeTable(tableStringRep);
    assertEquals("Table after deserialization should have been identical to sourceTable.",sourceTable.diff(targetTable),HCatTable.NO_DIFF);
    targetMetaStore.createTable(HCatCreateTableDesc.create(targetTable).build());
    targetTable=targetMetaStore.getTable(dbName,tableName);
    assertEquals("Table after deserialization should have been identical to sourceTable.",sourceTable.diff(targetTable),HCatTable.NO_DIFF);
    List<HCatFieldSchema> newColumnSchema=new ArrayList<HCatFieldSchema>(columnSchema);
    newColumnSchema.add(new HCatFieldSchema("goo_new",Type.DOUBLE,""));
    Map<String,String> tableParams=new HashMap<String,String>(1);
    tableParams.put("orc.compress","ZLIB");
    sourceTable.cols(newColumnSchema).fileFormat("orcfile").tblProps(tableParams).serdeParam(serdeConstants.FIELD_DELIM,Character.toString('\001'));
    sourceMetaStore.updateTableSchema(dbName,tableName,sourceTable);
    sourceTable=sourceMetaStore.getTable(dbName,tableName);
    EnumSet<HCatTable.TableAttribute> diff=targetTable.diff(sourceTable);
    assertTrue("Couldn't find change in column-schema.",diff.contains(HCatTable.TableAttribute.COLUMNS));
    assertTrue("Couldn't find change in InputFormat.",diff.contains(HCatTable.TableAttribute.INPUT_FORMAT));
    assertTrue("Couldn't find change in OutputFormat.",diff.contains(HCatTable.TableAttribute.OUTPUT_FORMAT));
    assertTrue("Couldn't find change in SerDe.",diff.contains(HCatTable.TableAttribute.SERDE));
    assertTrue("Couldn't find change in SerDe parameters.",diff.contains(HCatTable.TableAttribute.SERDE_PROPERTIES));
    assertTrue("Couldn't find change in Table parameters.",diff.contains(HCatTable.TableAttribute.TABLE_PROPERTIES));
    targetMetaStore.updateTableSchema(dbName,tableName,targetTable.resolve(sourceTable,diff));
    targetTable=targetMetaStore.getTable(dbName,tableName);
    assertEquals("After propagating schema changes, source and target tables should have been equivalent.",targetTable.diff(sourceTable),HCatTable.NO_DIFF);
  }
 catch (  Exception unexpected) {
    LOG.error("Unexpected exception!",unexpected);
    assertTrue("Unexpected exception! " + unexpected.getMessage(),false);
  }
}
