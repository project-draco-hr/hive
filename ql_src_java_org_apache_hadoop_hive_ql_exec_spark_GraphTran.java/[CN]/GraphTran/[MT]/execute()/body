{
  Map<SparkTran,JavaPairRDD<HiveKey,BytesWritable>> resultRDDs=new HashMap<SparkTran,JavaPairRDD<HiveKey,BytesWritable>>();
  for (  SparkTran tran : rootTrans) {
    if (!(tran instanceof MapTran)) {
      throw new IllegalStateException("root transformations must be MapTran!");
    }
    JavaPairRDD<BytesWritable,BytesWritable> input=mapInputs.get(tran);
    if (input == null) {
      throw new IllegalStateException("input is missing for transformation!");
    }
    JavaPairRDD<HiveKey,BytesWritable> rdd=tran.transform(input);
    while (getChildren(tran).size() > 0) {
      SparkTran childTran=getChildren(tran).get(0);
      if (childTran instanceof UnionTran) {
        List<JavaPairRDD<HiveKey,BytesWritable>> unionInputList=unionInputs.get(childTran);
        if (unionInputList == null) {
          unionInputList=new LinkedList<JavaPairRDD<HiveKey,BytesWritable>>();
          unionInputList.add(rdd);
          unionInputs.put(childTran,unionInputList);
          break;
        }
 else         if (unionInputList.size() < this.getParents(childTran).size() - 1) {
          unionInputList.add(rdd);
          break;
        }
 else         if (unionInputList.size() == this.getParents(childTran).size() - 1) {
          for (          JavaPairRDD<HiveKey,BytesWritable> inputRDD : unionInputList) {
            ((UnionTran)childTran).setOtherInput(inputRDD);
            rdd=childTran.transform(rdd);
          }
        }
      }
 else {
        rdd=childTran.transform(rdd);
      }
      tran=childTran;
    }
    if (!resultRDDs.containsKey(tran) && getChildren(tran).isEmpty()) {
      resultRDDs.put(tran,rdd);
    }
  }
  for (  JavaPairRDD<HiveKey,BytesWritable> resultRDD : resultRDDs.values()) {
    resultRDD.foreach(HiveVoidFunction.getInstance());
  }
}
