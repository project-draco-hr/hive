{
  if (fieldIndex == -1) {
    parse();
    fieldIndex=0;
  }
 else   if (fieldIndex + 1 >= fieldCount) {
    return true;
  }
 else {
    fieldIndex++;
  }
  if (columnsToInclude != null && !columnsToInclude[fieldIndex]) {
    return true;
  }
  fieldStart=startPosition[fieldIndex];
  fieldLength=startPosition[fieldIndex + 1] - startPosition[fieldIndex] - 1;
  if (fieldLength < 0) {
    return true;
  }
  if (nullSequenceBytes != null) {
    if (fieldLength == nullSequenceBytes.length) {
      int i=0;
      while (true) {
        if (bytes[fieldStart + i] != nullSequenceBytes[i]) {
          break;
        }
        i++;
        if (i >= fieldLength) {
          return true;
        }
      }
    }
  }
switch (primitiveCategories[fieldIndex]) {
case BOOLEAN:
{
      int i=fieldStart;
      if (fieldLength == 4) {
        if ((bytes[i] == 'T' || bytes[i] == 't') && (bytes[i + 1] == 'R' || bytes[i + 1] == 'r') && (bytes[i + 2] == 'U' || bytes[i + 1] == 'u')&& (bytes[i + 3] == 'E' || bytes[i + 3] == 'e')) {
          currentBoolean=true;
        }
 else {
          return true;
        }
      }
 else       if (fieldLength == 5) {
        if ((bytes[i] == 'F' || bytes[i] == 'f') && (bytes[i + 1] == 'A' || bytes[i + 1] == 'a') && (bytes[i + 2] == 'L' || bytes[i + 2] == 'l')&& (bytes[i + 3] == 'S' || bytes[i + 3] == 's')&& (bytes[i + 4] == 'E' || bytes[i + 4] == 'e')) {
          currentBoolean=false;
        }
 else {
          return true;
        }
      }
 else       if (isExtendedBooleanLiteral && fieldLength == 1) {
        byte b=bytes[fieldStart];
        if (b == '1' || b == 't' || b == 'T') {
          currentBoolean=true;
        }
 else         if (b == '0' || b == 'f' || b == 'F') {
          currentBoolean=false;
        }
 else {
          return true;
        }
      }
 else {
        return true;
      }
    }
  break;
case BYTE:
if (!LazyUtils.isNumberMaybe(bytes,fieldStart,fieldLength)) {
  return true;
}
try {
currentByte=LazyByte.parseByte(bytes,fieldStart,fieldLength,10);
}
 catch (NumberFormatException e) {
logExceptionMessage(bytes,fieldStart,fieldLength,"TINYINT");
return true;
}
break;
case SHORT:
if (!LazyUtils.isNumberMaybe(bytes,fieldStart,fieldLength)) {
return true;
}
try {
currentShort=LazyShort.parseShort(bytes,fieldStart,fieldLength,10);
}
 catch (NumberFormatException e) {
logExceptionMessage(bytes,fieldStart,fieldLength,"SMALLINT");
return true;
}
break;
case INT:
if (!LazyUtils.isNumberMaybe(bytes,fieldStart,fieldLength)) {
return true;
}
try {
currentInt=LazyInteger.parseInt(bytes,fieldStart,fieldLength,10);
}
 catch (NumberFormatException e) {
logExceptionMessage(bytes,fieldStart,fieldLength,"INT");
return true;
}
break;
case LONG:
if (!LazyUtils.isNumberMaybe(bytes,fieldStart,fieldLength)) {
return true;
}
try {
currentLong=LazyLong.parseLong(bytes,fieldStart,fieldLength,10);
}
 catch (NumberFormatException e) {
logExceptionMessage(bytes,fieldStart,fieldLength,"BIGINT");
return true;
}
break;
case FLOAT:
{
if (!LazyUtils.isNumberMaybe(bytes,fieldStart,fieldLength)) {
return true;
}
String byteData=null;
try {
byteData=Text.decode(bytes,fieldStart,fieldLength);
currentFloat=Float.parseFloat(byteData);
}
 catch (NumberFormatException e) {
LOG.debug("Data not in the Float data type range so converted to null. Given data is :" + byteData,e);
return true;
}
catch (CharacterCodingException e) {
LOG.debug("Data not in the Float data type range so converted to null.",e);
return true;
}
}
break;
case DOUBLE:
{
if (!LazyUtils.isNumberMaybe(bytes,fieldStart,fieldLength)) {
return true;
}
String byteData=null;
try {
byteData=Text.decode(bytes,fieldStart,fieldLength);
currentDouble=Double.parseDouble(byteData);
}
 catch (NumberFormatException e) {
LOG.debug("Data not in the Double data type range so converted to null. Given data is :" + byteData,e);
return true;
}
catch (CharacterCodingException e) {
LOG.debug("Data not in the Double data type range so converted to null.",e);
return true;
}
}
break;
case STRING:
case CHAR:
case VARCHAR:
{
if (isEscaped) {
int outputLength=0;
for (int i=0; i < fieldLength; i++) {
if (bytes[fieldStart + i] != escapeChar) {
outputLength++;
}
 else {
outputLength++;
i++;
}
}
if (outputLength == fieldLength) {
currentExternalBufferNeeded=false;
currentBytes=bytes;
currentBytesStart=fieldStart;
currentBytesLength=outputLength;
}
 else {
if (useExternalBuffer) {
currentExternalBufferNeeded=true;
currentExternalBufferNeededLen=outputLength;
}
 else {
currentExternalBufferNeeded=false;
if (internalBufferLen < outputLength) {
internalBufferLen=outputLength;
internalBuffer=new byte[internalBufferLen];
}
copyToBuffer(internalBuffer,0,outputLength);
currentBytes=internalBuffer;
currentBytesStart=0;
currentBytesLength=outputLength;
}
}
}
 else {
currentExternalBufferNeeded=false;
currentBytes=bytes;
currentBytesStart=fieldStart;
currentBytesLength=fieldLength;
}
}
break;
case BINARY:
{
byte[] recv=new byte[fieldLength];
System.arraycopy(bytes,fieldStart,recv,0,fieldLength);
byte[] decoded=LazyBinary.decodeIfNeeded(recv);
decoded=decoded.length > 0 ? decoded : recv;
currentBytes=decoded;
currentBytesStart=0;
currentBytesLength=decoded.length;
}
break;
case DATE:
{
if (!LazyUtils.isDateMaybe(bytes,fieldStart,fieldLength)) {
return true;
}
String s=null;
try {
s=Text.decode(bytes,fieldStart,fieldLength);
currentDateWritable.set(Date.valueOf(s));
}
 catch (Exception e) {
logExceptionMessage(bytes,fieldStart,fieldLength,"DATE");
return true;
}
}
break;
case TIMESTAMP:
{
if (!LazyUtils.isDateMaybe(bytes,fieldStart,fieldLength)) {
return true;
}
String s=null;
try {
s=new String(bytes,fieldStart,fieldLength,"US-ASCII");
}
 catch (UnsupportedEncodingException e) {
LOG.error("Unsupported encoding found ",e);
s="";
}
if (s.compareTo("NULL") == 0) {
logExceptionMessage(bytes,fieldStart,fieldLength,"TIMESTAMP");
return true;
}
 else {
try {
if (timestampParser == null) {
timestampParser=new TimestampParser();
}
currentTimestampWritable.set(timestampParser.parseTimestamp(s));
}
 catch (IllegalArgumentException e) {
logExceptionMessage(bytes,fieldStart,fieldLength,"TIMESTAMP");
return true;
}
}
}
break;
case INTERVAL_YEAR_MONTH:
{
if (fieldLength == 0) {
return true;
}
String s=null;
try {
s=Text.decode(bytes,fieldStart,fieldLength);
currentHiveIntervalYearMonthWritable.set(HiveIntervalYearMonth.valueOf(s));
}
 catch (Exception e) {
logExceptionMessage(bytes,fieldStart,fieldLength,"INTERVAL_YEAR_MONTH");
return true;
}
}
break;
case INTERVAL_DAY_TIME:
{
if (fieldLength == 0) {
return true;
}
String s=null;
try {
s=Text.decode(bytes,fieldStart,fieldLength);
currentHiveIntervalDayTimeWritable.set(HiveIntervalDayTime.valueOf(s));
}
 catch (Exception e) {
logExceptionMessage(bytes,fieldStart,fieldLength,"INTERVAL_DAY_TIME");
return true;
}
}
break;
case DECIMAL:
{
if (!LazyUtils.isNumberMaybe(bytes,fieldStart,fieldLength)) {
return true;
}
String byteData=null;
try {
byteData=Text.decode(bytes,fieldStart,fieldLength);
}
 catch (CharacterCodingException e) {
LOG.debug("Data not in the HiveDecimal data type range so converted to null.",e);
return true;
}
HiveDecimal decimal=HiveDecimal.create(byteData);
DecimalTypeInfo decimalTypeInfo=(DecimalTypeInfo)typeInfos[fieldIndex];
int precision=decimalTypeInfo.getPrecision();
int scale=decimalTypeInfo.getScale();
decimal=HiveDecimal.enforcePrecisionScale(decimal,precision,scale);
if (decimal == null) {
LOG.debug("Data not in the HiveDecimal data type range so converted to null. Given data is :" + byteData);
return true;
}
currentHiveDecimalWritable.set(decimal);
}
break;
default :
throw new Error("Unexpected primitive category " + primitiveCategories[fieldIndex].name());
}
return false;
}
