{
  ExprNodeTempDesc tempDesc=genSimpleExprNodeDesc(expr);
  if (tempDesc != null) {
    return tempDesc;
  }
  int tokType=expr.getType();
switch (tokType) {
case HiveParser.TOK_TABLE_OR_COL:
{
      String tableOrCol=BaseSemanticAnalyzer.unescapeIdentifier(expr.getChild(0).getText());
      if (metaData.getAliasToTable().get(tableOrCol.toLowerCase()) != null) {
        tempDesc=new ExprNodeTempDesc(tableOrCol);
      }
 else {
        String colName=tableOrCol;
        String tabAlias=SemanticAnalyzer.getTabAliasForCol(this.metaData,colName,(ASTNode)expr.getChild(0));
        LOG.debug("getTableColumnDesc(" + tabAlias + ", "+ colName);
        tempDesc=getTableColumnDesc(tabAlias,colName);
      }
      break;
    }
default :
{
    boolean isFunction=(expr.getType() == HiveParser.TOK_FUNCTION);
    int childrenBegin=(isFunction ? 1 : 0);
    ArrayList<ExprNodeTempDesc> tempChildren=new ArrayList<ExprNodeTempDesc>(expr.getChildCount() - childrenBegin);
    for (int ci=childrenBegin; ci < expr.getChildCount(); ci++) {
      ExprNodeTempDesc child=genExprNodeDesc((ASTNode)expr.getChild(ci));
      tempChildren.add(child);
    }
    if (expr.getType() == HiveParser.DOT && tempChildren.get(0).getIsTableName()) {
      String tabAlias=tempChildren.get(0).getTableName();
      String colName=((exprNodeConstantDesc)tempChildren.get(1).getDesc()).getValue().toString();
      tempDesc=getTableColumnDesc(tabAlias,colName);
    }
 else {
      ArrayList<exprNodeDesc> children=new ArrayList<exprNodeDesc>(expr.getChildCount() - childrenBegin);
      for (int ci=0; ci < tempChildren.size(); ci++) {
        children.add(tempChildren.get(ci).getDesc());
      }
      exprNodeDesc desc=null;
      try {
        desc=TypeCheckProcFactory.DefaultExprProcessor.getXpathOrFuncExprNodeDesc(expr,isFunction,children);
      }
 catch (      UDFArgumentTypeException e) {
        throw new SemanticException(ErrorMsg.INVALID_ARGUMENT_TYPE.getMsg(expr.getChild(childrenBegin + e.getArgumentId()),e.getMessage()));
      }
catch (      UDFArgumentLengthException e) {
        throw new SemanticException(ErrorMsg.INVALID_ARGUMENT_LENGTH.getMsg(expr,e.getMessage()));
      }
catch (      UDFArgumentException e) {
        throw new SemanticException(ErrorMsg.INVALID_ARGUMENT.getMsg(expr,e.getMessage()));
      }
      if (desc instanceof exprNodeFuncDesc && (((exprNodeFuncDesc)desc).getUDFMethod().getDeclaringClass().equals(UDFOPAnd.class) || ((exprNodeFuncDesc)desc).getUDFMethod().getDeclaringClass().equals(UDFOPOr.class) || ((exprNodeFuncDesc)desc).getUDFMethod().getDeclaringClass().equals(UDFOPNot.class))) {
      }
 else       if (mightBeUnknown(desc) || (desc instanceof exprNodeFuncDesc && ((exprNodeFuncDesc)desc).getUDFClass().getAnnotation(UDFType.class) != null && ((exprNodeFuncDesc)desc).getUDFClass().getAnnotation(UDFType.class).deterministic() == false) || (desc instanceof exprNodeGenericFuncDesc && ((exprNodeGenericFuncDesc)desc).getGenericUDFClass().getAnnotation(UDFType.class) != null && ((exprNodeGenericFuncDesc)desc).getGenericUDFClass().getAnnotation(UDFType.class).deterministic() == false)) {
        LOG.trace("Pruner function might be unknown: " + expr.toStringTree());
        desc=new exprNodeConstantDesc(desc.getTypeInfo(),null);
      }
      tempDesc=new ExprNodeTempDesc(desc);
    }
    break;
  }
}
return tempDesc;
}
