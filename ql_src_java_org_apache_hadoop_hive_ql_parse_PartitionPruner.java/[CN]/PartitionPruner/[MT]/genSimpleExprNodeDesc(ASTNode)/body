{
  exprNodeDesc desc=null;
switch (expr.getType()) {
case HiveParser.TOK_NULL:
    desc=new exprNodeNullDesc();
  break;
case HiveParser.Identifier:
desc=new exprNodeConstantDesc(TypeInfoFactory.stringTypeInfo,SemanticAnalyzer.unescapeIdentifier(expr.getText()));
break;
case HiveParser.Number:
Number v=null;
try {
v=Double.valueOf(expr.getText());
v=Long.valueOf(expr.getText());
v=Integer.valueOf(expr.getText());
}
 catch (NumberFormatException e) {
}
if (v == null) {
throw new SemanticException(ErrorMsg.INVALID_NUMERICAL_CONSTANT.getMsg(expr));
}
desc=new exprNodeConstantDesc(v);
break;
case HiveParser.StringLiteral:
desc=new exprNodeConstantDesc(TypeInfoFactory.stringTypeInfo,BaseSemanticAnalyzer.unescapeSQLString(expr.getText()));
break;
case HiveParser.TOK_CHARSETLITERAL:
desc=new exprNodeConstantDesc(BaseSemanticAnalyzer.charSetString(expr.getChild(0).getText(),expr.getChild(1).getText()));
break;
case HiveParser.KW_TRUE:
desc=new exprNodeConstantDesc(Boolean.TRUE);
break;
case HiveParser.KW_FALSE:
desc=new exprNodeConstantDesc(Boolean.FALSE);
break;
}
return desc == null ? null : new ExprNodeTempDesc(desc);
}
