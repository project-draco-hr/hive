{
  exprNodeDesc desc=null;
  desc=SemanticAnalyzer.genSimpleExprNodeDesc(expr);
  if (desc != null) {
    return desc;
  }
  int tokType=expr.getType();
switch (tokType) {
case HiveParser.TOK_COLREF:
{
      assert(expr.getChildCount() == 2);
      String tabAlias=SemanticAnalyzer.getTableName(expr);
      String colName=SemanticAnalyzer.getSerDeFieldExpression(expr);
      if (tabAlias == null || colName == null) {
        throw new SemanticException(ErrorMsg.INVALID_XPATH.getMsg(expr));
      }
      if (tabAlias.equals(tableAlias) && tab.isPartitionKey(colName)) {
        desc=new exprNodeColumnDesc(String.class,colName);
      }
 else {
        TypeInfo typeInfo=new TypeInfo(this.metaData.getTableForAlias(tabAlias).getSerDe(),null);
        desc=new exprNodeConstantDesc(typeInfo.getFieldType(colName),null);
      }
      break;
    }
default :
{
    boolean isFunction=(expr.getType() == HiveParser.TOK_FUNCTION);
    int childrenBegin=(isFunction ? 1 : 0);
    ArrayList<exprNodeDesc> children=new ArrayList<exprNodeDesc>(expr.getChildCount() - childrenBegin);
    for (int ci=childrenBegin; ci < expr.getChildCount(); ci++) {
      children.add(genExprNodeDesc((CommonTree)expr.getChild(ci)));
    }
    desc=SemanticAnalyzer.getXpathOrFuncExprNodeDesc(expr,isFunction,children);
    if (desc instanceof exprNodeFuncDesc && (((exprNodeFuncDesc)desc).getUDFMethod().getDeclaringClass().equals(UDFOPAnd.class) || ((exprNodeFuncDesc)desc).getUDFMethod().getDeclaringClass().equals(UDFOPOr.class) || ((exprNodeFuncDesc)desc).getUDFMethod().getDeclaringClass().equals(UDFOPNot.class))) {
    }
 else {
      if (mightBeUnknown(desc)) {
        LOG.trace("Pruner function might be unknown: " + expr.toStringTree());
        desc=new exprNodeConstantDesc(desc.getTypeInfo(),null);
      }
    }
    break;
  }
}
return desc;
}
