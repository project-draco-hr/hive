{
  List<InputSplit> finalSplits=Lists.newLinkedList();
  for (  Entry<Integer,Collection<InputSplit>> entry : bucketToGroupedSplitMap.asMap().entrySet()) {
    int bucketNum=entry.getKey();
    Collection<InputSplit> initialSplits=entry.getValue();
    finalSplits.addAll(initialSplits);
    for (int i=0; i < initialSplits.size(); i++) {
      bucketToTaskMap.put(bucketNum,taskCount);
      taskCount++;
    }
  }
  EdgeManagerPluginDescriptor hiveEdgeManagerDesc=null;
  if ((vertexType == VertexType.MULTI_INPUT_INITIALIZED_EDGES) || (vertexType == VertexType.INITIALIZED_EDGES)) {
    hiveEdgeManagerDesc=EdgeManagerPluginDescriptor.create(CustomPartitionEdge.class.getName());
    UserPayload payload=getBytePayload(bucketToTaskMap);
    hiveEdgeManagerDesc.setUserPayload(payload);
  }
  Map<String,EdgeManagerPluginDescriptor> emMap=Maps.newHashMap();
  for (  Entry<String,EdgeProperty> edgeEntry : context.getInputVertexEdgeProperties().entrySet()) {
    if (edgeEntry.getValue().getDataMovementType() == DataMovementType.CUSTOM && edgeEntry.getValue().getEdgeManagerDescriptor().getClassName().equals(CustomPartitionEdge.class.getName())) {
      emMap.put(edgeEntry.getKey(),hiveEdgeManagerDesc);
    }
  }
  LOG.info("Task count is " + taskCount);
  List<InputDataInformationEvent> taskEvents=Lists.newArrayListWithCapacity(finalSplits.size());
  int count=0;
  for (  InputSplit inputSplit : finalSplits) {
    MRSplitProto serializedSplit=MRInputHelpers.createSplitProto(inputSplit);
    InputDataInformationEvent diEvent=InputDataInformationEvent.createWithSerializedPayload(count,serializedSplit.toByteString().asReadOnlyByteBuffer());
    diEvent.setTargetIndex(count);
    count++;
    taskEvents.add(diEvent);
  }
  Map<String,InputSpecUpdate> rootInputSpecUpdate=new HashMap<String,InputSpecUpdate>();
  rootInputSpecUpdate.put(inputName,InputSpecUpdate.getDefaultSinglePhysicalInputSpecUpdate());
  if ((mainWorkName.compareTo(inputName) == 0) || (mainWorkName.isEmpty())) {
    context.setVertexParallelism(taskCount,VertexLocationHint.create(grouper.createTaskLocationHints(finalSplits.toArray(new InputSplit[finalSplits.size()]))),emMap,rootInputSpecUpdate);
  }
  context.addRootInputEvents(inputName,taskEvents);
  if (inputToGroupedSplitMap.isEmpty() == false) {
    for (    Entry<String,Multimap<Integer,InputSplit>> entry : inputToGroupedSplitMap.entrySet()) {
      processAllSideEvents(entry.getKey(),entry.getValue());
    }
    inputToGroupedSplitMap.clear();
  }
}
