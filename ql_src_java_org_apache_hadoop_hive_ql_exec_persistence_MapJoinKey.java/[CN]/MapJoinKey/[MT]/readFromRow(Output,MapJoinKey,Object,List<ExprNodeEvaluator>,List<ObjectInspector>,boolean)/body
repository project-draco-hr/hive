{
  Object[] fieldObjs=new Object[fields.size()];
  for (int keyIndex=0; keyIndex < fields.size(); ++keyIndex) {
    fieldObjs[keyIndex]=fields.get(keyIndex).evaluate(row);
  }
  boolean useOptimized=useOptimizedKeyBasedOnPrev(key);
  if (useOptimized || key == null) {
    try {
      byte[] structBytes=null;
      if (fieldObjs.length <= 8) {
        if (fieldObjs.length == 0) {
          structBytes=EMPTY_BYTE_ARRAY;
        }
 else {
          output=serializeRow(output,fieldObjs,keyFieldsOI,null);
          structBytes=Arrays.copyOf(output.getData(),output.getLength());
        }
      }
      if (structBytes != null) {
        return MapJoinKeyBytes.fromBytes(key,mayReuseKey,structBytes);
      }
 else       if (useOptimized) {
        throw new HiveException("Failed to serialize " + row + " even though optimized keys are used");
      }
    }
 catch (    SerDeException ex) {
      throw new HiveException("Serialization error",ex);
    }
  }
  MapJoinKeyObject result=mayReuseKey ? (MapJoinKeyObject)key : new MapJoinKeyObject();
  result.readFromRow(fieldObjs,keyFieldsOI);
  return result;
}
