{
  try {
    Connection dbConn=null;
    Statement stmt=null;
    PreparedStatement pStmt=null;
    ResultSet rs=null;
    try {
      dbConn=getDbConn(Connection.TRANSACTION_READ_COMMITTED);
      stmt=dbConn.createStatement();
      rs=stmt.executeQuery("select CQ_ID, CQ_DATABASE, CQ_TABLE, CQ_PARTITION, CQ_STATE, CQ_TYPE, CQ_TBLPROPERTIES, CQ_WORKER_ID, CQ_START, CQ_RUN_AS, CQ_HIGHEST_TXN_ID, CQ_META_INFO, CQ_HADOOP_JOB_ID from COMPACTION_QUEUE WHERE CQ_ID = " + info.id);
      if (rs.next()) {
        info=CompactionInfo.loadFullFromCompactionQueue(rs);
      }
 else {
        throw new IllegalStateException("No record with CQ_ID=" + info.id + " found in COMPACTION_QUEUE");
      }
      close(rs);
      String s="delete from COMPACTION_QUEUE where cq_id = " + info.id;
      LOG.debug("Going to execute update <" + s + ">");
      int updCount=stmt.executeUpdate(s);
      if (updCount != 1) {
        LOG.error("Unable to delete compaction record: " + info + ".  Update count="+ updCount);
        LOG.debug("Going to rollback");
        dbConn.rollback();
      }
      pStmt=dbConn.prepareStatement("insert into COMPLETED_COMPACTIONS(CC_ID, CC_DATABASE, CC_TABLE, CC_PARTITION, CC_STATE, CC_TYPE, CC_TBLPROPERTIES, CC_WORKER_ID, CC_START, CC_END, CC_RUN_AS, CC_HIGHEST_TXN_ID, CC_META_INFO, CC_HADOOP_JOB_ID) VALUES(?,?,?,?,?, ?,?,?,?,?, ?,?,?,?)");
      info.state=SUCCEEDED_STATE;
      CompactionInfo.insertIntoCompletedCompactions(pStmt,info,getDbTime(dbConn));
      updCount=pStmt.executeUpdate();
      s="delete from COMPLETED_TXN_COMPONENTS where ctc_database = '" + info.dbname + "' and "+ "ctc_table = '"+ info.tableName+ "'";
      if (info.partName != null) {
        s+=" and ctc_partition = '" + info.partName + "'";
      }
      if (info.highestTxnId != 0) {
        s+=" and ctc_txnid <= " + info.highestTxnId;
      }
      LOG.debug("Going to execute update <" + s + ">");
      if (stmt.executeUpdate(s) < 1) {
        LOG.error("Expected to remove at least one row from completed_txn_components when " + "marking compaction entry as clean!");
      }
      s="select distinct txn_id from TXNS, TXN_COMPONENTS where txn_id = tc_txnid and txn_state = '" + TXN_ABORTED + "' and tc_database = '"+ info.dbname+ "' and tc_table = '"+ info.tableName+ "'"+ (info.highestTxnId == 0 ? "" : " and txn_id <= " + info.highestTxnId);
      if (info.partName != null)       s+=" and tc_partition = '" + info.partName + "'";
      LOG.debug("Going to execute update <" + s + ">");
      rs=stmt.executeQuery(s);
      List<Long> txnids=new ArrayList<>();
      while (rs.next())       txnids.add(rs.getLong(1));
      if (txnids.size() > 0) {
        List<String> queries=new ArrayList<String>();
        StringBuilder prefix=new StringBuilder();
        StringBuilder suffix=new StringBuilder();
        prefix.append("delete from TXN_COMPONENTS where ");
        suffix.append(" and tc_database = ");
        suffix.append(quoteString(info.dbname));
        suffix.append(" and tc_table = ");
        suffix.append(quoteString(info.tableName));
        if (info.partName != null) {
          suffix.append(" and tc_partition = ");
          suffix.append(quoteString(info.partName));
        }
        TxnUtils.buildQueryWithINClause(conf,queries,prefix,suffix,txnids,"tc_txnid",true,false);
        for (        String query : queries) {
          LOG.debug("Going to execute update <" + query + ">");
          int rc=stmt.executeUpdate(query);
          LOG.debug("Removed " + rc + " records from txn_components");
        }
      }
      LOG.debug("Going to commit");
      dbConn.commit();
    }
 catch (    SQLException e) {
      LOG.error("Unable to delete from compaction queue " + e.getMessage());
      LOG.debug("Going to rollback");
      rollbackDBConn(dbConn);
      checkRetryable(dbConn,e,"markCleaned(" + info + ")");
      throw new MetaException("Unable to connect to transaction database " + StringUtils.stringifyException(e));
    }
 finally {
      closeStmt(pStmt);
      close(rs,stmt,dbConn);
    }
  }
 catch (  RetryException e) {
    markCleaned(info);
  }
}
