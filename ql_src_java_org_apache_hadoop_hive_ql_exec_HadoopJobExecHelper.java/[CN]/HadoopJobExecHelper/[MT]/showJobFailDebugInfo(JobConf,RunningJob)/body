{
  Map<String,Integer> failures=new HashMap<String,Integer>();
  Set<String> successes=new HashSet<String>();
  Map<String,TaskInfo> taskIdToInfo=new HashMap<String,TaskInfo>();
  int startIndex=0;
  console.printError("Error during job, obtaining debugging information...");
  while (true) {
    TaskCompletionEvent[] taskCompletions=rj.getTaskCompletionEvents(startIndex);
    if (taskCompletions == null || taskCompletions.length == 0) {
      break;
    }
    boolean more=true;
    for (    TaskCompletionEvent t : taskCompletions) {
      String[] taskJobIds=ShimLoader.getHadoopShims().getTaskJobIDs(t);
      if (taskJobIds == null) {
        console.printError("Task attempt info is unavailable in this Hadoop version");
        more=false;
        break;
      }
      String taskId=taskJobIds[0];
      String jobId=taskJobIds[1];
      console.printError("Examining task ID: " + taskId + " from job "+ jobId);
      TaskInfo ti=taskIdToInfo.get(taskId);
      if (ti == null) {
        ti=new TaskInfo(jobId);
        taskIdToInfo.put(taskId,ti);
      }
      assert(ti.getJobId() != null && ti.getJobId().equals(jobId));
      ti.getLogUrls().add(getTaskAttemptLogUrl(t.getTaskTrackerHttp(),t.getTaskId()));
      if (t.getTaskStatus() != TaskCompletionEvent.Status.SUCCEEDED) {
        Integer failAttempts=failures.get(taskId);
        if (failAttempts == null) {
          failAttempts=Integer.valueOf(0);
        }
        failAttempts=Integer.valueOf(failAttempts.intValue() + 1);
        failures.put(taskId,failAttempts);
      }
 else {
        successes.add(taskId);
      }
    }
    if (!more) {
      break;
    }
    startIndex+=taskCompletions.length;
  }
  for (  String task : successes) {
    failures.remove(task);
  }
  if (failures.keySet().size() == 0) {
    return;
  }
  int maxFailures=0;
  for (  Integer failCount : failures.values()) {
    if (maxFailures < failCount.intValue()) {
      maxFailures=failCount.intValue();
    }
  }
  String jtUrl=JobTrackerURLResolver.getURL(conf);
  for (  String task : failures.keySet()) {
    if (failures.get(task).intValue() == maxFailures) {
      TaskInfo ti=taskIdToInfo.get(task);
      String jobId=ti.getJobId();
      String taskUrl=jtUrl + "/taskdetails.jsp?jobid=" + jobId+ "&tipid="+ task.toString();
      TaskLogProcessor tlp=new TaskLogProcessor(conf);
      for (      String logUrl : ti.getLogUrls()) {
        tlp.addTaskAttemptLogUrl(logUrl);
      }
      List<ErrorAndSolution> errors=tlp.getErrors();
      StringBuilder sb=new StringBuilder();
      sb.append("\n");
      sb.append("Task with the most failures(" + maxFailures + "): \n");
      sb.append("-----\n");
      sb.append("Task ID:\n  " + task + "\n\n");
      sb.append("URL:\n  " + taskUrl + "\n");
      for (      ErrorAndSolution e : errors) {
        sb.append("\n");
        sb.append("Possible error:\n  " + e.getError() + "\n\n");
        sb.append("Solution:\n  " + e.getSolution() + "\n");
      }
      sb.append("-----\n");
      console.printError(sb.toString());
      break;
    }
  }
  return;
}
