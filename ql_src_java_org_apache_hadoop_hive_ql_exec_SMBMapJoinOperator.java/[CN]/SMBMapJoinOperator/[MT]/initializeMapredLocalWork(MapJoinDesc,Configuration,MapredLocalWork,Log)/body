{
  if (localWork == null || localWorkInited) {
    return;
  }
  localWorkInited=true;
  this.localWork=localWork;
  aliasToMergeQueue=new HashMap<String,MergeQueue>();
  Map<String,FetchWork> aliasToFetchWork=localWork.getAliasToFetchWork();
  Map<String,Operator<? extends OperatorDesc>> aliasToWork=localWork.getAliasToWork();
  for (  Map.Entry<String,FetchWork> entry : aliasToFetchWork.entrySet()) {
    String alias=entry.getKey();
    FetchWork fetchWork=entry.getValue();
    Operator<? extends OperatorDesc> forwardOp=aliasToWork.get(alias);
    forwardOp.setExecContext(getExecContext());
    JobConf jobClone=cloneJobConf(hconf,forwardOp);
    FetchOperator fetchOp=new FetchOperator(fetchWork,jobClone);
    forwardOp.initialize(jobClone,new ObjectInspector[]{fetchOp.getOutputObjectInspector()});
    fetchOp.clearFetchContext();
    MergeQueue mergeQueue=new MergeQueue(alias,fetchWork,jobClone);
    aliasToMergeQueue.put(alias,mergeQueue);
    l4j.info("fetch operators for " + alias + " initialized");
  }
}
