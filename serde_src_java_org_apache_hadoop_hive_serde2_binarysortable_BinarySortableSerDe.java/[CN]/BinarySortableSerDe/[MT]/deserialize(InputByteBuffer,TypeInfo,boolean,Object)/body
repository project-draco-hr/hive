{
  byte isNull=buffer.read(invert);
  if (isNull == 0) {
    return null;
  }
  assert(isNull == 1);
switch (type.getCategory()) {
case PRIMITIVE:
{
      PrimitiveTypeInfo ptype=(PrimitiveTypeInfo)type;
switch (ptype.getPrimitiveCategory()) {
case VOID:
{
          return null;
        }
case BOOLEAN:
{
        BooleanWritable r=reuse == null ? new BooleanWritable() : (BooleanWritable)reuse;
        byte b=buffer.read(invert);
        assert(b == 1 || b == 2);
        r.set(b == 2);
        return r;
      }
case BYTE:
{
      ByteWritable r=reuse == null ? new ByteWritable() : (ByteWritable)reuse;
      r.set((byte)(buffer.read(invert) ^ 0x80));
      return r;
    }
case SHORT:
{
    ShortWritable r=reuse == null ? new ShortWritable() : (ShortWritable)reuse;
    int v=buffer.read(invert) ^ 0x80;
    v=(v << 8) + (buffer.read(invert) & 0xff);
    r.set((short)v);
    return r;
  }
case INT:
{
  IntWritable r=reuse == null ? new IntWritable() : (IntWritable)reuse;
  r.set(deserializeInt(buffer,invert));
  return r;
}
case LONG:
{
LongWritable r=reuse == null ? new LongWritable() : (LongWritable)reuse;
long v=buffer.read(invert) ^ 0x80;
for (int i=0; i < 7; i++) {
  v=(v << 8) + (buffer.read(invert) & 0xff);
}
r.set(v);
return r;
}
case FLOAT:
{
FloatWritable r=reuse == null ? new FloatWritable() : (FloatWritable)reuse;
int v=0;
for (int i=0; i < 4; i++) {
v=(v << 8) + (buffer.read(invert) & 0xff);
}
if ((v & (1 << 31)) == 0) {
v=~v;
}
 else {
v=v ^ (1 << 31);
}
r.set(Float.intBitsToFloat(v));
return r;
}
case DOUBLE:
{
DoubleWritable r=reuse == null ? new DoubleWritable() : (DoubleWritable)reuse;
long v=0;
for (int i=0; i < 8; i++) {
v=(v << 8) + (buffer.read(invert) & 0xff);
}
if ((v & (1L << 63)) == 0) {
v=~v;
}
 else {
v=v ^ (1L << 63);
}
r.set(Double.longBitsToDouble(v));
return r;
}
case STRING:
{
Text r=reuse == null ? new Text() : (Text)reuse;
return deserializeText(buffer,invert,r);
}
case VARCHAR:
{
HiveVarcharWritable r=reuse == null ? new HiveVarcharWritable() : (HiveVarcharWritable)reuse;
deserializeText(buffer,invert,r.getTextValue());
r.enforceMaxLength(getVarcharMaxLength(type));
return r;
}
case BINARY:
{
BytesWritable bw=new BytesWritable();
int start=buffer.tell();
int length=0;
do {
byte b=buffer.read(invert);
if (b == 0) {
break;
}
if (b == 1) {
buffer.read(invert);
}
length++;
}
 while (true);
if (length == buffer.tell() - start) {
bw.set(buffer.getData(),start,length);
}
 else {
bw.set(buffer.getData(),start,length);
buffer.seek(start);
byte[] rdata=bw.getBytes();
for (int i=0; i < length; i++) {
byte b=buffer.read(invert);
if (b == 1) {
b=(byte)(buffer.read(invert) - 1);
}
rdata[i]=b;
}
byte b=buffer.read(invert);
assert(b == 0);
}
return bw;
}
case DATE:
{
DateWritable d=reuse == null ? new DateWritable() : (DateWritable)reuse;
d.set(deserializeInt(buffer,invert));
return d;
}
case TIMESTAMP:
TimestampWritable t=(reuse == null ? new TimestampWritable() : (TimestampWritable)reuse);
byte[] bytes=new byte[TimestampWritable.BINARY_SORTABLE_LENGTH];
for (int i=0; i < bytes.length; i++) {
bytes[i]=buffer.read(invert);
}
t.setBinarySortable(bytes,0);
return t;
case DECIMAL:
{
HiveDecimalWritable bdw=(reuse == null ? new HiveDecimalWritable() : (HiveDecimalWritable)reuse);
int b=buffer.read(invert) - 1;
assert(b == 1 || b == -1 || b == 0);
boolean positive=b != -1;
int factor=buffer.read(invert) ^ 0x80;
for (int i=0; i < 3; i++) {
factor=(factor << 8) + (buffer.read(invert) & 0xff);
}
if (!positive) {
factor=-factor;
}
int start=buffer.tell();
int length=0;
do {
b=buffer.read(positive ? invert : !invert);
assert(b != 1);
if (b == 0) {
break;
}
length++;
}
 while (true);
if (decimalBuffer == null || decimalBuffer.length < length) {
decimalBuffer=new byte[length];
}
buffer.seek(start);
for (int i=0; i < length; ++i) {
decimalBuffer[i]=buffer.read(positive ? invert : !invert);
}
buffer.read(positive ? invert : !invert);
String digits=new String(decimalBuffer,0,length,decimalCharSet);
BigInteger bi=new BigInteger(digits);
HiveDecimal bd=new HiveDecimal(bi).scaleByPowerOfTen(factor - length);
if (!positive) {
bd=bd.negate();
}
bdw.set(bd);
return bdw;
}
default :
{
throw new RuntimeException("Unrecognized type: " + ptype.getPrimitiveCategory());
}
}
}
case LIST:
{
ListTypeInfo ltype=(ListTypeInfo)type;
TypeInfo etype=ltype.getListElementTypeInfo();
ArrayList<Object> r=reuse == null ? new ArrayList<Object>() : (ArrayList<Object>)reuse;
int size=0;
while (true) {
int more=buffer.read(invert);
if (more == 0) {
break;
}
assert(more == 1);
if (size == r.size()) {
r.add(null);
}
r.set(size,deserialize(buffer,etype,invert,r.get(size)));
size++;
}
while (r.size() > size) {
r.remove(r.size() - 1);
}
return r;
}
case MAP:
{
MapTypeInfo mtype=(MapTypeInfo)type;
TypeInfo ktype=mtype.getMapKeyTypeInfo();
TypeInfo vtype=mtype.getMapValueTypeInfo();
Map<Object,Object> r;
if (reuse == null) {
r=new HashMap<Object,Object>();
}
 else {
r=(HashMap<Object,Object>)reuse;
r.clear();
}
while (true) {
int more=buffer.read(invert);
if (more == 0) {
break;
}
assert(more == 1);
Object k=deserialize(buffer,ktype,invert,null);
Object v=deserialize(buffer,vtype,invert,null);
r.put(k,v);
}
return r;
}
case STRUCT:
{
StructTypeInfo stype=(StructTypeInfo)type;
List<TypeInfo> fieldTypes=stype.getAllStructFieldTypeInfos();
int size=fieldTypes.size();
ArrayList<Object> r=reuse == null ? new ArrayList<Object>(size) : (ArrayList<Object>)reuse;
assert(r.size() <= size);
while (r.size() < size) {
r.add(null);
}
for (int eid=0; eid < size; eid++) {
r.set(eid,deserialize(buffer,fieldTypes.get(eid),invert,r.get(eid)));
}
return r;
}
case UNION:
{
UnionTypeInfo utype=(UnionTypeInfo)type;
StandardUnion r=reuse == null ? new StandardUnion() : (StandardUnion)reuse;
byte tag=buffer.read(invert);
r.setTag(tag);
r.setObject(deserialize(buffer,utype.getAllUnionObjectTypeInfos().get(tag),invert,null));
return r;
}
default :
{
throw new RuntimeException("Unrecognized type: " + type.getCategory());
}
}
}
