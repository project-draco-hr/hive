{
  fs.delete(file,true);
  byte[][] record_1={"123".getBytes("UTF-8"),"456".getBytes("UTF-8"),"789".getBytes("UTF-8"),"1000".getBytes("UTF-8"),"5.3".getBytes("UTF-8"),"howl and hadoop".getBytes("UTF-8"),new byte[0],"\\N".getBytes("UTF-8")};
  byte[][] record_2={"100".getBytes("UTF-8"),"200".getBytes("UTF-8"),"123".getBytes("UTF-8"),"1000".getBytes("UTF-8"),"5.3".getBytes("UTF-8"),"howl and hadoop".getBytes("UTF-8"),new byte[0],"\\N".getBytes("UTF-8")};
  RCFileOutputFormat.setColumnNumber(conf,8);
  RCFile.Writer writer=new RCFile.Writer(fs,conf,file,null,new DefaultCodec());
  BytesRefArrayWritable bytes=new BytesRefArrayWritable(record_1.length);
  for (int i=0; i < record_1.length; i++) {
    BytesRefWritable cu=new BytesRefWritable(record_1[i],0,record_1[i].length);
    bytes.set(i,cu);
  }
  writer.append(bytes);
  BytesRefArrayWritable bytes2=new BytesRefArrayWritable(record_2.length);
  for (int i=0; i < record_2.length; i++) {
    BytesRefWritable cu=new BytesRefWritable(record_2[i],0,record_2[i].length);
    bytes2.set(i,cu);
  }
  writer.append(bytes2);
  writer.close();
  BytesRefArrayWritable[] bytesArr=new BytesRefArrayWritable[]{bytes,bytes2};
  HCatSchema schema=buildHiveSchema();
  RCFileInputDriver sd=new RCFileInputDriver();
  JobContext jc=new JobContext(conf,new JobID());
  sd.setInputPath(jc,file.toString());
  InputFormat<?,?> iF=sd.getInputFormat(null);
  InputSplit split=iF.getSplits(jc).get(0);
  sd.setOriginalSchema(jc,schema);
  sd.setOutputSchema(jc,schema);
  sd.initialize(jc,getProps());
  TaskAttemptContext tac=new TaskAttemptContext(conf,new TaskAttemptID());
  RecordReader<?,?> rr=iF.createRecordReader(split,tac);
  rr.initialize(split,tac);
  HCatRecord[] tuples=getExpectedRecords();
  for (int j=0; j < 2; j++) {
    Assert.assertTrue(rr.nextKeyValue());
    BytesRefArrayWritable w=(BytesRefArrayWritable)rr.getCurrentValue();
    Assert.assertEquals(bytesArr[j],w);
    HCatRecord t=sd.convertToHCatRecord(null,w);
    Assert.assertEquals(8,t.size());
    Assert.assertEquals(t,tuples[j]);
  }
}
