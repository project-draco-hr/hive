{
  Map<Rule,NodeProcessor> opRules=new LinkedHashMap<Rule,NodeProcessor>();
  opRules.put(new RuleRegExp("No scripts",ScriptOperator.getOperatorName() + "%"),new NodeProcessor(){
    @Override public Object process(    Node n,    Stack<Node> s,    NodeProcessorCtx c,    Object... os){
      LOG.debug("Cannot run operator [" + n + "] in llap mode.");
      return new Boolean(false);
    }
  }
);
  opRules.put(new RuleRegExp("No user code in fil",FilterOperator.getOperatorName() + "%"),new NodeProcessor(){
    @Override public Object process(    Node n,    Stack<Node> s,    NodeProcessorCtx c,    Object... os){
      ExprNodeDesc expr=((FilterOperator)n).getConf().getPredicate();
      Boolean retval=new Boolean(checkExpression(expr));
      if (!retval) {
        LOG.info("Cannot run filter operator [" + n + "] in llap mode");
      }
      return new Boolean(retval);
    }
  }
);
  opRules.put(new RuleRegExp("No user code in gby",GroupByOperator.getOperatorName() + "%"),new NodeProcessor(){
    @Override public Object process(    Node n,    Stack<Node> s,    NodeProcessorCtx c,    Object... os){
      @SuppressWarnings("unchecked") List<AggregationDesc> aggs=((Operator<GroupByDesc>)n).getConf().getAggregators();
      Boolean retval=new Boolean(checkAggregators(aggs));
      if (!retval) {
        LOG.info("Cannot run group by operator [" + n + "] in llap mode");
      }
      return new Boolean(retval);
    }
  }
);
  opRules.put(new RuleRegExp("No user code in select",SelectOperator.getOperatorName() + "%"),new NodeProcessor(){
    @Override public Object process(    Node n,    Stack<Node> s,    NodeProcessorCtx c,    Object... os){
      @SuppressWarnings({"unchecked"}) List<ExprNodeDesc> exprs=((Operator<SelectDesc>)n).getConf().getColList();
      Boolean retval=new Boolean(checkExpressions(exprs));
      if (!retval) {
        LOG.info("Cannot run select operator [" + n + "] in llap mode");
      }
      return new Boolean(retval);
    }
  }
);
  return opRules;
}
