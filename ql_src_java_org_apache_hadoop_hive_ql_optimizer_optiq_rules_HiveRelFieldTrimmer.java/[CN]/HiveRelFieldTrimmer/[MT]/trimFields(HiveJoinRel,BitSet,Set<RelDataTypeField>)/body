{
  final RelDataType rowType=join.getRowType();
  final int fieldCount=rowType.getFieldCount();
  final RexNode conditionExpr=join.getCondition();
  final int systemFieldCount=join.getSystemFieldList().size();
  if (join.isLeftSemiJoin()) {
    return new TrimResult(join,Mappings.createIdentity(fieldCount));
  }
  BitSet fieldsUsedPlus=(BitSet)fieldsUsed.clone();
  final Set<RelDataTypeField> combinedInputExtraFields=new LinkedHashSet<RelDataTypeField>(extraFields);
  RelOptUtil.InputFinder inputFinder=new RelOptUtil.InputFinder(fieldsUsedPlus,combinedInputExtraFields);
  conditionExpr.accept(inputFinder);
  int systemFieldUsedCount=0;
  for (int i=0; i < systemFieldCount; ++i) {
    if (fieldsUsed.get(i)) {
      ++systemFieldUsedCount;
    }
  }
  final int newSystemFieldCount;
  if (systemFieldUsedCount == 0) {
    newSystemFieldCount=0;
  }
 else {
    newSystemFieldCount=systemFieldCount;
  }
  int offset=systemFieldCount;
  int changeCount=0;
  int newFieldCount=newSystemFieldCount;
  List<RelNode> newInputs=new ArrayList<RelNode>(2);
  List<Mapping> inputMappings=new ArrayList<Mapping>();
  List<Integer> inputExtraFieldCounts=new ArrayList<Integer>();
  for (  RelNode input : join.getInputs()) {
    final RelDataType inputRowType=input.getRowType();
    final int inputFieldCount=inputRowType.getFieldCount();
    BitSet inputFieldsUsed=new BitSet(inputFieldCount);
    for (    int bit : BitSets.toIter(fieldsUsedPlus)) {
      if (bit >= offset && bit < offset + inputFieldCount) {
        inputFieldsUsed.set(bit - offset);
      }
    }
    if (newSystemFieldCount > 0) {
      inputFieldsUsed.set(0,newSystemFieldCount);
    }
    Set<RelDataTypeField> inputExtraFields=RelDataTypeImpl.extra(rowType) == null ? Collections.<RelDataTypeField>emptySet() : combinedInputExtraFields;
    inputExtraFieldCounts.add(inputExtraFields.size());
    if (inputExtraFields.size() == 0 && inputFieldsUsed.isEmpty()) {
      inputFieldsUsed.set(0);
    }
    TrimResult trimResult=trimChild(join,input,inputFieldsUsed,inputExtraFields);
    newInputs.add(trimResult.left);
    if (trimResult.left != input) {
      ++changeCount;
    }
    final Mapping inputMapping=trimResult.right;
    inputMappings.add(inputMapping);
    offset+=inputFieldCount;
    newFieldCount+=inputMapping.getTargetCount() + inputExtraFields.size();
  }
  Mapping mapping=Mappings.create(MappingType.INVERSE_SURJECTION,fieldCount,newFieldCount);
  for (int i=0; i < newSystemFieldCount; ++i) {
    mapping.set(i,i);
  }
  offset=systemFieldCount;
  int newOffset=newSystemFieldCount;
  for (int i=0; i < inputMappings.size(); i++) {
    Mapping inputMapping=inputMappings.get(i);
    for (    IntPair pair : inputMapping) {
      mapping.set(pair.source + offset,pair.target + newOffset);
    }
    offset+=inputMapping.getSourceCount();
    newOffset+=inputMapping.getTargetCount() + inputExtraFieldCounts.get(i);
  }
  if (changeCount == 0 && mapping.isIdentity()) {
    return new TrimResult(join,Mappings.createIdentity(fieldCount));
  }
  final RexVisitor<RexNode> shuttle=new RexPermuteInputsShuttle(mapping,newInputs.get(0),newInputs.get(1));
  RexNode newConditionExpr=conditionExpr.accept(shuttle);
  final HiveJoinRel newJoin=join.copy(join.getTraitSet(),newConditionExpr,newInputs.get(0),newInputs.get(1),join.getJoinType(),false);
  return new TrimResult(newJoin,mapping);
}
