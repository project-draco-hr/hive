{
  Map<String,Integer> mapColumnNames=new HashMap<String,Integer>();
  ArrayList<String> outputColumnNames=new ArrayList<String>();
  ArrayList<ExprNodeDesc> keysDesc=new ArrayList<ExprNodeDesc>();
  Set<Object> keys=new HashSet<Object>();
  final String[] columnTypes=data.getTypes();
  int i=0;
  for (; i < columnTypes.length - 1; ++i) {
    String columnName=String.format("_col%d",i);
    mapColumnNames.put(columnName,i);
    outputColumnNames.add(columnName);
  }
  mapColumnNames.put("value",i);
  outputColumnNames.add("value");
  VectorizationContext ctx=new VectorizationContext(mapColumnNames,i + 1);
  ArrayList<AggregationDesc> aggs=new ArrayList(1);
  aggs.add(buildAggregationDesc(ctx,aggregateName,"value",TypeInfoFactory.getPrimitiveTypeInfo(columnTypes[i])));
  for (i=0; i < columnTypes.length - 1; ++i) {
    String columnName=String.format("_col%d",i);
    keysDesc.add(buildColumnDesc(ctx,columnName,TypeInfoFactory.getPrimitiveTypeInfo(columnTypes[i])));
  }
  GroupByDesc desc=new GroupByDesc();
  desc.setOutputColumnNames(outputColumnNames);
  desc.setAggregators(aggs);
  desc.setKeys(keysDesc);
  VectorGroupByOperator vgo=new VectorGroupByOperator(ctx,desc);
  FakeCaptureOutputOperator out=FakeCaptureOutputOperator.addCaptureOutputChild(vgo);
  vgo.initialize(null,null);
  out.setOutputInspector(new FakeCaptureOutputOperator.OutputInspector(){
    private int rowIndex;
    private String aggregateName;
    private Map<Object,Object> expected;
    private Set<Object> keys;
    @Override public void inspectRow(    Object row,    int tag) throws HiveException {
      assertTrue(row instanceof Object[]);
      Object[] fields=(Object[])row;
      assertEquals(columnTypes.length,fields.length);
      ArrayList<Object> keyValue=new ArrayList<Object>(columnTypes.length - 1);
      for (int i=0; i < columnTypes.length - 1; ++i) {
        Object key=fields[i];
        if (null == key) {
          keyValue.add(null);
        }
 else         if (key instanceof Text) {
          Text txKey=(Text)key;
          keyValue.add(txKey.toString());
        }
 else         if (key instanceof ByteWritable) {
          ByteWritable bwKey=(ByteWritable)key;
          keyValue.add(bwKey.get());
        }
 else         if (key instanceof ShortWritable) {
          ShortWritable swKey=(ShortWritable)key;
          keyValue.add(swKey.get());
        }
 else         if (key instanceof IntWritable) {
          IntWritable iwKey=(IntWritable)key;
          keyValue.add(iwKey.get());
        }
 else         if (key instanceof LongWritable) {
          LongWritable lwKey=(LongWritable)key;
          keyValue.add(lwKey.get());
        }
 else         if (key instanceof TimestampWritable) {
          TimestampWritable twKey=(TimestampWritable)key;
          keyValue.add(twKey.getTimestamp());
        }
 else         if (key instanceof DoubleWritable) {
          DoubleWritable dwKey=(DoubleWritable)key;
          keyValue.add(dwKey.get());
        }
 else         if (key instanceof FloatWritable) {
          FloatWritable fwKey=(FloatWritable)key;
          keyValue.add(fwKey.get());
        }
 else         if (key instanceof BooleanWritable) {
          BooleanWritable bwKey=(BooleanWritable)key;
          keyValue.add(bwKey.get());
        }
 else {
          Assert.fail(String.format("Not implemented key output type %s: %s",key.getClass().getName(),key));
        }
      }
      String keyAsString=Arrays.deepToString(keyValue.toArray());
      assertTrue(expected.containsKey(keyValue));
      Object expectedValue=expected.get(keyValue);
      Object value=fields[columnTypes.length - 1];
      Validator validator=getValidator(aggregateName);
      validator.validate(keyAsString,expectedValue,new Object[]{value});
      keys.add(keyValue);
    }
    private FakeCaptureOutputOperator.OutputInspector init(    String aggregateName,    Map<Object,Object> expected,    Set<Object> keys){
      this.aggregateName=aggregateName;
      this.expected=expected;
      this.keys=keys;
      return this;
    }
  }
.init(aggregateName,expected,keys));
  for (  VectorizedRowBatch unit : data) {
    vgo.process(unit,0);
  }
  vgo.close(false);
  List<Object> outBatchList=out.getCapturedRows();
  assertNotNull(outBatchList);
  assertEquals(expected.size(),outBatchList.size());
  assertEquals(expected.size(),keys.size());
}
