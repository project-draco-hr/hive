{
  List<ExpressionTree> kids=andList.get(0).children;
  if (result.isEmpty()) {
    for (    ExpressionTree kid : kids) {
      ExpressionTree or=new ExpressionTree(ExpressionTree.Operator.OR);
      result.add(or);
      for (      ExpressionTree node : nonAndList) {
        or.children.add(new ExpressionTree(node));
      }
      or.children.add(kid);
    }
  }
 else {
    List<ExpressionTree> work=new ArrayList<ExpressionTree>(result);
    result.clear();
    for (    ExpressionTree kid : kids) {
      for (      ExpressionTree or : work) {
        ExpressionTree copy=new ExpressionTree(or);
        copy.children.add(kid);
        result.add(copy);
      }
    }
  }
  if (andList.size() > 1) {
    generateAllCombinations(result,andList.subList(1,andList.size()),nonAndList);
  }
}
