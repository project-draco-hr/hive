{
  Path fpath=new Path((new Path(HiveConf.getVar(hconf,HiveConf.ConfVars.HADOOPMAPFILENAME))).toUri().getPath());
  ArrayList<Operator<? extends OperatorDesc>> children=new ArrayList<Operator<? extends OperatorDesc>>();
  opCtxMap=new HashMap<MapInputPath,MapOpCtx>();
  operatorToPaths=new HashMap<Operator<? extends OperatorDesc>,ArrayList<String>>();
  statsMap.put(Counter.DESERIALIZE_ERRORS,deserialize_error_count);
  Map<TableDesc,StructObjectInspector> convertedOI=getConvertedOI(hconf);
  try {
    for (    String onefile : conf.getPathToAliases().keySet()) {
      MapOpCtx opCtx=initObjectInspector(conf,hconf,onefile,convertedOI);
      Map<String,Integer> columnMap=new HashMap<String,Integer>();
      StructObjectInspector rowInspector=opCtx.getRowObjectInspector();
      int columnCount=0;
      for (      StructField sfield : rowInspector.getAllStructFieldRefs()) {
        columnMap.put(sfield.getFieldName(),columnCount);
        System.out.println("Column Name: " + sfield.getFieldName() + ", "+ "column index: "+ columnCount);
        LOG.info("Column Name: " + sfield.getFieldName() + ", "+ "column index: "+ columnCount);
        columnCount++;
      }
      Path onepath=new Path(new Path(onefile).toUri().getPath());
      List<String> aliases=conf.getPathToAliases().get(onefile);
      vectorizationContext=new VectorizationContext(columnMap,columnCount);
      for (      String onealias : aliases) {
        Operator<? extends OperatorDesc> op=conf.getAliasToWork().get(onealias);
        LOG.info("Adding alias " + onealias + " to work list for file "+ onefile);
        Operator<? extends OperatorDesc> vectorOp=vectorizeOperator(op,vectorizationContext);
        System.out.println("Using vectorized op: " + vectorOp.getName());
        LOG.info("Using vectorized op: " + vectorOp.getName());
        op=vectorOp;
        MapInputPath inp=new MapInputPath(onefile,onealias,op);
        opCtxMap.put(inp,opCtx);
        if (operatorToPaths.get(op) == null) {
          operatorToPaths.put(op,new ArrayList<String>());
        }
        operatorToPaths.get(op).add(onefile);
        op.setParentOperators(new ArrayList<Operator<? extends OperatorDesc>>());
        op.getParentOperators().add(this);
        if (!onepath.toUri().relativize(fpath.toUri()).equals(fpath.toUri())) {
          children.add(op);
          childrenOpToOpCtxMap.put(op,opCtx);
          LOG.info("dump " + op.getName() + " "+ opCtxMap.get(inp).getRowObjectInspector().getTypeName());
        }
        setInspectorInput(inp);
      }
    }
    if (children.size() == 0) {
      LOG.error("Configuration does not have any alias for path: " + fpath.toUri().getPath());
      throw new HiveException("Configuration and input path are inconsistent");
    }
    setChildOperators(children);
  }
 catch (  Exception e) {
    throw new HiveException(e);
  }
}
