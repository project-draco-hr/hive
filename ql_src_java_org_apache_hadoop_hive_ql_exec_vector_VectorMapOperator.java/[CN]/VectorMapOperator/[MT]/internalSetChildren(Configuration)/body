{
  currentReadType=VectorMapOperatorReadType.NONE;
  batchContext=conf.getVectorizedRowBatchCtx();
  vectorizedInputFileFormatBatch=batchContext.createVectorizedRowBatch();
  conf.setVectorizedRowBatch(vectorizedInputFileFormatBatch);
  deserializerBatch=batchContext.createVectorizedRowBatch();
  batchCounter=0;
  dataColumnCount=batchContext.getDataColumnCount();
  partitionColumnCount=batchContext.getPartitionColumnCount();
  partitionValues=new Object[partitionColumnCount];
  dataColumnNums=batchContext.getDataColumnNums();
  Preconditions.checkState(dataColumnNums != null);
  determineDataColumnsToIncludeTruncated();
  final String[] rowColumnNames=batchContext.getRowColumnNames();
  final TypeInfo[] rowColumnTypeInfos=batchContext.getRowColumnTypeInfos();
  tableStructTypeInfo=TypeInfoFactory.getStructTypeInfo(Arrays.asList(rowColumnNames),Arrays.asList(rowColumnTypeInfos));
  tableStandardStructObjectInspector=(StandardStructObjectInspector)TypeInfoUtils.getStandardWritableObjectInspectorFromTypeInfo(tableStructTypeInfo);
  tableRowTypeInfos=batchContext.getRowColumnTypeInfos();
  fileToPartitionContextMap=new HashMap<String,VectorPartitionContext>();
  HashMap<PartitionDesc,VectorPartitionContext> partitionContextMap=new HashMap<PartitionDesc,VectorPartitionContext>();
  for (  Map.Entry<Path,ArrayList<String>> entry : conf.getPathToAliases().entrySet()) {
    Path path=entry.getKey();
    PartitionDesc partDesc=conf.getPathToPartitionInfo().get(path);
    ArrayList<String> aliases=entry.getValue();
    VectorPartitionDesc vectorPartDesc=partDesc.getVectorPartitionDesc();
    LOG.info("VectorMapOperator path: " + path + ", read type "+ vectorPartDesc.getVectorMapOperatorReadType().name()+ ", vector deserialize type "+ vectorPartDesc.getVectorDeserializeType().name()+ ", aliases "+ aliases);
    VectorPartitionContext vectorPartitionContext;
    if (!partitionContextMap.containsKey(partDesc)) {
      vectorPartitionContext=createAndInitPartitionContext(partDesc,hconf);
      partitionContextMap.put(partDesc,vectorPartitionContext);
    }
 else {
      vectorPartitionContext=partitionContextMap.get(partDesc);
    }
    fileToPartitionContextMap.put(path.toString(),vectorPartitionContext);
  }
  List<Operator<? extends OperatorDesc>> children=new ArrayList<Operator<? extends OperatorDesc>>();
  children.add(oneRootOperator);
  setChildOperators(children);
}
