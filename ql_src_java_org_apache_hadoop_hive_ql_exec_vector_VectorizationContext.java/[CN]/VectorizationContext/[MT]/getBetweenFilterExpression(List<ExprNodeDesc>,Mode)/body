{
  if (mode == Mode.PROJECTION) {
    return null;
  }
  boolean notKeywordPresent=(Boolean)((ExprNodeConstantDesc)childExpr.get(0)).getValue();
  ExprNodeDesc colExpr=childExpr.get(1);
  long left, right;
  List<ExprNodeDesc> newChildren;
  String colType=colExpr.getTypeString();
  List<ExprNodeDesc> childrenAfterNot=foldConstantsForUnaryExprs(childExpr.subList(1,4));
  ;
  Class<?> cl=null;
  if (isIntFamily(colType) && !notKeywordPresent) {
    cl=FilterLongColumnBetween.class;
  }
 else   if (isIntFamily(colType) && notKeywordPresent) {
    cl=FilterLongColumnNotBetween.class;
  }
 else   if (isFloatFamily(colType) && !notKeywordPresent) {
    cl=FilterDoubleColumnBetween.class;
  }
 else   if (isFloatFamily(colType) && notKeywordPresent) {
    cl=FilterDoubleColumnNotBetween.class;
  }
 else   if (colType.equals("string") && !notKeywordPresent) {
    cl=FilterStringColumnBetween.class;
  }
 else   if (colType.equals("string") && notKeywordPresent) {
    cl=FilterStringColumnNotBetween.class;
  }
 else   if (colType.equals("timestamp")) {
    left=getTimestampScalar(childExpr.get(2));
    right=getTimestampScalar(childExpr.get(3));
    childrenAfterNot=new ArrayList<ExprNodeDesc>();
    childrenAfterNot.add(colExpr);
    childrenAfterNot.add(new ExprNodeConstantDesc(left));
    childrenAfterNot.add(new ExprNodeConstantDesc(right));
    if (notKeywordPresent) {
      cl=FilterLongColumnNotBetween.class;
    }
 else {
      cl=FilterLongColumnBetween.class;
    }
  }
  return createVectorExpression(cl,childrenAfterNot,Mode.PROJECTION,null);
}
