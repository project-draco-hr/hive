{
  String typeName=typeInfo.getTypeName();
  VectorExpressionDescriptor.ArgumentType vectorArgType=VectorExpressionDescriptor.ArgumentType.fromHiveTypeName(typeName);
  if (vectorArgType == VectorExpressionDescriptor.ArgumentType.NONE) {
    throw new HiveException("No vector argument type for type name " + typeName);
  }
  int outCol=-1;
  if (mode == Mode.PROJECTION) {
    outCol=ocm.allocateOutputColumn(typeName);
  }
  if (constantValue == null) {
    return new ConstantVectorExpression(outCol,typeName,true);
  }
  if (typeName.equalsIgnoreCase("boolean")) {
    if (mode == Mode.FILTER) {
      if (((Boolean)constantValue).booleanValue()) {
        return new FilterConstantBooleanVectorExpression(1);
      }
 else {
        return new FilterConstantBooleanVectorExpression(0);
      }
    }
 else {
      if (((Boolean)constantValue).booleanValue()) {
        return new ConstantVectorExpression(outCol,1);
      }
 else {
        return new ConstantVectorExpression(outCol,0);
      }
    }
  }
switch (vectorArgType) {
case INT_FAMILY:
    return new ConstantVectorExpression(outCol,((Number)constantValue).longValue());
case TIMESTAMP:
  return new ConstantVectorExpression(outCol,TimestampUtils.getTimeNanoSec((Timestamp)constantValue));
case FLOAT_FAMILY:
return new ConstantVectorExpression(outCol,((Number)constantValue).doubleValue());
case DECIMAL:
VectorExpression ve=new ConstantVectorExpression(outCol,(Decimal128)constantValue);
ve.setOutputType(typeName);
return ve;
case STRING:
return new ConstantVectorExpression(outCol,((String)constantValue).getBytes());
case CHAR:
return new ConstantVectorExpression(outCol,((HiveChar)constantValue));
case VARCHAR:
return new ConstantVectorExpression(outCol,((HiveVarchar)constantValue));
default :
throw new HiveException("Unsupported constant type: " + typeName + ", object class "+ constantValue.getClass().getSimpleName());
}
}
