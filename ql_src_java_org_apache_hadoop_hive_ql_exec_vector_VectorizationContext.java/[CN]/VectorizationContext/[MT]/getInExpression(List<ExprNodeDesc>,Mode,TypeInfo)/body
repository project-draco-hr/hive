{
  ExprNodeDesc colExpr=childExpr.get(0);
  String colType=colExpr.getTypeString();
  List<ExprNodeDesc> childrenForInList=evaluateCastOnConstants(childExpr.subList(1,childExpr.size()));
  VectorExpression expr=null;
  Class<?> cl=null;
  if (isIntFamily(colType)) {
    cl=(mode == Mode.FILTER ? FilterLongColumnInList.class : LongColumnInList.class);
    long[] inVals=new long[childrenForInList.size()];
    for (int i=0; i != inVals.length; i++) {
      inVals[i]=getIntFamilyScalarAsLong((ExprNodeConstantDesc)childrenForInList.get(i));
    }
    expr=createVectorExpression(cl,childExpr.subList(0,1),Mode.PROJECTION,returnType);
    ((ILongInExpr)expr).setInListValues(inVals);
  }
 else   if (isTimestampFamily(colType)) {
    cl=(mode == Mode.FILTER ? FilterLongColumnInList.class : LongColumnInList.class);
    long[] inVals=new long[childrenForInList.size()];
    for (int i=0; i != inVals.length; i++) {
      inVals[i]=getTimestampScalar(childrenForInList.get(i));
    }
    expr=createVectorExpression(cl,childExpr.subList(0,1),Mode.PROJECTION,returnType);
    ((ILongInExpr)expr).setInListValues(inVals);
  }
 else   if (isStringFamily(colType)) {
    cl=(mode == Mode.FILTER ? FilterStringColumnInList.class : StringColumnInList.class);
    byte[][] inVals=new byte[childrenForInList.size()][];
    for (int i=0; i != inVals.length; i++) {
      inVals[i]=getStringScalarAsByteArray((ExprNodeConstantDesc)childrenForInList.get(i));
    }
    expr=createVectorExpression(cl,childExpr.subList(0,1),Mode.PROJECTION,returnType);
    ((IStringInExpr)expr).setInListValues(inVals);
  }
 else   if (isFloatFamily(colType)) {
    cl=(mode == Mode.FILTER ? FilterDoubleColumnInList.class : DoubleColumnInList.class);
    double[] inValsD=new double[childrenForInList.size()];
    for (int i=0; i != inValsD.length; i++) {
      inValsD[i]=getNumericScalarAsDouble(childrenForInList.get(i));
    }
    expr=createVectorExpression(cl,childExpr.subList(0,1),Mode.PROJECTION,returnType);
    ((IDoubleInExpr)expr).setInListValues(inValsD);
  }
 else   if (isDecimalFamily(colType)) {
    cl=(mode == Mode.FILTER ? FilterDecimalColumnInList.class : DecimalColumnInList.class);
    Decimal128[] inValsD=new Decimal128[childrenForInList.size()];
    for (int i=0; i != inValsD.length; i++) {
      inValsD[i]=(Decimal128)getVectorTypeScalarValue((ExprNodeConstantDesc)childrenForInList.get(i));
    }
    expr=createVectorExpression(cl,childExpr.subList(0,1),Mode.PROJECTION,returnType);
    ((IDecimalInExpr)expr).setInListValues(inValsD);
  }
 else   if (isDateFamily(colType)) {
    cl=(mode == Mode.FILTER ? FilterLongColumnInList.class : LongColumnInList.class);
    long[] inVals=new long[childrenForInList.size()];
    for (int i=0; i != inVals.length; i++) {
      inVals[i]=(Integer)getVectorTypeScalarValue((ExprNodeConstantDesc)childrenForInList.get(i));
    }
    expr=createVectorExpression(cl,childExpr.subList(0,1),Mode.PROJECTION,returnType);
    ((ILongInExpr)expr).setInListValues(inVals);
  }
  return expr;
}
