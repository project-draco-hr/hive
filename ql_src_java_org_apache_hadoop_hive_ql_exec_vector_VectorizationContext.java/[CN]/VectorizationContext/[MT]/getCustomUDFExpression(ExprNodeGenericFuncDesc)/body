{
  List<ExprNodeDesc> childExprList=expr.getChildren();
  VectorUDFArgDesc[] argDescs=new VectorUDFArgDesc[expr.getChildren().size()];
  for (int i=0; i < argDescs.length; i++) {
    argDescs[i]=new VectorUDFArgDesc();
  }
  List<Integer> variableArgPositions=new ArrayList<Integer>();
  List<Integer> exprResultColumnNums=new ArrayList<Integer>();
  List<VectorExpression> vectorExprs=new ArrayList<VectorExpression>();
  for (int i=0; i < childExprList.size(); i++) {
    ExprNodeDesc child=childExprList.get(i);
    if (child instanceof ExprNodeGenericFuncDesc) {
      VectorExpression e=getVectorExpression(child,Mode.PROJECTION);
      vectorExprs.add(e);
      variableArgPositions.add(i);
      exprResultColumnNums.add(e.getOutputColumn());
      argDescs[i].setVariable(e.getOutputColumn());
    }
 else     if (child instanceof ExprNodeColumnDesc) {
      variableArgPositions.add(i);
      argDescs[i].setVariable(getInputColumnIndex(((ExprNodeColumnDesc)child).getColumn()));
    }
 else     if (child instanceof ExprNodeConstantDesc) {
      argDescs[i].setConstant((ExprNodeConstantDesc)child);
    }
 else {
      throw new HiveException("Unable to vectorize Custom UDF");
    }
  }
  int outputCol=-1;
  String resultType=expr.getTypeInfo().getTypeName();
  String resultColVectorType=getNormalizedTypeName(resultType);
  outputCol=ocm.allocateOutputColumn(resultColVectorType);
  VectorExpression ve=new VectorUDFAdaptor(expr,outputCol,resultColVectorType,argDescs);
  VectorExpression[] childVEs=null;
  if (exprResultColumnNums.size() != 0) {
    childVEs=new VectorExpression[exprResultColumnNums.size()];
    for (int i=0; i < childVEs.length; i++) {
      childVEs[i]=vectorExprs.get(i);
    }
  }
  ve.setChildExpressions(childVEs);
  for (  Integer i : exprResultColumnNums) {
    ocm.freeOutputColumn(i);
  }
  return ve;
}
