{
  ArrayList<ExprNodeDesc> paramDescList=desc.getParameters();
  VectorExpression[] vectorParams=new VectorExpression[paramDescList.size()];
  for (int i=0; i < paramDescList.size(); ++i) {
    ExprNodeDesc exprDesc=paramDescList.get(i);
    vectorParams[i]=this.getVectorExpression(exprDesc,Mode.PROJECTION);
  }
  String aggregateName=desc.getGenericUDAFName();
  String inputType=null;
  if (paramDescList.size() > 0) {
    ExprNodeDesc inputExpr=paramDescList.get(0);
    inputType=getNormalizedTypeName(inputExpr.getTypeString());
    if (decimalTypePattern.matcher(inputType).matches()) {
      inputType="Decimal";
    }
  }
  for (  Object[] aggDef : aggregatesDefinition) {
    if (aggregateName.equalsIgnoreCase((String)aggDef[0]) && ((aggDef[1] == null && inputType == null) || (aggDef[1] != null && aggDef[1].equals(inputType)))) {
      Class<? extends VectorAggregateExpression> aggClass=(Class<? extends VectorAggregateExpression>)(aggDef[2]);
      try {
        Constructor<? extends VectorAggregateExpression> ctor=aggClass.getConstructor(VectorExpression.class);
        VectorAggregateExpression aggExpr=ctor.newInstance(vectorParams.length > 0 ? vectorParams[0] : null);
        aggExpr.init(desc);
        return aggExpr;
      }
 catch (      Exception e) {
        throw new HiveException("Internal exception for vector aggregate : \"" + aggregateName + "\" for type: \""+ inputType+ "",e);
      }
    }
  }
  throw new HiveException("Vector aggregate not implemented: \"" + aggregateName + "\" for type: \""+ inputType+ "");
}
