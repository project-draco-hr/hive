{
  boolean isFilter=false;
  if (mode == VectorExpressionDescriptor.Mode.FILTER) {
    TypeInfo resultTypeInfo=expr.getTypeInfo();
    if (resultTypeInfo.getCategory() == Category.PRIMITIVE && ((PrimitiveTypeInfo)resultTypeInfo).getPrimitiveCategory() == PrimitiveCategory.BOOLEAN) {
      isFilter=true;
    }
 else {
      return null;
    }
  }
  List<ExprNodeDesc> childExprList=expr.getChildren();
  VectorUDFArgDesc[] argDescs=new VectorUDFArgDesc[expr.getChildren().size()];
  for (int i=0; i < argDescs.length; i++) {
    argDescs[i]=new VectorUDFArgDesc();
  }
  List<Integer> variableArgPositions=new ArrayList<Integer>();
  List<Integer> exprResultColumnNums=new ArrayList<Integer>();
  List<VectorExpression> vectorExprs=new ArrayList<VectorExpression>();
  for (int i=0; i < childExprList.size(); i++) {
    ExprNodeDesc child=childExprList.get(i);
    if (child instanceof ExprNodeGenericFuncDesc) {
      VectorExpression e=getVectorExpression(child,VectorExpressionDescriptor.Mode.PROJECTION);
      vectorExprs.add(e);
      variableArgPositions.add(i);
      exprResultColumnNums.add(e.getOutputColumn());
      argDescs[i].setVariable(e.getOutputColumn());
    }
 else     if (child instanceof ExprNodeColumnDesc) {
      variableArgPositions.add(i);
      argDescs[i].setVariable(getInputColumnIndex(((ExprNodeColumnDesc)child).getColumn()));
    }
 else     if (child instanceof ExprNodeConstantDesc) {
      argDescs[i].setConstant((ExprNodeConstantDesc)child);
    }
 else {
      throw new HiveException("Unable to vectorize custom UDF. Encountered unsupported expr desc : " + child);
    }
  }
  int outputCol=-1;
  String resultTypeName=expr.getTypeInfo().getTypeName();
  outputCol=ocm.allocateOutputColumn(resultTypeName);
  String normalizedName=getNormalizedName(resultTypeName);
  VectorExpression ve=new VectorUDFAdaptor(expr,outputCol,normalizedName,argDescs);
  VectorExpression[] childVEs=null;
  if (exprResultColumnNums.size() != 0) {
    childVEs=new VectorExpression[exprResultColumnNums.size()];
    for (int i=0; i < childVEs.length; i++) {
      childVEs[i]=vectorExprs.get(i);
    }
  }
  ve.setChildExpressions(childVEs);
  for (  Integer i : exprResultColumnNums) {
    ocm.freeOutputColumn(i);
  }
  if (isFilter) {
    SelectColumnIsTrue filterVectorExpr=new SelectColumnIsTrue(outputCol);
    filterVectorExpr.setChildExpressions(new VectorExpression[]{ve});
    return filterVectorExpr;
  }
 else {
    return ve;
  }
}
