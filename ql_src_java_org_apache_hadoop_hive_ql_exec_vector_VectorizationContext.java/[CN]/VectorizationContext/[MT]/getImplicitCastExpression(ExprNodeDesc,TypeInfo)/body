{
  TypeInfo inputTypeInfo=child.getTypeInfo();
  String inputTypeString=inputTypeInfo.getTypeName();
  String castTypeString=castType.getTypeName();
  boolean inputTypeDecimal=false;
  boolean castTypeDecimal=false;
  if (decimalTypePattern.matcher(inputTypeString).matches()) {
    inputTypeDecimal=true;
  }
  if (decimalTypePattern.matcher(castTypeString).matches()) {
    castTypeDecimal=true;
  }
  if (castTypeDecimal) {
    castType=updatePrecision(inputTypeInfo,(DecimalTypeInfo)castType);
  }
  if (castTypeDecimal && !inputTypeDecimal) {
    GenericUDFToDecimal castToDecimalUDF=new GenericUDFToDecimal();
    List<ExprNodeDesc> children=new ArrayList<ExprNodeDesc>();
    children.add(child);
    ExprNodeDesc desc=new ExprNodeGenericFuncDesc(castType,castToDecimalUDF,children);
    return desc;
  }
 else   if (!castTypeDecimal && inputTypeDecimal) {
    UDF udfClass=null;
    GenericUDF genericUdf=null;
    PrimitiveObjectInspector.PrimitiveCategory primitiveCategory=((PrimitiveTypeInfo)castType).getPrimitiveCategory();
switch (((PrimitiveTypeInfo)castType).getPrimitiveCategory()) {
case BYTE:
      udfClass=new UDFToByte();
    break;
case SHORT:
  udfClass=new UDFToShort();
break;
case INT:
udfClass=new UDFToInteger();
break;
case LONG:
udfClass=new UDFToLong();
break;
case FLOAT:
udfClass=new UDFToFloat();
break;
case DOUBLE:
udfClass=new UDFToDouble();
break;
case STRING:
udfClass=new UDFToString();
break;
case BOOLEAN:
udfClass=new UDFToBoolean();
break;
case DATE:
genericUdf=new GenericUDFToDate();
break;
case TIMESTAMP:
genericUdf=new GenericUDFToUnixTimeStamp();
break;
case BINARY:
genericUdf=new GenericUDFToBinary();
break;
}
if (genericUdf == null) {
genericUdf=new GenericUDFBridge();
((GenericUDFBridge)genericUdf).setUdfClassName(udfClass.getClass().getName());
}
List<ExprNodeDesc> children=new ArrayList<ExprNodeDesc>();
children.add(child);
ExprNodeDesc desc=new ExprNodeGenericFuncDesc(castType,genericUdf,children);
return desc;
}
return null;
}
