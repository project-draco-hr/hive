{
  HiveConf conf=new HiveConf(getConf(),BitmapIndexHandler.class);
  HiveConf.setBoolVar(conf,HiveConf.ConfVars.HIVEROWOFFSET,true);
  HiveConf.setBoolVar(conf,HiveConf.ConfVars.HIVEOPTINDEXFILTER,false);
  String indexCols=HiveUtils.getUnparsedColumnNamesFromFieldSchema(indexField);
  StringBuilder command=new StringBuilder();
  LinkedHashMap<String,String> partSpec=indexTblPartDesc.getPartSpec();
  command.append("INSERT OVERWRITE TABLE " + HiveUtils.unparseIdentifier(indexTableName));
  if (partitioned && indexTblPartDesc != null) {
    command.append(" PARTITION ( ");
    List<String> ret=getPartKVPairStringArray(partSpec);
    for (int i=0; i < ret.size(); i++) {
      String partKV=ret.get(i);
      command.append(partKV);
      if (i < ret.size() - 1) {
        command.append(",");
      }
    }
    command.append(" ) ");
  }
  command.append(" SELECT ");
  command.append(indexCols);
  command.append(",");
  command.append(VirtualColumn.FILENAME.getName());
  command.append(",");
  command.append(VirtualColumn.BLOCKOFFSET.getName());
  command.append(",");
  command.append("EWAH_BITMAP(");
  command.append(VirtualColumn.ROWOFFSET.getName());
  command.append(")");
  command.append(" FROM " + HiveUtils.unparseIdentifier(baseTableName));
  LinkedHashMap<String,String> basePartSpec=baseTablePartDesc.getPartSpec();
  if (basePartSpec != null) {
    command.append(" WHERE ");
    List<String> pkv=getPartKVPairStringArray(basePartSpec);
    for (int i=0; i < pkv.size(); i++) {
      String partKV=pkv.get(i);
      command.append(partKV);
      if (i < pkv.size() - 1) {
        command.append(" AND ");
      }
    }
  }
  command.append(" GROUP BY ");
  command.append(VirtualColumn.FILENAME.getName());
  command.append(",");
  command.append(VirtualColumn.BLOCKOFFSET.getName());
  for (  FieldSchema fieldSchema : indexField) {
    command.append(",");
    command.append(HiveUtils.unparseIdentifier(fieldSchema.getName()));
  }
  if (!conf.get("hive.map.aggr",null).equals("true")) {
    throw new HiveException("Cannot construct index without map-side aggregation");
  }
  Driver driver=new Driver(conf);
  driver.compile(command.toString());
  Task<?> rootTask=driver.getPlan().getRootTasks().get(0);
  inputs.addAll(driver.getPlan().getInputs());
  outputs.addAll(driver.getPlan().getOutputs());
  IndexMetadataChangeWork indexMetaChange=new IndexMetadataChangeWork(partSpec,indexTableName,dbName);
  IndexMetadataChangeTask indexMetaChangeTsk=new IndexMetadataChangeTask();
  indexMetaChangeTsk.setWork(indexMetaChange);
  rootTask.addDependentTask(indexMetaChangeTsk);
  return rootTask;
}
