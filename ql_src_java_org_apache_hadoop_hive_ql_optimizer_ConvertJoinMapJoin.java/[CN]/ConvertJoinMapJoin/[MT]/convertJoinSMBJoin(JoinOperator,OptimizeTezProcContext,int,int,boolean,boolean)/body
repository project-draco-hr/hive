{
  ParseContext parseContext=context.parseContext;
  MapJoinDesc mapJoinDesc=null;
  if (adjustParentsChildren) {
    mapJoinDesc=MapJoinProcessor.getMapJoinDesc(context.conf,parseContext.getOpParseCtx(),joinOp,parseContext.getJoinContext().get(joinOp),mapJoinConversionPos,true);
  }
 else {
    JoinDesc joinDesc=joinOp.getConf();
    mapJoinDesc=new MapJoinDesc(null,null,joinDesc.getExprs(),null,null,joinDesc.getOutputColumnNames(),mapJoinConversionPos,joinDesc.getConds(),joinDesc.getFilters(),joinDesc.getNoOuterJoin(),null);
  }
  @SuppressWarnings("unchecked") CommonMergeJoinOperator mergeJoinOp=(CommonMergeJoinOperator)OperatorFactory.get(new CommonMergeJoinDesc(numBuckets,isSubQuery,mapJoinConversionPos,mapJoinDesc));
  OpTraits opTraits=new OpTraits(joinOp.getOpTraits().getBucketColNames(),numBuckets,joinOp.getOpTraits().getSortCols());
  mergeJoinOp.setOpTraits(opTraits);
  mergeJoinOp.setStatistics(joinOp.getStatistics());
  for (  Operator<? extends OperatorDesc> parentOp : joinOp.getParentOperators()) {
    int pos=parentOp.getChildOperators().indexOf(joinOp);
    parentOp.getChildOperators().remove(pos);
    parentOp.getChildOperators().add(pos,mergeJoinOp);
  }
  for (  Operator<? extends OperatorDesc> childOp : joinOp.getChildOperators()) {
    int pos=childOp.getParentOperators().indexOf(joinOp);
    childOp.getParentOperators().remove(pos);
    childOp.getParentOperators().add(pos,mergeJoinOp);
  }
  List<Operator<? extends OperatorDesc>> childOperators=mergeJoinOp.getChildOperators();
  if (childOperators == null) {
    childOperators=new ArrayList<Operator<? extends OperatorDesc>>();
    mergeJoinOp.setChildOperators(childOperators);
  }
  List<Operator<? extends OperatorDesc>> parentOperators=mergeJoinOp.getParentOperators();
  if (parentOperators == null) {
    parentOperators=new ArrayList<Operator<? extends OperatorDesc>>();
    mergeJoinOp.setParentOperators(parentOperators);
  }
  childOperators.clear();
  parentOperators.clear();
  childOperators.addAll(joinOp.getChildOperators());
  parentOperators.addAll(joinOp.getParentOperators());
  mergeJoinOp.getConf().setGenJoinKeys(false);
  if (adjustParentsChildren) {
    mergeJoinOp.getConf().setGenJoinKeys(true);
    List<Operator<? extends OperatorDesc>> newParentOpList=new ArrayList<Operator<? extends OperatorDesc>>();
    for (    Operator<? extends OperatorDesc> parentOp : mergeJoinOp.getParentOperators()) {
      for (      Operator<? extends OperatorDesc> grandParentOp : parentOp.getParentOperators()) {
        grandParentOp.getChildOperators().remove(parentOp);
        grandParentOp.getChildOperators().add(mergeJoinOp);
        newParentOpList.add(grandParentOp);
      }
    }
    mergeJoinOp.getParentOperators().clear();
    mergeJoinOp.getParentOperators().addAll(newParentOpList);
    List<Operator<? extends OperatorDesc>> parentOps=new ArrayList<Operator<? extends OperatorDesc>>(mergeJoinOp.getParentOperators());
    for (    Operator<? extends OperatorDesc> parentOp : parentOps) {
      int parentIndex=mergeJoinOp.getParentOperators().indexOf(parentOp);
      if (parentIndex == mapJoinConversionPos) {
        continue;
      }
      DummyStoreOperator dummyStoreOp=new TezDummyStoreOperator();
      dummyStoreOp.setParentOperators(new ArrayList<Operator<? extends OperatorDesc>>());
      dummyStoreOp.setChildOperators(new ArrayList<Operator<? extends OperatorDesc>>());
      dummyStoreOp.getChildOperators().add(mergeJoinOp);
      int index=parentOp.getChildOperators().indexOf(mergeJoinOp);
      parentOp.getChildOperators().remove(index);
      parentOp.getChildOperators().add(index,dummyStoreOp);
      dummyStoreOp.getParentOperators().add(parentOp);
      mergeJoinOp.getParentOperators().remove(parentIndex);
      mergeJoinOp.getParentOperators().add(parentIndex,dummyStoreOp);
    }
  }
  mergeJoinOp.cloneOriginalParentsList(mergeJoinOp.getParentOperators());
}
