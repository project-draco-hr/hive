{
  if (fields == null) {
    List<TypeInfo> fieldTypeInfos=((StructTypeInfo)typeInfo).getAllStructFieldTypeInfos();
    fields=new LazyObject[fieldTypeInfos.size()];
    for (int i=0; i < fields.length; i++) {
      fields[i]=LazyFactory.createLazyObject(fieldTypeInfos.get(i));
    }
    fieldInited=new boolean[fields.length];
    startPosition=new int[fields.length + 1];
  }
  int structByteEnd=start + length;
  int fieldId=0;
  int fieldByteBegin=start;
  int fieldByteEnd=start;
  byte[] bytes=this.bytes.getData();
  while (fieldByteEnd <= structByteEnd) {
    if (fieldByteEnd == structByteEnd || bytes[fieldByteEnd] == separator) {
      if (lastColumnTakesRest && fieldId == fields.length - 1) {
        fieldByteEnd=structByteEnd;
      }
      startPosition[fieldId]=fieldByteBegin;
      fieldId++;
      if (fieldId == fields.length || fieldByteEnd == structByteEnd) {
        for (int i=fieldId; i <= fields.length; i++) {
          startPosition[i]=fieldByteEnd + 1;
        }
        break;
      }
      fieldByteBegin=fieldByteEnd + 1;
    }
    fieldByteEnd++;
  }
  if (!extraFieldWarned && fieldByteEnd < structByteEnd) {
    extraFieldWarned=true;
    LOG.warn("Extra bytes detected at the end of the row! Ignoring similar " + "problems.");
  }
  if (!missingFieldWarned && fieldId < fields.length) {
    missingFieldWarned=true;
    LOG.warn("Missing fields! Expected " + fields.length + " fields but "+ "only got "+ fieldId+ "! Ignoring similar problems.");
  }
  Arrays.fill(fieldInited,false);
  parsed=true;
}
