{
  int structByteEnd=start + length;
  int fieldId=0;
  int fieldByteBegin=start;
  int fieldByteEnd=start;
  while (fieldByteEnd <= structByteEnd) {
    if (fieldByteEnd == structByteEnd || bytes[fieldByteEnd] == separator) {
      if (lastColumnTakesAll && fieldId == fields.length - 1) {
        fieldByteEnd=structByteEnd;
      }
      int fieldLength=fieldByteEnd - fieldByteBegin;
      if (fieldLength == nullSequence.getLength() && LazyUtils.compare(bytes,fieldByteBegin,fieldLength,nullSequence.getBytes(),0,nullSequence.getLength()) == 0) {
        fields[fieldId].setAll(null,0,0);
      }
 else {
        fields[fieldId].setAll(bytes,fieldByteBegin,fieldByteEnd - fieldByteBegin);
      }
      fieldId++;
      if (fieldId == fields.length || fieldByteEnd == structByteEnd) {
        break;
      }
      fieldByteBegin=fieldByteEnd + 1;
    }
    fieldByteEnd++;
  }
  if (!extraFieldWarned && fieldByteEnd < structByteEnd) {
    extraFieldWarned=true;
    LOG.warn("Extra bytes detected at the end of the row! Ignoring similar problems.");
  }
  if (!missingFieldWarned && fieldId < fields.length) {
    missingFieldWarned=true;
    LOG.warn("Missing fields! Expected " + fields.length + " fields but only got "+ fieldId+ "! Ignoring similar problems.");
  }
  for (; fieldId < fields.length; fieldId++) {
    fields[fieldId].setAll(null,0,0);
  }
  parsed=true;
}
