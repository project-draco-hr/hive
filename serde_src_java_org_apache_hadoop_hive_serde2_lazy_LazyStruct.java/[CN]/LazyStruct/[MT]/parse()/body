{
  byte separator=oi.getSeparator();
  boolean lastColumnTakesRest=oi.getLastColumnTakesRest();
  boolean isEscaped=oi.isEscaped();
  byte escapeChar=oi.getEscapeChar();
  if (fields == null) {
    List<? extends StructField> fieldRefs=((StructObjectInspector)oi).getAllStructFieldRefs();
    fields=new LazyObject[fieldRefs.size()];
    for (int i=0; i < fields.length; i++) {
      fields[i]=LazyFactory.createLazyObject(fieldRefs.get(i).getFieldObjectInspector());
    }
    fieldInited=new boolean[fields.length];
    startPosition=new int[fields.length + 1];
  }
  int structByteEnd=start + length;
  int fieldId=0;
  int fieldByteBegin=start;
  int fieldByteEnd=start;
  byte[] bytes=this.bytes.getData();
  while (fieldByteEnd <= structByteEnd) {
    if (fieldByteEnd == structByteEnd || bytes[fieldByteEnd] == separator) {
      if (lastColumnTakesRest && fieldId == fields.length - 1) {
        fieldByteEnd=structByteEnd;
      }
      startPosition[fieldId]=fieldByteBegin;
      fieldId++;
      if (fieldId == fields.length || fieldByteEnd == structByteEnd) {
        for (int i=fieldId; i <= fields.length; i++) {
          startPosition[i]=fieldByteEnd + 1;
        }
        break;
      }
      fieldByteBegin=fieldByteEnd + 1;
      fieldByteEnd++;
    }
 else {
      if (isEscaped && bytes[fieldByteEnd] == escapeChar && fieldByteEnd + 1 < structByteEnd) {
        fieldByteEnd+=2;
      }
 else {
        fieldByteEnd++;
      }
    }
  }
  if (!extraFieldWarned && fieldByteEnd < structByteEnd) {
    extraFieldWarned=true;
    LOG.warn("Extra bytes detected at the end of the row! Ignoring similar " + "problems.");
  }
  if (!missingFieldWarned && fieldId < fields.length) {
    missingFieldWarned=true;
    LOG.warn("Missing fields! Expected " + fields.length + " fields but "+ "only got "+ fieldId+ "! Ignoring similar problems.");
  }
  Arrays.fill(fieldInited,false);
  parsed=true;
}
