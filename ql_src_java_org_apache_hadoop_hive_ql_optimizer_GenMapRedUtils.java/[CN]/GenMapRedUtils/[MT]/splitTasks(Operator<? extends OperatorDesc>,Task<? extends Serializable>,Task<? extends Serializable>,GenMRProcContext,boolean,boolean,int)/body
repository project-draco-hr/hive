{
  childTask.getWork();
  Operator<? extends OperatorDesc> currTopOp=opProcCtx.getCurrTopOp();
  ParseContext parseCtx=opProcCtx.getParseCtx();
  parentTask.addDependentTask(childTask);
  List<Task<? extends Serializable>> rootTasks=opProcCtx.getRootTasks();
  if (rootTasks.contains(childTask)) {
    rootTasks.remove(childTask);
  }
  Context baseCtx=parseCtx.getContext();
  String taskTmpDir=baseCtx.getMRTmpFileURI();
  Operator<? extends OperatorDesc> parent=op.getParentOperators().get(posn);
  TableDesc tt_desc=PlanUtils.getIntermediateFileTableDesc(PlanUtils.getFieldSchemasFromRowSchema(parent.getSchema(),"temporarycol"));
  boolean compressIntermediate=parseCtx.getConf().getBoolVar(HiveConf.ConfVars.COMPRESSINTERMEDIATE);
  FileSinkDesc desc=new FileSinkDesc(taskTmpDir,tt_desc,compressIntermediate);
  if (compressIntermediate) {
    desc.setCompressCodec(parseCtx.getConf().getVar(HiveConf.ConfVars.COMPRESSINTERMEDIATECODEC));
    desc.setCompressType(parseCtx.getConf().getVar(HiveConf.ConfVars.COMPRESSINTERMEDIATETYPE));
  }
  Operator<? extends OperatorDesc> fs_op=putOpInsertMap(OperatorFactory.get(desc,parent.getSchema()),null,parseCtx);
  List<Operator<? extends OperatorDesc>> childOpList=parent.getChildOperators();
  for (int pos=0; pos < childOpList.size(); pos++) {
    if (childOpList.get(pos) == op) {
      childOpList.set(pos,fs_op);
      break;
    }
  }
  List<Operator<? extends OperatorDesc>> parentOpList=new ArrayList<Operator<? extends OperatorDesc>>();
  parentOpList.add(parent);
  fs_op.setParentOperators(parentOpList);
  RowResolver rowResolver=opProcCtx.getParseCtx().getOpParseCtx().get(parent).getRowResolver();
  Operator<? extends OperatorDesc> ts_op=putOpInsertMap(OperatorFactory.get(TableScanDesc.class,parent.getSchema()),rowResolver,parseCtx);
  childOpList=new ArrayList<Operator<? extends OperatorDesc>>();
  childOpList.add(op);
  ts_op.setChildOperators(childOpList);
  op.getParentOperators().set(posn,ts_op);
  Map<Operator<? extends OperatorDesc>,GenMapRedCtx> mapCurrCtx=opProcCtx.getMapCurrCtx();
  mapCurrCtx.put(ts_op,new GenMapRedCtx(childTask,null,null));
  String streamDesc=taskTmpDir;
  MapredWork cplan=(MapredWork)childTask.getWork();
  if (setReducer) {
    Operator<? extends OperatorDesc> reducer=op.getChildOperators().get(0);
    if (reducer.getClass() == JoinOperator.class) {
      String origStreamDesc;
      streamDesc="$INTNAME";
      origStreamDesc=streamDesc;
      int pos=0;
      while (cplan.getAliasToWork().get(streamDesc) != null) {
        streamDesc=origStreamDesc.concat(String.valueOf(++pos));
      }
    }
    if (reducer.getClass() == JoinOperator.class) {
      cplan.setNeedsTagging(true);
      cplan.setNeedsOperationPathTagging(false);
    }
  }
  setTaskPlan(taskTmpDir,streamDesc,ts_op,cplan,local,tt_desc);
  if (op instanceof AbstractMapJoinOperator<?>) {
    AbstractMapJoinOperator<? extends MapJoinDesc> mjOp=(AbstractMapJoinOperator<? extends MapJoinDesc>)op;
    opProcCtx.setCurrMapJoinOp(mjOp);
    GenMRMapJoinCtx mjCtx=opProcCtx.getMapJoinCtx(mjOp);
    if (mjCtx == null) {
      mjCtx=new GenMRMapJoinCtx(taskTmpDir,tt_desc,ts_op,null);
    }
 else {
      mjCtx.setTaskTmpDir(taskTmpDir);
      mjCtx.setTTDesc(tt_desc);
      mjCtx.setRootMapJoinOp(ts_op);
    }
    opProcCtx.setMapJoinCtx(mjOp,mjCtx);
    opProcCtx.getMapCurrCtx().put(parent,new GenMapRedCtx(childTask,null,null));
    setupBucketMapJoinInfo(cplan,mjOp,false);
  }
  currTopOp=null;
  String currAliasId=null;
  opProcCtx.setCurrTopOp(currTopOp);
  opProcCtx.setCurrAliasId(currAliasId);
  opProcCtx.setCurrTask(childTask);
}
