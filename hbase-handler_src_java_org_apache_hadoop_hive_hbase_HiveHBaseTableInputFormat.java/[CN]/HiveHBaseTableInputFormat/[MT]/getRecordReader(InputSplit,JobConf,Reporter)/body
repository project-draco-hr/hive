{
  HBaseSplit hbaseSplit=(HBaseSplit)split;
  TableSplit tableSplit=hbaseSplit.getSplit();
  String hbaseTableName=jobConf.get(HBaseSerDe.HBASE_TABLE_NAME);
  setHTable(new HTable(HBaseConfiguration.create(jobConf),Bytes.toBytes(hbaseTableName)));
  String hbaseColumnsMapping=jobConf.get(HBaseSerDe.HBASE_COLUMNS_MAPPING);
  List<Integer> readColIDs=ColumnProjectionUtils.getReadColumnIDs(jobConf);
  List<ColumnMapping> columnsMapping=null;
  try {
    columnsMapping=HBaseSerDe.parseColumnsMapping(hbaseColumnsMapping);
  }
 catch (  SerDeException e) {
    throw new IOException(e);
  }
  if (columnsMapping.size() < readColIDs.size()) {
    throw new IOException("Cannot read more columns than the given table contains.");
  }
  boolean addAll=(readColIDs.size() == 0);
  Scan scan=new Scan();
  boolean empty=true;
  if (!addAll) {
    for (    int i : readColIDs) {
      ColumnMapping colMap=columnsMapping.get(i);
      if (colMap.hbaseRowKey) {
        continue;
      }
      if (colMap.qualifierName == null) {
        scan.addFamily(colMap.familyNameBytes);
      }
 else {
        scan.addColumn(colMap.familyNameBytes,colMap.qualifierNameBytes);
      }
      empty=false;
    }
  }
  if (empty) {
    for (int i=0; i < columnsMapping.size(); i++) {
      ColumnMapping colMap=columnsMapping.get(i);
      if (colMap.hbaseRowKey) {
        continue;
      }
      if (colMap.qualifierName == null) {
        scan.addFamily(colMap.familyNameBytes);
      }
 else {
        scan.addColumn(colMap.familyNameBytes,colMap.qualifierNameBytes);
      }
      if (!addAll) {
        break;
      }
    }
  }
  int iKey=-1;
  try {
    iKey=HBaseSerDe.getRowKeyColumnOffset(columnsMapping);
  }
 catch (  SerDeException e) {
    throw new IOException(e);
  }
  tableSplit=convertFilter(jobConf,scan,tableSplit,iKey);
  setScan(scan);
  Job job=new Job(jobConf);
  TaskAttemptContext tac=ShimLoader.getHadoopShims().newTaskAttemptContext(job.getConfiguration(),reporter);
  final org.apache.hadoop.mapreduce.RecordReader<ImmutableBytesWritable,Result> recordReader=createRecordReader(tableSplit,tac);
  return new RecordReader<ImmutableBytesWritable,Result>(){
    @Override public void close() throws IOException {
      recordReader.close();
    }
    @Override public ImmutableBytesWritable createKey(){
      return new ImmutableBytesWritable();
    }
    @Override public Result createValue(){
      return new Result();
    }
    @Override public long getPos() throws IOException {
      return 0;
    }
    @Override public float getProgress() throws IOException {
      float progress=0.0F;
      try {
        progress=recordReader.getProgress();
      }
 catch (      InterruptedException e) {
        throw new IOException(e);
      }
      return progress;
    }
    @Override public boolean next(    ImmutableBytesWritable rowKey,    Result value) throws IOException {
      boolean next=false;
      try {
        next=recordReader.nextKeyValue();
        if (next) {
          rowKey.set(recordReader.getCurrentValue().getRow());
          Writables.copyWritable(recordReader.getCurrentValue(),value);
        }
      }
 catch (      InterruptedException e) {
        throw new IOException(e);
      }
      return next;
    }
  }
;
}
