{
  ParseContext tempParseContext=getParseContext(pCtx,rootTasks);
  GenTezWork genTezWork=new GenTezWork();
  Deque<Operator<?>> deque=new LinkedList<Operator<?>>();
  deque.addAll(pCtx.getTopOps().values());
  GenTezProcContext procCtx=new GenTezProcContext(conf,tempParseContext,mvTask,rootTasks,inputs,outputs,deque);
  Map<Rule,NodeProcessor> opRules=new LinkedHashMap<Rule,NodeProcessor>();
  opRules.put(new RuleRegExp("Split Work - ReduceSink",ReduceSinkOperator.getOperatorName() + "%"),genTezWork);
  opRules.put(new RuleRegExp("No more walking on ReduceSink-MapJoin",ReduceSinkOperator.getOperatorName() + "%" + MapJoinOperator.getOperatorName()+ "%"),new ReduceSinkMapJoinProc());
  opRules.put(new RuleRegExp("Split Work + Move/Merge - FileSink",FileSinkOperator.getOperatorName() + "%"),new CompositeProcessor(new FileSinkProcessor(),genTezWork));
  opRules.put(new RuleRegExp("Bail on Union",UnionOperator.getOperatorName() + "%"),new NodeProcessor(){
    @Override public Object process(    Node n,    Stack<Node> s,    NodeProcessorCtx procCtx,    Object... os) throws SemanticException {
      throw new SemanticException("Unions not yet supported on Tez." + " Please use MR for this query");
    }
  }
);
  opRules.put(new RuleRegExp("Setup table scan",TableScanOperator.getOperatorName() + "%"),new NodeProcessor(){
    @Override public Object process(    Node n,    Stack<Node> s,    NodeProcessorCtx procCtx,    Object... os) throws SemanticException {
      GenTezProcContext context=(GenTezProcContext)procCtx;
      TableScanOperator tableScan=(TableScanOperator)n;
      LOG.debug("TableScan operator (" + tableScan + "). Number of branches: "+ tableScan.getNumChild());
      context.lastRootOfMultiChildOperator.push(tableScan);
      context.currentBranchCount.push(tableScan.getNumChild());
      context.lastWorkForMultiChildOperator.push(null);
      return null;
    }
  }
);
  opRules.put(new RuleRegExp("Handle Forward opertor",ForwardOperator.getOperatorName() + "%"),new NodeProcessor(){
    @Override public Object process(    Node n,    Stack<Node> s,    NodeProcessorCtx procCtx,    Object... os) throws SemanticException {
      GenTezProcContext context=(GenTezProcContext)procCtx;
      ForwardOperator forward=(ForwardOperator)n;
      LOG.debug("Forward operator (" + forward + "). Number of branches: "+ forward.getNumChild());
      context.lastRootOfMultiChildOperator.push(context.currentRootOperator);
      context.currentBranchCount.push(forward.getNumChild());
      context.lastWorkForMultiChildOperator.push(null);
      return null;
    }
  }
);
  Dispatcher disp=new DefaultRuleDispatcher(null,opRules,procCtx);
  List<Node> topNodes=new ArrayList<Node>();
  topNodes.addAll(pCtx.getTopOps().values());
  GraphWalker ogw=new TezWalker(disp);
  ogw.startWalking(topNodes,null);
}
