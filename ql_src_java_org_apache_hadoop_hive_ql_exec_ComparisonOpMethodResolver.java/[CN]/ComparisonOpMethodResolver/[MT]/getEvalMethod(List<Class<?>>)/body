{
  assert(argClasses.size() == 2);
  List<Class<?>> pClasses=null;
  if (argClasses.get(0) == Void.class || argClasses.get(1) == Void.class) {
    pClasses=new ArrayList<Class<?>>();
    pClasses.add(Double.class);
    pClasses.add(Double.class);
  }
 else   if (argClasses.get(0) == argClasses.get(1)) {
    pClasses=argClasses;
  }
 else   if (argClasses.get(0) == java.sql.Date.class || argClasses.get(1) == java.sql.Date.class) {
    pClasses=new ArrayList<Class<?>>();
    pClasses.add(java.sql.Date.class);
    pClasses.add(java.sql.Date.class);
  }
 else {
    pClasses=new ArrayList<Class<?>>();
    pClasses.add(Double.class);
    pClasses.add(Double.class);
  }
  Method udfMethod=null;
  for (  Method m : Arrays.asList(udfClass.getMethods())) {
    if (m.getName().equals("evaluate")) {
      Class<?>[] argumentTypeInfos=m.getParameterTypes();
      boolean match=(argumentTypeInfos.length == pClasses.size());
      for (int i=0; i < pClasses.size() && match; i++) {
        Class<?> accepted=ObjectInspectorUtils.generalizePrimitive(argumentTypeInfos[i]);
        if (accepted != pClasses.get(i)) {
          match=false;
        }
      }
      if (match) {
        if (udfMethod != null) {
          throw new AmbiguousMethodException(udfClass,argClasses);
        }
 else {
          udfMethod=m;
        }
      }
    }
  }
  return udfMethod;
}
