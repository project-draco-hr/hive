{
  assert(argTypeInfos.size() == 2);
  List<TypeInfo> pTypeInfos=null;
  if (argTypeInfos.get(0).equals(TypeInfoFactory.voidTypeInfo) || argTypeInfos.get(1).equals(TypeInfoFactory.voidTypeInfo)) {
    pTypeInfos=new ArrayList<TypeInfo>();
    pTypeInfos.add(TypeInfoFactory.doubleTypeInfo);
    pTypeInfos.add(TypeInfoFactory.doubleTypeInfo);
  }
 else   if (argTypeInfos.get(0).equals(TypeInfoFactory.booleanTypeInfo) && argTypeInfos.get(1).equals(TypeInfoFactory.booleanTypeInfo)) {
    pTypeInfos=new ArrayList<TypeInfo>();
    pTypeInfos.add(TypeInfoFactory.intTypeInfo);
    pTypeInfos.add(TypeInfoFactory.intTypeInfo);
  }
 else   if (argTypeInfos.get(0) == argTypeInfos.get(1)) {
    pTypeInfos=argTypeInfos;
  }
 else {
    pTypeInfos=new ArrayList<TypeInfo>();
    pTypeInfos.add(TypeInfoFactory.doubleTypeInfo);
    pTypeInfos.add(TypeInfoFactory.doubleTypeInfo);
  }
  Method udfMethod=null;
  List<Method> evaluateMethods=new ArrayList<Method>();
  for (  Method m : Arrays.asList(udfClass.getMethods())) {
    if (m.getName().equals("evaluate")) {
      evaluateMethods.add(m);
      List<TypeInfo> acceptedTypeInfos=TypeInfoUtils.getParameterTypeInfos(m,pTypeInfos.size());
      if (acceptedTypeInfos == null) {
        continue;
      }
      boolean match=(acceptedTypeInfos.size() == pTypeInfos.size());
      for (int i=0; i < pTypeInfos.size() && match; i++) {
        TypeInfo accepted=acceptedTypeInfos.get(i);
        if (accepted != pTypeInfos.get(i)) {
          match=false;
        }
      }
      if (match) {
        if (udfMethod != null) {
          throw new AmbiguousMethodException(udfClass,argTypeInfos,Arrays.asList(new Method[]{udfMethod,m}));
        }
 else {
          udfMethod=m;
        }
      }
    }
  }
  if (udfMethod == null) {
    throw new NoMatchingMethodException(udfClass,argTypeInfos,evaluateMethods);
  }
  return udfMethod;
}
