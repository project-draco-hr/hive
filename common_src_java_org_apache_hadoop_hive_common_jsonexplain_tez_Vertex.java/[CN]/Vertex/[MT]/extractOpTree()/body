{
  if (vertexObject.length() != 0) {
    for (    String key : JSONObject.getNames(vertexObject)) {
      if (key.equals("Map Operator Tree:")) {
        extractOp(vertexObject.getJSONArray(key).getJSONObject(0));
      }
 else       if (key.equals("Reduce Operator Tree:") || key.equals("Processor Tree:")) {
        extractOp(vertexObject.getJSONObject(key));
      }
 else       if (key.equals("Join:")) {
        JSONArray array=vertexObject.getJSONArray(key);
        for (int index=0; index < array.length(); index++) {
          JSONObject mpOpTree=array.getJSONObject(index);
          Vertex v=new Vertex(null,mpOpTree,parser);
          v.extractOpTree();
          v.dummy=true;
          mergeJoinDummyVertexs.add(v);
        }
      }
 else       if (key.equals("Merge File Operator")) {
        JSONObject opTree=vertexObject.getJSONObject(key);
        if (opTree.has("Map Operator Tree:")) {
          extractOp(opTree.getJSONArray("Map Operator Tree:").getJSONObject(0));
        }
 else {
          throw new Exception("Merge File Operator does not have a Map Operator Tree");
        }
      }
 else       if (key.equals("Execution mode:")) {
        executionMode=" " + vertexObject.getString(key);
      }
 else       if (key.equals("tagToInput:")) {
        JSONObject tagToInput=vertexObject.getJSONObject(key);
        for (        String tag : JSONObject.getNames(tagToInput)) {
          this.tagToInput.put(tag,(String)tagToInput.get(tag));
        }
      }
 else       if (key.equals("tag:")) {
        this.tag=vertexObject.getString(key);
      }
 else {
        throw new Exception("Unsupported operator tree in vertex " + this.name);
      }
    }
  }
}
