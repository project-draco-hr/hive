{
  byte[] magic=new byte[MAGIC.length];
  in.readFully(magic);
  if (Arrays.equals(magic,ORIGINAL_MAGIC)) {
    byte vers=in.readByte();
    if (vers != ORIGINAL_MAGIC_VERSION_WITH_METADATA) {
      throw new IOException(file + " is a version " + vers+ " SequenceFile instead of an RCFile.");
    }
    version=ORIGINAL_VERSION;
  }
 else {
    if (!Arrays.equals(magic,MAGIC)) {
      throw new IOException(file + " not a RCFile and has magic of " + new String(magic));
    }
    version=in.readByte();
    if (version > CURRENT_VERSION) {
      throw new VersionMismatchException((byte)CURRENT_VERSION,version);
    }
  }
  if (version == ORIGINAL_VERSION) {
    try {
      Class<?> keyCls=conf.getClassByName(Text.readString(in));
      Class<?> valCls=conf.getClassByName(Text.readString(in));
      if (!keyCls.equals(KeyBuffer.class) || !valCls.equals(ValueBuffer.class)) {
        throw new IOException(file + " not a RCFile");
      }
    }
 catch (    ClassNotFoundException e) {
      throw new IOException(file + " not a RCFile",e);
    }
  }
  decompress=in.readBoolean();
  if (version == ORIGINAL_VERSION) {
    boolean blkCompressed=in.readBoolean();
    if (blkCompressed) {
      throw new IOException(file + " not a RCFile.");
    }
  }
  if (decompress) {
    String codecClassname=Text.readString(in);
    try {
      Class<? extends CompressionCodec> codecClass=conf.getClassByName(codecClassname).asSubclass(CompressionCodec.class);
      codec=(CompressionCodec)ReflectionUtils.newInstance(codecClass,conf);
    }
 catch (    ClassNotFoundException cnfe) {
      throw new IllegalArgumentException("Unknown codec: " + codecClassname,cnfe);
    }
    keyDecompressor=CodecPool.getDecompressor(codec);
  }
  metadata=new Metadata();
  metadata.readFields(in);
  in.readFully(sync);
  headerEnd=in.getPos();
}
