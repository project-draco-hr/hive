{
  conf.setInt("io.file.buffer.size",bufferSize);
  this.file=file;
  in=openFile(fs,file,bufferSize,length);
  this.conf=conf;
  end=start + length;
  boolean succeed=false;
  try {
    if (start > 0) {
      seek(0);
      init();
      seek(start);
    }
 else {
      init();
    }
    succeed=true;
  }
  finally {
    if (!succeed) {
      if (in != null) {
        try {
          in.close();
        }
 catch (        IOException e) {
          if (LOG != null && LOG.isDebugEnabled()) {
            LOG.debug("Exception in closing " + in,e);
          }
        }
      }
    }
  }
  columnNumber=Integer.parseInt(metadata.get(new Text(COLUMN_NUMBER_METADATA_STR)).toString());
  java.util.ArrayList<Integer> notSkipIDs=ColumnProjectionUtils.getReadColumnIDs(conf);
  skippedColIDs=new boolean[columnNumber];
  if (notSkipIDs.size() > 0) {
    for (int i=0; i < skippedColIDs.length; i++) {
      skippedColIDs[i]=true;
    }
    for (    int read : notSkipIDs) {
      if (read < columnNumber) {
        skippedColIDs[read]=false;
      }
    }
  }
 else {
    for (int i=0; i < skippedColIDs.length; i++) {
      skippedColIDs[i]=false;
    }
  }
  loadColumnNum=columnNumber;
  if (skippedColIDs != null && skippedColIDs.length > 0) {
    for (    boolean skippedColID : skippedColIDs) {
      if (skippedColID) {
        loadColumnNum-=1;
      }
    }
  }
  prjColIDs=new int[loadColumnNum];
  for (int i=0, j=0; i < columnNumber; ++i) {
    if (!skippedColIDs[i]) {
      prjColIDs[j++]=i;
    }
  }
  colValLenBufferReadIn=new NonSyncDataInputBuffer[columnNumber];
  columnRunLength=new int[columnNumber];
  columnPrvLength=new int[columnNumber];
  columnRowReadIndex=new int[columnNumber];
  for (int i=0; i < columnNumber; i++) {
    columnRowReadIndex[i]=0;
    if (!skippedColIDs[i]) {
      colValLenBufferReadIn[i]=new NonSyncDataInputBuffer();
    }
    columnRunLength[i]=0;
    columnPrvLength[i]=-1;
  }
  currentKey=createKeyBuffer();
  currentValue=new ValueBuffer(null,columnNumber,skippedColIDs,codec);
}
