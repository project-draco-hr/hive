{
  conf.setInt("io.file.buffer.size",bufferSize);
  this.file=file;
  in=fs.open(file,bufferSize);
  this.conf=conf;
  end=start + length;
  if (start > 0) {
    seek(0);
    init();
    seek(start);
  }
 else {
    init();
  }
  columnNumber=Integer.parseInt(metadata.get(new Text(COLUMN_NUMBER_METADATA_STR)).toString());
  java.util.ArrayList<Integer> notSkipIDs=ColumnProjectionUtils.getReadColumnIDs(conf);
  skippedColIDs=new boolean[columnNumber];
  if (notSkipIDs.size() > 0) {
    for (int i=0; i < skippedColIDs.length; i++) {
      skippedColIDs[i]=true;
    }
    for (    int read : notSkipIDs) {
      if (read < columnNumber)       skippedColIDs[read]=false;
    }
  }
 else {
    for (int i=0; i < skippedColIDs.length; i++) {
      skippedColIDs[i]=false;
    }
  }
  loadColumnNum=columnNumber;
  if (skippedColIDs != null && skippedColIDs.length > 0) {
    for (int i=0; i < skippedColIDs.length; i++) {
      if (skippedColIDs[i])       loadColumnNum-=1;
    }
  }
  prjColIDs=new int[loadColumnNum];
  for (int i=0, j=0; i < columnNumber; ++i) {
    if (!skippedColIDs[i]) {
      prjColIDs[j++]=i;
    }
  }
  colValLenBufferReadIn=new NonSyncDataInputBuffer[columnNumber];
  columnRunLength=new int[columnNumber];
  columnPrvLength=new int[columnNumber];
  columnRowReadIndex=new int[columnNumber];
  for (int i=0; i < columnNumber; i++) {
    columnRowReadIndex[i]=0;
    if (!skippedColIDs[i])     colValLenBufferReadIn[i]=new NonSyncDataInputBuffer();
    columnRunLength[i]=0;
    columnPrvLength[i]=-1;
  }
  currentKey=createKeyBuffer();
  currentValue=new ValueBuffer(null,columnNumber,skippedColIDs,codec);
}
