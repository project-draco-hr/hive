{
  int addIndex=0;
  int skipTotal=0;
  for (int i=0; i < columnNumber; i++) {
    int vaRowsLen=keyBuffer.eachColumnValueLen[i];
    if (skippedColIDs[i]) {
      skipTotal+=vaRowsLen;
      continue;
    }
    if (skipTotal != 0) {
      in.skipBytes(skipTotal);
      skipTotal=0;
    }
    NonSyncDataOutputBuffer valBuf;
    if (codec != null) {
      valBuf=compressedColumnsValueBuffer[addIndex];
    }
 else {
      valBuf=loadedColumnsValueBuffer[addIndex];
    }
    valBuf.reset();
    valBuf.write(in,vaRowsLen);
    if (codec != null) {
      decompressedFlag[addIndex]=false;
      if (!lazyDecompress) {
        lazyDecompressCallbackObjs[addIndex].decompress();
        decompressedFlag[addIndex]=true;
      }
    }
    addIndex++;
  }
  if (codec != null) {
    numCompressed=decompressedFlag.length;
  }
  if (skipTotal != 0) {
    in.skipBytes(skipTotal);
  }
}
