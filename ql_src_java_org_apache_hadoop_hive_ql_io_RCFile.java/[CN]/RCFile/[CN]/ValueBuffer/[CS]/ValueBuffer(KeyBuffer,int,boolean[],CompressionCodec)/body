{
  keyBuffer=currentKey;
  this.columnNumber=columnNumber;
  if (skippedCols != null && skippedCols.length > 0) {
    skippedColIDs=skippedCols;
  }
 else {
    skippedColIDs=new boolean[columnNumber];
    for (int i=0; i < skippedColIDs.length; i++) {
      skippedColIDs[i]=false;
    }
  }
  int skipped=0;
  if (skippedColIDs != null) {
    for (    boolean currentSkip : skippedColIDs) {
      if (currentSkip) {
        skipped++;
      }
    }
  }
  loadedColumnsValueBuffer=new NonSyncDataOutputBuffer[columnNumber - skipped];
  decompressedFlag=new boolean[columnNumber - skipped];
  lazyDecompressCallbackObjs=new LazyDecompressionCallbackImpl[columnNumber - skipped];
  this.codec=codec;
  if (codec != null) {
    valDecompressor=CodecPool.getDecompressor(codec);
    deflatFilter=codec.createInputStream(decompressBuffer,valDecompressor);
  }
  for (int k=0, readIndex=0; k < columnNumber; k++) {
    if (skippedColIDs[k]) {
      continue;
    }
    loadedColumnsValueBuffer[readIndex]=new NonSyncDataOutputBuffer();
    if (codec != null) {
      decompressedFlag[readIndex]=false;
      lazyDecompressCallbackObjs[readIndex]=new LazyDecompressionCallbackImpl(readIndex,k);
    }
 else {
      decompressedFlag[readIndex]=true;
    }
    readIndex++;
  }
}
