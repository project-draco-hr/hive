{
  final ConcurrentLinkedQueue<Path> nextLevel=new ConcurrentLinkedQueue<>();
  if (null == pool) {
    for (    final Path path : basePaths) {
      FileStatus[] statuses=fs.listStatus(path,FileUtils.HIDDEN_FILES_PATH_FILTER);
      boolean fileFound=false;
      for (      FileStatus status : statuses) {
        if (status.isDirectory()) {
          nextLevel.add(status.getPath());
        }
 else {
          fileFound=true;
        }
      }
      if (depth != 0) {
        if (fileFound) {
          if ("throw".equals(HiveConf.getVar(conf,HiveConf.ConfVars.HIVE_MSCK_PATH_VALIDATION))) {
            throw new HiveException("MSCK finds a file rather than a folder when it searches for " + path.toString());
          }
 else {
            LOG.warn("MSCK finds a file rather than a folder when it searches for " + path.toString());
          }
        }
        if (!nextLevel.isEmpty()) {
          checkPartitionDirs(pool,nextLevel,allDirs,fs,depth - 1,maxDepth);
        }
 else         if (depth != maxDepth) {
          if ("throw".equals(HiveConf.getVar(conf,HiveConf.ConfVars.HIVE_MSCK_PATH_VALIDATION))) {
            throw new HiveException("MSCK is missing partition columns under " + path.toString());
          }
 else {
            LOG.warn("MSCK is missing partition columns under " + path.toString());
          }
        }
      }
 else {
        allDirs.put(path,true);
      }
    }
  }
 else {
    final List<Future<Void>> futures=new LinkedList<>();
    for (    final Path path : basePaths) {
      futures.add(pool.submit(new Callable<Void>(){
        @Override public Void call() throws Exception {
          FileStatus[] statuses=fs.listStatus(path,FileUtils.HIDDEN_FILES_PATH_FILTER);
          boolean fileFound=false;
          for (          FileStatus status : statuses) {
            if (status.isDirectory()) {
              nextLevel.add(status.getPath());
            }
 else {
              fileFound=true;
            }
          }
          if (depth != 0) {
            if (fileFound) {
              if ("throw".equals(HiveConf.getVar(conf,HiveConf.ConfVars.HIVE_MSCK_PATH_VALIDATION))) {
                throw new HiveException("MSCK finds a file rather than a folder when it searches for " + path.toString());
              }
 else {
                LOG.warn("MSCK finds a file rather than a folder when it searches for " + path.toString());
              }
            }
            if (!nextLevel.isEmpty()) {
              checkPartitionDirs(pool,nextLevel,allDirs,fs,depth - 1,maxDepth);
            }
 else             if (depth != maxDepth) {
              if ("throw".equals(HiveConf.getVar(conf,HiveConf.ConfVars.HIVE_MSCK_PATH_VALIDATION))) {
                throw new HiveException("MSCK is missing partition columns under " + path.toString());
              }
 else {
                LOG.warn("MSCK is missing partition columns under " + path.toString());
              }
            }
          }
 else {
            allDirs.put(path,true);
          }
          return null;
        }
      }
));
    }
    for (    Future<Void> future : futures) {
      try {
        future.get();
      }
 catch (      Exception e) {
        LOG.error(e.getMessage());
        pool.shutdownNow();
        throw new HiveException(e.getCause());
      }
    }
    if (!nextLevel.isEmpty() && depth != 0) {
      checkPartitionDirs(pool,nextLevel,allDirs,fs,depth - 1,maxDepth);
    }
  }
}
