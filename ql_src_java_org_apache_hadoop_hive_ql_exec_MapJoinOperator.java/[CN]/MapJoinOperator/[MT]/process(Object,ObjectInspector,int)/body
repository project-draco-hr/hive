{
  try {
    alias=(byte)tag;
    if ((lastAlias == null) || (!lastAlias.equals(alias)))     nextSz=joinEmitInterval;
    ArrayList<Object> key=computeValues(row,rowInspector,joinKeys.get(alias),joinKeysObjectInspectors);
    ArrayList<Object> value=computeValues(row,rowInspector,joinValues.get(alias),joinValuesObjectInspectors);
    int keyPos=0;
    for (    Object keyElem : key) {
      PrimitiveObjectInspector poi=(PrimitiveObjectInspector)joinKeysObjectInspectors.get(alias).get(keyPos);
      if (!poi.isWritable()) {
        key.set(keyPos,ObjectInspectorUtils.copyToStandardObject(key.get(keyPos),poi,ObjectInspectorCopyOption.WRITABLE));
      }
      keyPos++;
    }
    if (tag != posBigTable) {
      if (firstRow) {
        metadataKeyTag=nextVal++;
        tableDesc keyTableDesc=conf.getKeyTblDesc();
        Serializer keySerializer=(Serializer)keyTableDesc.getDeserializerClass().newInstance();
        keySerializer.initialize(null,keyTableDesc.getProperties());
        ExprNodeEvaluator[] keyEval=new ExprNodeEvaluator[conf.getKeys().get(new Byte((byte)tag)).size()];
        int i=0;
        for (        exprNodeDesc e : conf.getKeys().get(new Byte((byte)tag))) {
          keyEval[i++]=ExprNodeEvaluatorFactory.get(e);
        }
        List<String> keyOutputCols=new ArrayList<String>();
        for (int k=0; k < keyEval.length; k++) {
          keyOutputCols.add(HiveConf.getColumnInternalName(k));
        }
        ObjectInspector keyObjectInspector=initEvaluatorsAndReturnStruct(keyEval,keyOutputCols,rowInspector);
        Deserializer deserializer=(Deserializer)ReflectionUtils.newInstance(keyTableDesc.getDeserializerClass(),null);
        deserializer.initialize(null,keyTableDesc.getProperties());
        mapMetadata.put(new Integer(metadataKeyTag),new MapJoinObjectCtx(keyObjectInspector,keySerializer,deserializer.getObjectInspector(),deserializer));
        firstRow=false;
      }
      HTree hashTable=mapJoinTables.get(alias);
      MapJoinObjectKey keyMap=new MapJoinObjectKey(metadataKeyTag,key);
      MapJoinObjectValue o=(MapJoinObjectValue)hashTable.get(keyMap);
      Vector<ArrayList<Object>> res=null;
      if (o == null) {
        res=new Vector<ArrayList<Object>>();
      }
 else {
        res=o.getObj();
      }
      res.add(value);
      if (metadataValueTag[tag] == -1) {
        metadataValueTag[tag]=nextVal++;
        tableDesc valueTableDesc=conf.getValueTblDescs().get(tag);
        Serializer valueSerializer=(Serializer)valueTableDesc.getDeserializerClass().newInstance();
        valueSerializer.initialize(null,valueTableDesc.getProperties());
        ExprNodeEvaluator[] valueEval=new ExprNodeEvaluator[conf.getExprs().get(new Byte((byte)tag)).size()];
        int i=0;
        for (        exprNodeDesc e : conf.getExprs().get(new Byte((byte)tag))) {
          valueEval[i++]=ExprNodeEvaluatorFactory.get(e);
        }
        List<String> tagOutputCols=new ArrayList<String>();
        int start=0;
        for (int k=0; k < tag; k++)         start+=conf.getExprs().get(new Byte((byte)k)).size();
        for (int k=0; k < conf.getExprs().get(new Byte((byte)tag)).size(); k++)         tagOutputCols.add(HiveConf.getColumnInternalName(k));
        ObjectInspector valueObjectInspector=initEvaluatorsAndReturnStruct(valueEval,tagOutputCols,rowInspector);
        Deserializer deserializer=(Deserializer)ReflectionUtils.newInstance(valueTableDesc.getDeserializerClass(),null);
        deserializer.initialize(null,valueTableDesc.getProperties());
        mapMetadata.put(new Integer((byte)metadataValueTag[tag]),new MapJoinObjectCtx(valueObjectInspector,valueSerializer,deserializer.getObjectInspector(),deserializer));
      }
      MapJoinObjectKey keyObj=new MapJoinObjectKey(metadataKeyTag,key);
      MapJoinObjectValue valueObj=new MapJoinObjectValue(metadataValueTag[tag],res);
      if (res.size() > 1)       hashTable.remove(keyObj);
      if (res.size() > mapJoinRowsKey) {
        LOG.warn("Number of values for a given key " + keyObj + " are "+ res.size());
      }
      hashTable.put(keyObj,valueObj);
      return;
    }
    storage.get(alias).add(value);
    for (    Byte pos : order) {
      if (pos.intValue() != tag) {
        MapJoinObjectKey keyMap=new MapJoinObjectKey(metadataKeyTag,key);
        MapJoinObjectValue o=(MapJoinObjectValue)mapJoinTables.get(pos).get(keyMap);
        if (o == null) {
          storage.put(pos,new Vector<ArrayList<Object>>());
        }
 else {
          storage.put(pos,o.getObj());
        }
      }
    }
    checkAndGenObject();
    storage.get(alias).clear();
    for (    Byte pos : order)     if (pos.intValue() != tag)     storage.put(pos,null);
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw new HiveException(e);
  }
}
