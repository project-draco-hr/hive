{
  this.hconf=hconf;
  unwrapContainer=new UnwrapRowContainer[conf.getTagLength()];
  Collection<Future<?>> result=super.initializeOp(hconf);
  if (result == null) {
    result=new HashSet<Future<?>>();
  }
  int tagLen=conf.getTagLength();
  cacheKey=HiveConf.getVar(hconf,HiveConf.ConfVars.HIVEQUERYID) + "__HASH_MAP_" + this.getOperatorId()+ "_container";
  cache=ObjectCacheFactory.getCache(hconf);
  loader=HashTableLoaderFactory.getLoader(hconf);
  hashMapRowGetters=null;
  mapJoinTables=new MapJoinTableContainer[tagLen];
  mapJoinTableSerdes=new MapJoinTableContainerSerDe[tagLen];
  hashTblInitedOnce=false;
  generateMapMetaData();
  final ExecMapperContext mapContext=getExecContext();
  final MapredContext mrContext=MapredContext.get();
  if (!conf.isBucketMapJoin()) {
    if (isLogInfoEnabled) {
      LOG.info("This is not bucket map join, so cache");
    }
    Future<Pair<MapJoinTableContainer[],MapJoinTableContainerSerDe[]>> future=cache.retrieveAsync(cacheKey,new Callable<Pair<MapJoinTableContainer[],MapJoinTableContainerSerDe[]>>(){
      @Override public Pair<MapJoinTableContainer[],MapJoinTableContainerSerDe[]> call() throws HiveException {
        return loadHashTable(mapContext,mrContext);
      }
    }
);
    result.add(future);
  }
 else   if (mapContext == null || mapContext.getLocalWork() == null || mapContext.getLocalWork().getInputFileChangeSensitive() == false) {
    loadHashTable(mapContext,mrContext);
    hashTblInitedOnce=true;
  }
  return result;
}
