{
  if (tag == posBigTable) {
    this.getExecContext().processInputFileChangeForLocalWork();
  }
  try {
    alias=(byte)tag;
    if ((lastAlias == null) || (!lastAlias.equals(alias))) {
      nextSz=joinEmitInterval;
    }
    ArrayList<Object> key=computeValues(row,joinKeys.get(alias),joinKeysObjectInspectors.get(alias));
    ArrayList<Object> value=computeValues(row,joinValues.get(alias),joinValuesObjectInspectors.get(alias));
    if (tag != posBigTable) {
      if (firstRow) {
        metadataKeyTag=nextVal++;
        TableDesc keyTableDesc=conf.getKeyTblDesc();
        SerDe keySerializer=(SerDe)ReflectionUtils.newInstance(keyTableDesc.getDeserializerClass(),null);
        keySerializer.initialize(null,keyTableDesc.getProperties());
        mapMetadata.put(Integer.valueOf(metadataKeyTag),new MapJoinObjectCtx(ObjectInspectorUtils.getStandardObjectInspector(keySerializer.getObjectInspector(),ObjectInspectorCopyOption.WRITABLE),keySerializer,keyTableDesc,hconf));
        firstRow=false;
      }
      reportProgress();
      if ((numMapRowsRead > maxMapJoinSize) && (reporter != null) && (counterNameToEnum != null)) {
        LOG.warn("Too many rows in map join tables. Fatal error counter will be incremented!!");
        incrCounter(fatalErrorCntr,1);
        fatalError=true;
        return;
      }
      HashMapWrapper<MapJoinObjectKey,MapJoinObjectValue> hashTable=mapJoinTables.get(alias);
      MapJoinObjectKey keyMap=new MapJoinObjectKey(metadataKeyTag,key);
      MapJoinObjectValue o=hashTable.get(keyMap);
      RowContainer res=null;
      boolean needNewKey=true;
      if (o == null) {
        int bucketSize=HiveConf.getIntVar(hconf,HiveConf.ConfVars.HIVEMAPJOINBUCKETCACHESIZE);
        res=getRowContainer(hconf,(byte)tag,order[tag],bucketSize);
        res.add(value);
      }
 else {
        res=o.getObj();
        res.add(value);
        if (hashTable.cacheSize() > 0) {
          o.setObj(res);
          needNewKey=false;
        }
      }
      if (metadataValueTag[tag] == -1) {
        metadataValueTag[tag]=nextVal++;
        TableDesc valueTableDesc=conf.getValueTblDescs().get(tag);
        SerDe valueSerDe=(SerDe)ReflectionUtils.newInstance(valueTableDesc.getDeserializerClass(),null);
        valueSerDe.initialize(null,valueTableDesc.getProperties());
        mapMetadata.put(Integer.valueOf(metadataValueTag[tag]),new MapJoinObjectCtx(ObjectInspectorUtils.getStandardObjectInspector(valueSerDe.getObjectInspector(),ObjectInspectorCopyOption.WRITABLE),valueSerDe,valueTableDesc,hconf));
      }
      if (needNewKey) {
        MapJoinObjectKey keyObj=new MapJoinObjectKey(metadataKeyTag,key);
        MapJoinObjectValue valueObj=new MapJoinObjectValue(metadataValueTag[tag],res);
        valueObj.setConf(hconf);
        valueObj.setConf(hconf);
        if (res.size() > mapJoinRowsKey) {
          if (res.size() % 100 == 0) {
            LOG.warn("Number of values for a given key " + keyObj + " are "+ res.size());
            LOG.warn("used memory " + Runtime.getRuntime().totalMemory());
          }
        }
        hashTable.put(keyObj,valueObj);
      }
      return;
    }
    storage.get(alias).add(value);
    for (    Byte pos : order) {
      if (pos.intValue() != tag) {
        MapJoinObjectKey keyMap=new MapJoinObjectKey(metadataKeyTag,key);
        MapJoinObjectValue o=mapJoinTables.get(pos).get(keyMap);
        if (o == null) {
          if (noOuterJoin) {
            storage.put(pos,emptyList);
          }
 else {
            storage.put(pos,dummyObjVectors[pos.intValue()]);
          }
        }
 else {
          storage.put(pos,o.getObj());
        }
      }
    }
    checkAndGenObject();
    storage.get(alias).clear();
    for (    Byte pos : order) {
      if (pos.intValue() != tag) {
        storage.put(pos,null);
      }
    }
  }
 catch (  SerDeException e) {
    e.printStackTrace();
    throw new HiveException(e);
  }
}
