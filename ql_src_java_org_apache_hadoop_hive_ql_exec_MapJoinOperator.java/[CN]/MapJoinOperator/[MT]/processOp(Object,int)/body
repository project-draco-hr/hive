{
  try {
    alias=(byte)tag;
    if ((lastAlias == null) || (!lastAlias.equals(alias)))     nextSz=joinEmitInterval;
    ArrayList<Object> key=computeValues(row,joinKeys.get(alias),joinKeysObjectInspectors.get(alias));
    ArrayList<Object> value=computeValues(row,joinValues.get(alias),joinValuesObjectInspectors.get(alias));
    if (tag != posBigTable) {
      if (firstRow) {
        metadataKeyTag=nextVal++;
        tableDesc keyTableDesc=conf.getKeyTblDesc();
        SerDe keySerializer=(SerDe)ReflectionUtils.newInstance(keyTableDesc.getDeserializerClass(),null);
        keySerializer.initialize(null,keyTableDesc.getProperties());
        mapMetadata.put(Integer.valueOf(metadataKeyTag),new MapJoinObjectCtx(ObjectInspectorUtils.getStandardObjectInspector(keySerializer.getObjectInspector(),ObjectInspectorCopyOption.WRITABLE),keySerializer));
        firstRow=false;
      }
      numMapRowsRead++;
      if (((numMapRowsRead % heartbeatInterval) == 0) && (reporter != null))       reporter.progress();
      HTree hashTable=mapJoinTables.get(alias);
      MapJoinObjectKey keyMap=new MapJoinObjectKey(metadataKeyTag,key);
      MapJoinObjectValue o=(MapJoinObjectValue)hashTable.get(keyMap);
      ArrayList<ArrayList<Object>> res=null;
      if (o == null) {
        res=new ArrayList<ArrayList<Object>>();
      }
 else {
        res=o.getObj();
      }
      res.add(value);
      if (metadataValueTag[tag] == -1) {
        metadataValueTag[tag]=nextVal++;
        tableDesc valueTableDesc=conf.getValueTblDescs().get(tag);
        SerDe valueSerDe=(SerDe)ReflectionUtils.newInstance(valueTableDesc.getDeserializerClass(),null);
        valueSerDe.initialize(null,valueTableDesc.getProperties());
        mapMetadata.put(Integer.valueOf(metadataValueTag[tag]),new MapJoinObjectCtx(ObjectInspectorUtils.getStandardObjectInspector(valueSerDe.getObjectInspector(),ObjectInspectorCopyOption.WRITABLE),valueSerDe));
      }
      MapJoinObjectKey keyObj=new MapJoinObjectKey(metadataKeyTag,key);
      MapJoinObjectValue valueObj=new MapJoinObjectValue(metadataValueTag[tag],res);
      if (res.size() > 1)       hashTable.remove(keyObj);
      if (res.size() > mapJoinRowsKey) {
        if (res.size() % 100 == 0) {
          LOG.warn("Number of values for a given key " + keyObj + " are "+ res.size());
          LOG.warn("used memory " + Runtime.getRuntime().totalMemory());
        }
      }
      hashTable.put(keyObj,valueObj);
      if ((res.size() % 100 == 0) && recman != null) {
        recman.commit();
      }
      return;
    }
    storage.get(alias).add(value);
    for (    Byte pos : order) {
      if (pos.intValue() != tag) {
        MapJoinObjectKey keyMap=new MapJoinObjectKey(metadataKeyTag,key);
        MapJoinObjectValue o=(MapJoinObjectValue)mapJoinTables.get(pos).get(keyMap);
        if (o == null) {
          storage.put(pos,new ArrayList<ArrayList<Object>>());
        }
 else {
          storage.put(pos,o.getObj());
        }
      }
    }
    checkAndGenObject();
    storage.get(alias).clear();
    for (    Byte pos : order)     if (pos.intValue() != tag)     storage.put(pos,null);
  }
 catch (  SerDeException e) {
    e.printStackTrace();
    throw new HiveException(e);
  }
catch (  IOException e) {
    e.printStackTrace();
    throw new HiveException(e);
  }
}
