{
  KeyValueContainer kvContainer=partition.getSidefileKVContainer();
  int rowCount=kvContainer.size();
  LOG.info("Hybrid Grace Hash Join: Number of rows restored from KeyValueContainer: " + kvContainer.size());
  BytesBytesMultiHashMap restoredHashMap=partition.getHashMapFromDisk(rowCount);
  rowCount+=restoredHashMap.getNumValues();
  LOG.info("Hybrid Grace Hash Join: Deserializing spilled hash partition...");
  LOG.info("Hybrid Grace Hash Join: Number of rows in hashmap: " + rowCount);
  if (rowCount * hybridHtContainer.getTableRowSize() >= hybridHtContainer.getMemoryThreshold() / 2) {
    LOG.info("Hybrid Grace Hash Join: Hash table reload can fail since it will be greater than memory limit. Recursive spilling is currently not supported");
  }
  KeyValueHelper writeHelper=hybridHtContainer.getWriteHelper();
  while (kvContainer.hasNext()) {
    ObjectPair<HiveKey,BytesWritable> pair=kvContainer.next();
    Writable key=pair.getFirst();
    Writable val=pair.getSecond();
    writeHelper.setKeyValue(key,val);
    restoredHashMap.put(writeHelper,-1);
  }
  hybridHtContainer.setTotalInMemRowCount(hybridHtContainer.getTotalInMemRowCount() + restoredHashMap.getNumValues() + kvContainer.size());
  kvContainer.clear();
  currentSmallTable=new MapJoinBytesTableContainer(restoredHashMap);
  currentSmallTable.setInternalValueOi(hybridHtContainer.getInternalValueOi());
  currentSmallTable.setSortableSortOrders(hybridHtContainer.getSortableSortOrders());
}
