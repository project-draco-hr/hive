{
  if (oi instanceof ConstantObjectInspector) {
    return (ConstantObjectInspector)oi;
  }
  ObjectInspector writableOI=getStandardObjectInspector(oi,ObjectInspectorCopyOption.WRITABLE);
  Object writableValue=value == null ? value : ObjectInspectorConverters.getConverter(oi,writableOI).convert(value);
switch (writableOI.getCategory()) {
case PRIMITIVE:
    PrimitiveObjectInspector poi=(PrimitiveObjectInspector)oi;
  return PrimitiveObjectInspectorFactory.getPrimitiveWritableConstantObjectInspector(poi.getTypeInfo(),writableValue);
case LIST:
ListObjectInspector loi=(ListObjectInspector)oi;
return ObjectInspectorFactory.getStandardConstantListObjectInspector(getStandardObjectInspector(loi.getListElementObjectInspector(),ObjectInspectorCopyOption.WRITABLE),(List<?>)writableValue);
case MAP:
MapObjectInspector moi=(MapObjectInspector)oi;
return ObjectInspectorFactory.getStandardConstantMapObjectInspector(getStandardObjectInspector(moi.getMapKeyObjectInspector(),ObjectInspectorCopyOption.WRITABLE),getStandardObjectInspector(moi.getMapValueObjectInspector(),ObjectInspectorCopyOption.WRITABLE),(Map<?,?>)writableValue);
case STRUCT:
StructObjectInspector soi=(StructObjectInspector)oi;
List<? extends StructField> fields=soi.getAllStructFieldRefs();
List<String> fieldNames=new ArrayList<String>(fields.size());
List<ObjectInspector> fieldObjectInspectors=new ArrayList<ObjectInspector>(fields.size());
for (StructField f : fields) {
fieldNames.add(f.getFieldName());
fieldObjectInspectors.add(getStandardObjectInspector(f.getFieldObjectInspector(),ObjectInspectorCopyOption.WRITABLE));
}
if (value != null && (writableValue.getClass().isArray())) {
writableValue=java.util.Arrays.asList((Object[])writableValue);
}
return ObjectInspectorFactory.getStandardConstantStructObjectInspector(fieldNames,fieldObjectInspectors,(List<?>)writableValue);
default :
throw new IllegalArgumentException(writableOI.getCategory() + " not yet supported for constant OI");
}
}
