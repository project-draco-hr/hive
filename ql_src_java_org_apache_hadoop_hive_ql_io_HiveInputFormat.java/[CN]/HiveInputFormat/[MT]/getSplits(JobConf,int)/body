{
  PerfLogger perfLogger=PerfLogger.getPerfLogger();
  perfLogger.PerfLogBegin(CLASS_NAME,PerfLogger.GET_SPLITS);
  init(job);
  Path[] dirs=getInputPaths(job);
  JobConf newjob=new JobConf(job);
  List<InputSplit> result=new ArrayList<InputSplit>();
  List<Path> currentDirs=new ArrayList<Path>();
  Class<? extends InputFormat> currentInputFormatClass=null;
  TableDesc currentTable=null;
  TableScanOperator currentTableScan=null;
  boolean pushDownProjection=false;
  StringBuilder readColumnsBuffer=new StringBuilder(newjob.get(ColumnProjectionUtils.READ_COLUMN_IDS_CONF_STR,""));
  ;
  StringBuilder readColumnNamesBuffer=new StringBuilder(newjob.get(ColumnProjectionUtils.READ_COLUMN_NAMES_CONF_STR,""));
  for (  Path dir : dirs) {
    PartitionDesc part=getPartitionDescFromPath(pathToPartitionInfo,dir);
    Class<? extends InputFormat> inputFormatClass=part.getInputFileFormatClass();
    TableDesc table=part.getTableDesc();
    TableScanOperator tableScan=null;
    List<String> aliases=mrwork.getPathToAliases().get(dir.toUri().toString());
    if ((aliases != null) && (aliases.size() == 1)) {
      Operator op=mrwork.getAliasToWork().get(aliases.get(0));
      if ((op != null) && (op instanceof TableScanOperator)) {
        tableScan=(TableScanOperator)op;
        readColumnsBuffer.setLength(0);
        readColumnNamesBuffer.setLength(0);
        ColumnProjectionUtils.appendReadColumns(readColumnsBuffer,readColumnNamesBuffer,tableScan.getNeededColumnIDs(),tableScan.getNeededColumns());
        pushDownProjection=true;
        pushFilters(newjob,tableScan);
      }
    }
    if (!currentDirs.isEmpty() && inputFormatClass.equals(currentInputFormatClass) && table.equals(currentTable)&& tableScan == currentTableScan) {
      currentDirs.add(dir);
      continue;
    }
    if (!currentDirs.isEmpty()) {
      LOG.info("Generating splits");
      addSplitsForGroup(currentDirs,currentTableScan,newjob,getInputFormatFromCache(currentInputFormatClass,job),currentInputFormatClass,currentDirs.size() * (numSplits / dirs.length),currentTable,result);
    }
    currentDirs.clear();
    currentDirs.add(dir);
    currentTableScan=tableScan;
    currentTable=table;
    currentInputFormatClass=inputFormatClass;
  }
  if (pushDownProjection) {
    newjob.setBoolean(ColumnProjectionUtils.READ_ALL_COLUMNS,false);
    newjob.set(ColumnProjectionUtils.READ_COLUMN_IDS_CONF_STR,readColumnsBuffer.toString());
    newjob.set(ColumnProjectionUtils.READ_COLUMN_NAMES_CONF_STR,readColumnNamesBuffer.toString());
    LOG.info(ColumnProjectionUtils.READ_COLUMN_IDS_CONF_STR + "=" + readColumnsBuffer.toString());
    LOG.info(ColumnProjectionUtils.READ_COLUMN_NAMES_CONF_STR + "=" + readColumnNamesBuffer.toString());
  }
  if (dirs.length != 0) {
    LOG.info("Generating splits");
    addSplitsForGroup(currentDirs,currentTableScan,newjob,getInputFormatFromCache(currentInputFormatClass,job),currentInputFormatClass,currentDirs.size() * (numSplits / dirs.length),currentTable,result);
  }
  Utilities.clearWorkMapForConf(job);
  LOG.info("number of splits " + result.size());
  perfLogger.PerfLogEnd(CLASS_NAME,PerfLogger.GET_SPLITS);
  return result.toArray(new HiveInputSplit[result.size()]);
}
