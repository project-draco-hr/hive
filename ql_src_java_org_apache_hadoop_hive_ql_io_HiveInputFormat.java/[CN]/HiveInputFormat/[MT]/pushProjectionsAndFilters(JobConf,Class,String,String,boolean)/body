{
  if (this.mrwork == null) {
    init(job);
  }
  if (this.mrwork.getPathToAliases() == null) {
    return;
  }
  ArrayList<String> aliases=new ArrayList<String>();
  Iterator<Entry<String,ArrayList<String>>> iterator=this.mrwork.getPathToAliases().entrySet().iterator();
  while (iterator.hasNext()) {
    Entry<String,ArrayList<String>> entry=iterator.next();
    String key=entry.getKey();
    boolean match;
    if (nonNative) {
      match=splitPath.equals(key) || splitPathWithNoSchema.equals(key);
    }
 else {
      match=splitPath.startsWith(key) || splitPathWithNoSchema.startsWith(key);
    }
    if (match) {
      ArrayList<String> list=entry.getValue();
      for (      String val : list) {
        aliases.add(val);
      }
    }
  }
  for (  String alias : aliases) {
    Operator<? extends OperatorDesc> op=this.mrwork.getAliasToWork().get(alias);
    if (op instanceof TableScanOperator) {
      TableScanOperator ts=(TableScanOperator)op;
      ColumnProjectionUtils.appendReadColumns(jobConf,ts.getNeededColumnIDs(),ts.getNeededColumns());
      pushFilters(jobConf,ts);
    }
  }
}
