{
  MapredWork mapredWork=(MapredWork)currTask.getWork();
  MapredLocalWork localwork=mapredWork.getMapWork().getMapRedLocalWork();
  if (localwork != null) {
    Context ctx=physicalContext.getContext();
    Path tmpPath=Utilities.generateTmpPath(ctx.getLocalTmpPath(),currTask.getId());
    localwork.setTmpPath(tmpPath);
    mapredWork.getMapWork().setTmpHDFSPath(Utilities.generateTmpPath(ctx.getMRTmpPath(),currTask.getId()));
    MapredLocalTask localTask=(MapredLocalTask)TaskFactory.get(localwork,physicalContext.getParseContext().getConf());
    localTask.setBackupTask(currTask.getBackupTask());
    localTask.setBackupChildrenTasks(currTask.getBackupChildrenTasks());
    currTask.setBackupChildrenTasks(null);
    currTask.setBackupTask(null);
    if (currTask.getTaskTag() == Task.CONVERTED_MAPJOIN) {
      localTask.setTaskTag(Task.CONVERTED_MAPJOIN_LOCAL);
    }
 else {
      localTask.setTaskTag(Task.HINTED_MAPJOIN_LOCAL);
      currTask.setTaskTag(Task.HINTED_MAPJOIN);
    }
    LocalMapJoinProcCtx localMapJoinProcCtx=adjustLocalTask(localTask);
    List<Operator<? extends OperatorDesc>> dummyOps=localMapJoinProcCtx.getDummyParentOp();
    MapredLocalWork newLocalWork=localwork.extractDirectWorks(localMapJoinProcCtx.getDirectWorks());
    newLocalWork.setDummyParentOp(dummyOps);
    mapredWork.getMapWork().setMapRedLocalWork(newLocalWork);
    if (localwork.getAliasToFetchWork().isEmpty()) {
      newLocalWork.setHasStagedAlias(false);
      currTask.setBackupTask(localTask.getBackupTask());
      currTask.setBackupChildrenTasks(localTask.getBackupChildrenTasks());
      return;
    }
    newLocalWork.setHasStagedAlias(true);
    List<Task<? extends Serializable>> parentTasks=currTask.getParentTasks();
    currTask.setParentTasks(null);
    if (parentTasks != null) {
      for (      Task<? extends Serializable> tsk : parentTasks) {
        tsk.addDependentTask(localTask);
        tsk.removeDependentTask(currTask);
      }
    }
 else {
      if (conditionalTask == null) {
        physicalContext.addToRootTask(localTask);
        physicalContext.removeFromRootTask(currTask);
      }
 else {
        List<Task<? extends Serializable>> listTask=conditionalTask.getListTasks();
        ConditionalWork conditionalWork=conditionalTask.getWork();
        int index=listTask.indexOf(currTask);
        listTask.set(index,localTask);
        List<Serializable> listWork=(List<Serializable>)conditionalWork.getListWorks();
        index=listWork.indexOf(mapredWork);
        listWork.set(index,localwork);
        conditionalWork.setListWorks(listWork);
        ConditionalResolver resolver=conditionalTask.getResolver();
        if (resolver instanceof ConditionalResolverSkewJoin) {
          ConditionalResolverSkewJoinCtx context=(ConditionalResolverSkewJoinCtx)conditionalTask.getResolverCtx();
          HashMap<Path,Task<? extends Serializable>> bigKeysDirToTaskMap=context.getDirToTaskMap();
          HashMap<Path,Task<? extends Serializable>> newbigKeysDirToTaskMap=new HashMap<Path,Task<? extends Serializable>>();
          for (          Map.Entry<Path,Task<? extends Serializable>> entry : bigKeysDirToTaskMap.entrySet()) {
            Task<? extends Serializable> task=entry.getValue();
            Path key=entry.getKey();
            if (task.equals(currTask)) {
              newbigKeysDirToTaskMap.put(key,localTask);
            }
 else {
              newbigKeysDirToTaskMap.put(key,task);
            }
          }
          context.setDirToTaskMap(newbigKeysDirToTaskMap);
          conditionalTask.setResolverCtx(context);
        }
 else         if (resolver instanceof ConditionalResolverCommonJoin) {
          ConditionalResolverCommonJoinCtx context=(ConditionalResolverCommonJoinCtx)conditionalTask.getResolverCtx();
          HashMap<Task<? extends Serializable>,Set<String>> taskToAliases=context.getTaskToAliases();
          HashMap<Task<? extends Serializable>,Set<String>> newTaskToAliases=new LinkedHashMap<Task<? extends Serializable>,Set<String>>();
          for (          Map.Entry<Task<? extends Serializable>,Set<String>> entry : taskToAliases.entrySet()) {
            Task<? extends Serializable> task=entry.getKey();
            Set<String> key=new HashSet<String>(entry.getValue());
            if (task.equals(currTask)) {
              newTaskToAliases.put(localTask,key);
            }
 else {
              newTaskToAliases.put(task,key);
            }
          }
          context.setTaskToAliases(newTaskToAliases);
          conditionalTask.setResolverCtx(context);
        }
      }
    }
    localTask.addDependentTask(currTask);
  }
}
