{
  if (columnsToIncludeTruncated != null) {
    deserializeRead.setColumnsToInclude(columnsToIncludeTruncated);
  }
  int targetColumnCount;
  if (columnsToIncludeTruncated == null) {
    targetColumnCount=targetTypeInfos.length;
  }
 else {
    targetColumnCount=Math.min(targetTypeInfos.length,columnsToIncludeTruncated.length);
  }
  int sourceColumnCount=Math.min(sourceTypeInfos.length,targetColumnCount);
  allocateArrays(sourceColumnCount);
  allocateConvertArrays(sourceColumnCount);
  boolean atLeastOneConvert=false;
  for (int i=0; i < sourceColumnCount; i++) {
    if (columnsToIncludeTruncated != null && !columnsToIncludeTruncated[i]) {
    }
 else {
      TypeInfo sourceTypeInfo=sourceTypeInfos[i];
      TypeInfo targetTypeInfo=targetTypeInfos[i];
      if (!sourceTypeInfo.equals(targetTypeInfo)) {
        if (VectorPartitionConversion.isImplicitVectorColumnConversion(sourceTypeInfo,targetTypeInfo)) {
          initSourceEntry(i,i,sourceTypeInfo);
        }
 else {
          initSourceEntry(i,i,sourceTypeInfo);
          initConvertTargetEntry(i);
          atLeastOneConvert=true;
        }
      }
 else {
        initSourceEntry(i,i,sourceTypeInfo);
      }
    }
  }
  if (atLeastOneConvert) {
    convertVectorAssignRow=new VectorAssignRow();
    convertVectorAssignRow.initConversion(sourceTypeInfos,targetTypeInfos,columnsToIncludeTruncated);
  }
  return sourceColumnCount;
}
