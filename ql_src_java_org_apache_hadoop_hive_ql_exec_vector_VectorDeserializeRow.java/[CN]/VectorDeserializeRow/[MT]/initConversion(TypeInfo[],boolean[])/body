{
  Preconditions.checkState(targetTypeInfos.length >= sourceTypeInfos.length);
  Preconditions.checkState(columnsToIncludeTruncated == null || columnsToIncludeTruncated.length >= sourceTypeInfos.length);
  final int columnCount=sourceTypeInfos.length;
  allocateArrays(columnCount);
  allocateConvertArrays(columnCount);
  int includedCount=0;
  int[] includedIndices=new int[columnCount];
  boolean atLeastOneConvert=false;
  for (int i=0; i < columnCount; i++) {
    if (columnsToIncludeTruncated != null && !columnsToIncludeTruncated[i]) {
    }
 else {
      TypeInfo sourceTypeInfo=sourceTypeInfos[i];
      TypeInfo targetTypeInfo=targetTypeInfos[i];
      if (!sourceTypeInfo.equals(targetTypeInfo)) {
        if (VectorPartitionConversion.isImplicitVectorColumnConversion(sourceTypeInfo,targetTypeInfo)) {
          initSourceEntry(i,i,sourceTypeInfo);
        }
 else {
          initSourceEntry(i,i,sourceTypeInfo);
          initConvertTargetEntry(i);
          atLeastOneConvert=true;
        }
      }
 else {
        initSourceEntry(i,i,sourceTypeInfo);
      }
      includedIndices[includedCount++]=i;
    }
  }
  if (includedCount < columnCount && deserializeRead.isReadFieldSupported()) {
    useReadField=true;
    readFieldLogicalIndices=Arrays.copyOf(includedIndices,includedCount);
  }
  if (atLeastOneConvert) {
    convertVectorAssignRow=new VectorAssignRow();
    convertVectorAssignRow.initConversion(sourceTypeInfos,targetTypeInfos,columnsToIncludeTruncated);
  }
}
