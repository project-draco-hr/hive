{
  final int projectionColumnNum=projectionColumnNums[logicalColumnIndex];
  if (deserializeRead.readCheckNull()) {
    VectorizedBatchUtil.setNullColIsNullValue(batch.cols[projectionColumnNum],batchIndex);
    return;
  }
  Category sourceCategory=sourceCategories[logicalColumnIndex];
  if (sourceCategory == null) {
    return;
  }
switch (sourceCategory) {
case PRIMITIVE:
{
      PrimitiveCategory sourcePrimitiveCategory=sourcePrimitiveCategories[logicalColumnIndex];
switch (sourcePrimitiveCategory) {
case VOID:
        VectorizedBatchUtil.setNullColIsNullValue(batch.cols[projectionColumnNum],batchIndex);
      return;
case BOOLEAN:
    ((LongColumnVector)batch.cols[projectionColumnNum]).vector[batchIndex]=(deserializeRead.currentBoolean ? 1 : 0);
  break;
case BYTE:
((LongColumnVector)batch.cols[projectionColumnNum]).vector[batchIndex]=deserializeRead.currentByte;
break;
case SHORT:
((LongColumnVector)batch.cols[projectionColumnNum]).vector[batchIndex]=deserializeRead.currentShort;
break;
case INT:
((LongColumnVector)batch.cols[projectionColumnNum]).vector[batchIndex]=deserializeRead.currentInt;
break;
case LONG:
((LongColumnVector)batch.cols[projectionColumnNum]).vector[batchIndex]=deserializeRead.currentLong;
break;
case TIMESTAMP:
((TimestampColumnVector)batch.cols[projectionColumnNum]).set(batchIndex,deserializeRead.currentTimestampWritable.getTimestamp());
break;
case DATE:
((LongColumnVector)batch.cols[projectionColumnNum]).vector[batchIndex]=deserializeRead.currentDateWritable.getDays();
break;
case FLOAT:
((DoubleColumnVector)batch.cols[projectionColumnNum]).vector[batchIndex]=deserializeRead.currentFloat;
break;
case DOUBLE:
((DoubleColumnVector)batch.cols[projectionColumnNum]).vector[batchIndex]=deserializeRead.currentDouble;
break;
case BINARY:
case STRING:
((BytesColumnVector)batch.cols[projectionColumnNum]).setVal(batchIndex,deserializeRead.currentBytes,deserializeRead.currentBytesStart,deserializeRead.currentBytesLength);
break;
case VARCHAR:
{
int adjustedLength=StringExpr.truncate(deserializeRead.currentBytes,deserializeRead.currentBytesStart,deserializeRead.currentBytesLength,maxLengths[logicalColumnIndex]);
((BytesColumnVector)batch.cols[projectionColumnNum]).setVal(batchIndex,deserializeRead.currentBytes,deserializeRead.currentBytesStart,adjustedLength);
}
break;
case CHAR:
{
int adjustedLength=StringExpr.rightTrimAndTruncate(deserializeRead.currentBytes,deserializeRead.currentBytesStart,deserializeRead.currentBytesLength,maxLengths[logicalColumnIndex]);
((BytesColumnVector)batch.cols[projectionColumnNum]).setVal(batchIndex,deserializeRead.currentBytes,deserializeRead.currentBytesStart,adjustedLength);
}
break;
case DECIMAL:
((DecimalColumnVector)batch.cols[projectionColumnNum]).set(batchIndex,deserializeRead.currentHiveDecimalWritable.getHiveDecimal());
break;
case INTERVAL_YEAR_MONTH:
((LongColumnVector)batch.cols[projectionColumnNum]).vector[batchIndex]=deserializeRead.currentHiveIntervalYearMonthWritable.getHiveIntervalYearMonth().getTotalMonths();
break;
case INTERVAL_DAY_TIME:
((IntervalDayTimeColumnVector)batch.cols[projectionColumnNum]).set(batchIndex,deserializeRead.currentHiveIntervalDayTimeWritable.getHiveIntervalDayTime());
break;
default :
throw new RuntimeException("Primitive category " + sourcePrimitiveCategory.name() + " not supported");
}
}
break;
default :
throw new RuntimeException("Category " + sourceCategory.name() + " not supported");
}
batch.cols[projectionColumnNum].isNull[batchIndex]=false;
}
