{
  final StructObjectInspector outputRowOI=(StructObjectInspector)objInspector;
  final List<? extends StructField> outputFieldRefs=outputRowOI.getAllStructFieldRefs();
  if (outputFieldRefs.size() != numCols) {
    throw new SerDeException("Cannot serialize the object because there are " + outputFieldRefs.size() + " fields but the table has "+ numCols+ " columns.");
  }
  for (int c=0; c < numCols; c++) {
    final Object field=outputRowOI.getStructFieldData(obj,outputFieldRefs.get(c));
    final ObjectInspector fieldOI=outputFieldRefs.get(c).getFieldObjectInspector();
    final StringObjectInspector fieldStringOI=(StringObjectInspector)fieldOI;
    outputFields[c]=fieldStringOI.getPrimitiveJavaObject(field);
  }
  final StringWriter writer=new StringWriter();
  final CSVWriter csv=newWriter(writer,separatorChar,quoteChar,escapeChar);
  try {
    csv.writeNext(outputFields);
    csv.close();
    return new Text(writer.toString());
  }
 catch (  final IOException ioe) {
    throw new SerDeException(ioe);
  }
}
