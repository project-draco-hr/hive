{
  Path fpath=new Path((new Path(HiveConf.getVar(hconf,HiveConf.ConfVars.HADOOPMAPFILENAME))).toUri().getPath());
  ArrayList<Operator<? extends Serializable>> todo=new ArrayList<Operator<? extends Serializable>>();
  Map<MapInputPath,MapOpCtx> opCtx=new HashMap<MapInputPath,MapOpCtx>();
  statsMap.put(Counter.DESERIALIZE_ERRORS,deserialize_error_count);
  try {
    for (    String onefile : conf.getPathToAliases().keySet()) {
      MapOpCtx ctx=initObjectInspector(hconf,onefile);
      List<String> aliases=conf.getPathToAliases().get(onefile);
      for (      String onealias : aliases) {
        Operator<? extends Serializable> op=conf.getAliasToWork().get(onealias);
        opCtx.put(new MapInputPath(onefile,onealias,op),ctx);
      }
    }
    boolean done=false;
    for (    String onefile : conf.getPathToAliases().keySet()) {
      Path onepath=new Path(new Path(onefile).toUri().getPath());
      if (!onepath.toUri().relativize(fpath.toUri()).equals(fpath.toUri())) {
        List<String> aliases=conf.getPathToAliases().get(onefile);
        for (        String onealias : aliases) {
          LOG.info("Adding alias " + onealias + " to work list for file "+ fpath.toUri().getPath());
          Operator<? extends Serializable> op=conf.getAliasToWork().get(onealias);
          List<Operator<? extends Serializable>> parents=new ArrayList<Operator<? extends Serializable>>();
          parents.add(this);
          op.setParentOperators(parents);
          todo.add(op);
          MapInputPath inp=new MapInputPath(onefile,onealias,op);
          LOG.info("dump " + opCtx.get(inp).getRowObjectInspector().getTypeName());
          op.initialize(hconf,reporter,new ObjectInspector[]{opCtx.get(inp).getRowObjectInspector()});
          if (!done) {
            deserializer=opCtx.get(inp).getDeserializer();
            isPartitioned=opCtx.get(inp).isPartitioned();
            rowWithPart=opCtx.get(inp).getRowWithPart();
            rowObjectInspector=opCtx.get(inp).getRowObjectInspector();
            done=true;
          }
        }
      }
    }
    for (    MapInputPath input : opCtx.keySet()) {
      Operator<? extends Serializable> op=input.op;
      op.initialize(hconf,reporter,new ObjectInspector[]{opCtx.get(input).getRowObjectInspector()});
    }
    if (todo.size() == 0) {
      LOG.error("Configuration does not have any alias for path: " + fpath.toUri().getPath());
      throw new HiveException("Configuration and input path are inconsistent");
    }
    this.setChildOperators(todo);
    this.setMapredWork(conf);
    this.setOutputCollector(out);
  }
 catch (  SerDeException e) {
    e.printStackTrace();
    throw new HiveException(e);
  }
catch (  InstantiationException e) {
    throw new HiveException(e);
  }
catch (  IllegalAccessException e) {
    throw new HiveException(e);
  }
catch (  ClassNotFoundException e) {
    throw new HiveException(e);
  }
}
