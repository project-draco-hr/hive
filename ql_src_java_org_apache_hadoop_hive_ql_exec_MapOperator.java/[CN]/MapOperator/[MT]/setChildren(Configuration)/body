{
  Path fpath=new Path((new Path(HiveConf.getVar(hconf,HiveConf.ConfVars.HADOOPMAPFILENAME))).toUri().getPath());
  ArrayList<Operator<? extends Serializable>> children=new ArrayList<Operator<? extends Serializable>>();
  opCtxMap=new HashMap<MapInputPath,MapOpCtx>();
  operatorToPaths=new HashMap<Operator<? extends Serializable>,java.util.ArrayList<String>>();
  statsMap.put(Counter.DESERIALIZE_ERRORS,deserialize_error_count);
  try {
    boolean done=false;
    for (    String onefile : conf.getPathToAliases().keySet()) {
      MapOpCtx opCtx=initObjectInspector(conf,hconf,onefile);
      Path onepath=new Path(new Path(onefile).toUri().getPath());
      List<String> aliases=conf.getPathToAliases().get(onefile);
      for (      String onealias : aliases) {
        Operator<? extends Serializable> op=conf.getAliasToWork().get(onealias);
        LOG.info("Adding alias " + onealias + " to work list for file "+ fpath.toUri().getPath());
        MapInputPath inp=new MapInputPath(onefile,onealias,op);
        opCtxMap.put(inp,opCtx);
        if (operatorToPaths.get(op) == null) {
          operatorToPaths.put(op,new java.util.ArrayList<String>());
        }
        operatorToPaths.get(op).add(onefile);
        op.setParentOperators(new ArrayList<Operator<? extends Serializable>>());
        op.getParentOperators().add(this);
        if (!onepath.toUri().relativize(fpath.toUri()).equals(fpath.toUri())) {
          children.add(op);
          childrenPaths.add(onefile);
          LOG.info("dump " + op.getName() + " "+ opCtxMap.get(inp).getRowObjectInspector().getTypeName());
          if (!done) {
            deserializer=opCtxMap.get(inp).getDeserializer();
            isPartitioned=opCtxMap.get(inp).isPartitioned();
            rowWithPart=opCtxMap.get(inp).getRowWithPart();
            rowObjectInspector=opCtxMap.get(inp).getRowObjectInspector();
            StructObjectInspector rawRowObjectInspector=opCtxMap.get(inp).rawRowObjectInspector;
            StructObjectInspector partObjectInspector=opCtxMap.get(inp).partObjectInspector;
            if (op instanceof TableScanOperator) {
              TableScanOperator tsOp=(TableScanOperator)op;
              TableScanDesc tsDesc=tsOp.getConf();
              if (tsDesc != null) {
                this.vcs=tsDesc.getVirtualCols();
                if (vcs != null && vcs.size() > 0) {
                  this.hasVC=true;
                  List<String> vcNames=new ArrayList<String>(vcs.size());
                  this.vcValues=new Writable[vcs.size()];
                  List<ObjectInspector> vcsObjectInspectors=new ArrayList<ObjectInspector>(vcs.size());
                  for (int i=0; i < vcs.size(); i++) {
                    VirtualColumn vc=vcs.get(i);
                    vcsObjectInspectors.add(PrimitiveObjectInspectorFactory.getPrimitiveWritableObjectInspector(((PrimitiveTypeInfo)vc.getTypeInfo()).getPrimitiveCategory()));
                    vcNames.add(vc.getName());
                  }
                  StructObjectInspector vcStructObjectInspector=ObjectInspectorFactory.getStandardStructObjectInspector(vcNames,vcsObjectInspectors);
                  if (isPartitioned) {
                    this.rowWithPartAndVC=new Object[3];
                    this.rowWithPartAndVC[1]=this.rowWithPart[1];
                  }
 else {
                    this.rowWithPartAndVC=new Object[2];
                  }
                  if (partObjectInspector == null) {
                    this.rowObjectInspector=ObjectInspectorFactory.getUnionStructObjectInspector(Arrays.asList(new StructObjectInspector[]{rowObjectInspector,vcStructObjectInspector}));
                  }
 else {
                    this.rowObjectInspector=ObjectInspectorFactory.getUnionStructObjectInspector(Arrays.asList(new StructObjectInspector[]{rawRowObjectInspector,partObjectInspector,vcStructObjectInspector}));
                  }
                  opCtxMap.get(inp).rowObjectInspector=this.rowObjectInspector;
                }
              }
            }
            done=true;
          }
        }
      }
    }
    if (children.size() == 0) {
      LOG.error("Configuration does not have any alias for path: " + fpath.toUri().getPath());
      throw new HiveException("Configuration and input path are inconsistent");
    }
    setChildOperators(children);
  }
 catch (  Exception e) {
    throw new HiveException(e);
  }
}
