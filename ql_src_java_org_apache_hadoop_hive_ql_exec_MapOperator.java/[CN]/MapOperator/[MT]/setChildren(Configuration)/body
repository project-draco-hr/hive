{
  List<Operator<? extends OperatorDesc>> children=new ArrayList<Operator<? extends OperatorDesc>>();
  Map<TableDesc,StructObjectInspector> convertedOI=getConvertedOI(hconf);
  for (  Map.Entry<Path,ArrayList<String>> entry : conf.getPathToAliases().entrySet()) {
    Path onefile=entry.getKey();
    List<String> aliases=entry.getValue();
    PartitionDesc partDesc=conf.getPathToPartitionInfo().get(onefile);
    for (    String alias : aliases) {
      Operator<? extends OperatorDesc> op=conf.getAliasToWork().get(alias);
      if (isLogDebugEnabled) {
        LOG.debug("Adding alias " + alias + " to work list for file "+ onefile);
      }
      Map<Operator<?>,MapOpCtx> contexts=opCtxMap.get(onefile.toString());
      if (contexts == null) {
        opCtxMap.put(onefile.toString(),contexts=new LinkedHashMap<Operator<?>,MapOpCtx>());
      }
      if (contexts.containsKey(op)) {
        continue;
      }
      MapOpCtx context=new MapOpCtx(alias,op,partDesc);
      StructObjectInspector tableRowOI=convertedOI.get(partDesc.getTableDesc());
      contexts.put(op,initObjectInspector(hconf,context,tableRowOI));
      if (children.contains(op) == false) {
        op.setParentOperators(new ArrayList<Operator<? extends OperatorDesc>>(1));
        op.getParentOperators().add(this);
        children.add(op);
      }
    }
  }
  initOperatorContext(children);
  setChildOperators(children);
}
