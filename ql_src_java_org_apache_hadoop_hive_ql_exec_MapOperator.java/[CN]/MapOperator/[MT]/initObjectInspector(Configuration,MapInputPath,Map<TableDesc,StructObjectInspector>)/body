{
  PartitionDesc pd=ctx.partDesc;
  TableDesc td=pd.getTableDesc();
  MapOpCtx opCtx=new MapOpCtx();
  Properties overlayedProps=SerDeUtils.createOverlayedProperties(td.getProperties(),pd.getProperties());
  Map<String,String> partSpec=pd.getPartSpec();
  opCtx.tableName=String.valueOf(overlayedProps.getProperty("name"));
  opCtx.partName=String.valueOf(partSpec);
  Class serdeclass=hconf.getClassByName(pd.getSerdeClassName());
  opCtx.deserializer=(Deserializer)serdeclass.newInstance();
  SerDeUtils.initializeSerDe(opCtx.deserializer,hconf,td.getProperties(),pd.getProperties());
  StructObjectInspector partRawRowObjectInspector=(StructObjectInspector)opCtx.deserializer.getObjectInspector();
  opCtx.tblRawRowObjectInspector=convertedOI.get(td);
  opCtx.partTblObjectInspectorConverter=ObjectInspectorConverters.getConverter(partRawRowObjectInspector,opCtx.tblRawRowObjectInspector);
  String pcols=overlayedProps.getProperty(hive_metastoreConstants.META_TABLE_PARTITION_COLUMNS);
  if (pcols != null && pcols.length() > 0) {
    String[] partKeys=pcols.trim().split("/");
    String pcolTypes=overlayedProps.getProperty(hive_metastoreConstants.META_TABLE_PARTITION_COLUMN_TYPES);
    String[] partKeyTypes=pcolTypes.trim().split(":");
    if (partKeys.length > partKeyTypes.length) {
      throw new HiveException("Internal error : partKeys length, " + partKeys.length + " greater than partKeyTypes length, "+ partKeyTypes.length);
    }
    List<String> partNames=new ArrayList<String>(partKeys.length);
    Object[] partValues=new Object[partKeys.length];
    List<ObjectInspector> partObjectInspectors=new ArrayList<ObjectInspector>(partKeys.length);
    for (int i=0; i < partKeys.length; i++) {
      String key=partKeys[i];
      partNames.add(key);
      ObjectInspector oi=PrimitiveObjectInspectorFactory.getPrimitiveWritableObjectInspector(TypeInfoFactory.getPrimitiveTypeInfo(partKeyTypes[i]));
      if (partSpec == null) {
        partValues[i]=null;
      }
 else {
        partValues[i]=ObjectInspectorConverters.getConverter(PrimitiveObjectInspectorFactory.javaStringObjectInspector,oi).convert(partSpec.get(key));
      }
      partObjectInspectors.add(oi);
    }
    opCtx.rowWithPart=new Object[]{null,partValues};
    opCtx.partObjectInspector=ObjectInspectorFactory.getStandardStructObjectInspector(partNames,partObjectInspectors);
  }
  if (ctx.op instanceof TableScanOperator) {
    TableScanOperator tsOp=(TableScanOperator)ctx.op;
    TableScanDesc tsDesc=tsOp.getConf();
    if (tsDesc != null && tsDesc.hasVirtualCols()) {
      opCtx.vcs=tsDesc.getVirtualCols();
      opCtx.vcValues=new Object[opCtx.vcs.size()];
      opCtx.vcsObjectInspector=VirtualColumn.getVCSObjectInspector(opCtx.vcs);
      if (opCtx.isPartitioned()) {
        opCtx.rowWithPartAndVC=Arrays.copyOfRange(opCtx.rowWithPart,0,3);
      }
 else {
        opCtx.rowWithPartAndVC=new Object[2];
      }
    }
  }
  if (!opCtx.hasVC() && !opCtx.isPartitioned()) {
    opCtx.rowObjectInspector=opCtx.tblRawRowObjectInspector;
    return opCtx;
  }
  List<StructObjectInspector> inspectors=new ArrayList<StructObjectInspector>();
  inspectors.add(opCtx.tblRawRowObjectInspector);
  if (opCtx.isPartitioned()) {
    inspectors.add(opCtx.partObjectInspector);
  }
  if (opCtx.hasVC()) {
    inspectors.add(opCtx.vcsObjectInspector);
  }
  opCtx.rowObjectInspector=ObjectInspectorFactory.getUnionStructObjectInspector(inspectors);
  return opCtx;
}
