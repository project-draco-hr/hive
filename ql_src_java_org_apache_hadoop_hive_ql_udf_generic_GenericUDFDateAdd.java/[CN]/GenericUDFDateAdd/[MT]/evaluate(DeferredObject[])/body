{
  if (arguments[0].get() == null) {
    return null;
  }
  Object daysWritableObject=daysConverter.convert(arguments[1].get());
  if (daysWritableObject == null) {
    return null;
  }
  int toBeAdded;
  if (daysWritableObject instanceof ByteWritable) {
    toBeAdded=((ByteWritable)daysWritableObject).get();
  }
 else   if (daysWritableObject instanceof ShortWritable) {
    toBeAdded=((ShortWritable)daysWritableObject).get();
  }
 else   if (daysWritableObject instanceof IntWritable) {
    toBeAdded=((IntWritable)daysWritableObject).get();
  }
 else {
    return null;
  }
switch (inputType1) {
case STRING:
    String dateString=dateConverter.convert(arguments[0].get()).toString();
  if (dateParser.parseDate(dateString,dateVal)) {
    output.set(dateVal);
  }
 else {
    return null;
  }
break;
case TIMESTAMP:
Timestamp ts=((TimestampWritable)dateConverter.convert(arguments[0].get())).getTimestamp();
output.set(DateWritable.millisToDays(ts.getTime()));
break;
case DATE:
DateWritable dw=(DateWritable)dateConverter.convert(arguments[0].get());
output.set(dw.getDays());
break;
default :
throw new UDFArgumentException("DATE_ADD() only takes STRING/TIMESTAMP/DATEWRITABLE types, got " + inputType1);
}
int newDays=output.getDays() + (signModifier * toBeAdded);
output.set(newDays);
return output;
}
