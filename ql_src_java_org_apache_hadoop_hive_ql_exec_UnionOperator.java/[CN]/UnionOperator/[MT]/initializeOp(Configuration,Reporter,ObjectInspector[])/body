{
  int parents=inputObjInspector.length;
  parentObjInspectors=new StructObjectInspector[parents];
  parentFields=new List[parents];
  for (int p=0; p < parents; p++) {
    parentObjInspectors[p]=(StructObjectInspector)inputObjInspector[p];
    parentFields[p]=parentObjInspectors[p].getAllStructFieldRefs();
  }
  int columns=parentFields[0].size();
  ArrayList<String> columnNames=new ArrayList<String>(columns);
  for (int c=0; c < columns; c++) {
    columnNames.add(parentFields[0].get(c).getFieldName());
  }
  columnTypeResolvers=new ReturnObjectInspectorResolver[columns];
  for (int c=0; c < columns; c++) {
    columnTypeResolvers[c]=new ReturnObjectInspectorResolver();
  }
  for (int p=0; p < parents; p++) {
    assert(parentFields[p].size() == columns);
    for (int c=0; c < columns; c++) {
      columnTypeResolvers[c].update(parentFields[p].get(c).getFieldObjectInspector());
    }
  }
  ArrayList<ObjectInspector> outputFieldOIs=new ArrayList<ObjectInspector>(columns);
  for (int c=0; c < columns; c++) {
    outputFieldOIs.add(columnTypeResolvers[c].get());
  }
  outputOI=ObjectInspectorFactory.getStandardStructObjectInspector(columnNames,outputFieldOIs);
  outputRow=new ArrayList<Object>(columns);
  for (int c=0; c < columns; c++) {
    outputRow.add(null);
  }
  needsTransform=new boolean[parents];
  for (int p=0; p < parents; p++) {
    needsTransform[p]=(inputObjInspector[p] != outputOI);
    if (needsTransform[p]) {
      LOG.info("Union Operator needs to transform row from parent[" + p + "] from "+ inputObjInspector[p]+ " to "+ outputOI);
    }
  }
  initializeChildren(hconf,reporter,new ObjectInspector[]{outputOI});
}
