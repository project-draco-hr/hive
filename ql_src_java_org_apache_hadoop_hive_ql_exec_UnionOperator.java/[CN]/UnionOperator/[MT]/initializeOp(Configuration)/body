{
  Collection<Future<?>> result=super.initializeOp(hconf);
  int parents=parentOperators.size();
  parentObjInspectors=new StructObjectInspector[parents];
  parentFields=new List[parents];
  for (int p=0; p < parents; p++) {
    parentObjInspectors[p]=(StructObjectInspector)inputObjInspectors[p];
    parentFields[p]=parentObjInspectors[p].getAllStructFieldRefs();
  }
  int columns=parentFields[0].size();
  ArrayList<String> columnNames=new ArrayList<String>(columns);
  for (int c=0; c < columns; c++) {
    columnNames.add(parentFields[0].get(c).getFieldName());
  }
  columnTypeResolvers=new ReturnObjectInspectorResolver[columns];
  for (int c=0; c < columns; c++) {
    columnTypeResolvers[c]=new ReturnObjectInspectorResolver(true);
  }
  for (int p=0; p < parents; p++) {
    assert(parentFields[p].size() == columns);
    for (int c=0; c < columns; c++) {
      if (!columnTypeResolvers[c].updateForUnionAll(parentFields[p].get(c).getFieldObjectInspector())) {
        throw new HiveException("Incompatible types for union operator");
      }
    }
  }
  ArrayList<ObjectInspector> outputFieldOIs=new ArrayList<ObjectInspector>(columns);
  for (int c=0; c < columns; c++) {
    ObjectInspector fieldOI=parentFields[0].get(c).getFieldObjectInspector();
    outputFieldOIs.add(columnTypeResolvers[c].get(fieldOI));
  }
  outputObjInspector=ObjectInspectorFactory.getStandardStructObjectInspector(columnNames,outputFieldOIs);
  outputRow=new ArrayList<Object>(columns);
  for (int c=0; c < columns; c++) {
    outputRow.add(null);
  }
  needsTransform=new boolean[parents];
  for (int p=0; p < parents; p++) {
    needsTransform[p]=(inputObjInspectors[p] != outputObjInspector);
    if (isLogInfoEnabled && needsTransform[p]) {
      LOG.info("Union Operator needs to transform row from parent[" + p + "] from "+ inputObjInspectors[p]+ " to "+ outputObjInspector);
    }
  }
  return result;
}
