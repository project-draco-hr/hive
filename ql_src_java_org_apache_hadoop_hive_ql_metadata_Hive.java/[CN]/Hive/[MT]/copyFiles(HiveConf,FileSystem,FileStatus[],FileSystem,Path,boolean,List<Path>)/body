{
  final HdfsUtils.HadoopFileStatus fullDestStatus;
  try {
    fullDestStatus=new HdfsUtils.HadoopFileStatus(conf,destFs,destf);
  }
 catch (  IOException e1) {
    throw new HiveException(e1);
  }
  if (!fullDestStatus.getFileStatus().isDirectory()) {
    throw new HiveException(destf + " is not a directory.");
  }
  final boolean inheritPerms=HiveConf.getBoolVar(conf,HiveConf.ConfVars.HIVE_WAREHOUSE_SUBDIR_INHERIT_PERMS);
  final List<Future<ObjectPair<Path,Path>>> futures=new LinkedList<>();
  final ExecutorService pool=Executors.newFixedThreadPool(conf.getIntVar(ConfVars.HIVE_MOVE_FILES_THREAD_COUNT),new ThreadFactoryBuilder().setDaemon(true).setNameFormat("MoveDir-Thread-%d").build());
  for (  FileStatus src : srcs) {
    FileStatus[] files;
    if (src.isDirectory()) {
      try {
        files=srcFs.listStatus(src.getPath(),FileUtils.HIDDEN_FILES_PATH_FILTER);
      }
 catch (      IOException e) {
        pool.shutdownNow();
        throw new HiveException(e);
      }
    }
 else {
      files=new FileStatus[]{src};
    }
    final SessionState parentSession=SessionState.get();
    for (    final FileStatus srcFile : files) {
      futures.add(pool.submit(new Callable<ObjectPair<Path,Path>>(){
        @Override public ObjectPair<Path,Path> call() throws Exception {
          SessionState.setCurrentSessionState(parentSession);
          final Path srcP=srcFile.getPath();
          final boolean needToCopy=needToCopy(srcP,destf,srcFs,destFs);
          final String name;
          final String filetype;
          String itemName=srcP.getName();
          int index=itemName.lastIndexOf('.');
          if (index >= 0) {
            filetype=itemName.substring(index);
            name=itemName.substring(0,index);
          }
 else {
            name=itemName;
            filetype="";
          }
          Path destPath=new Path(destf,srcP.getName());
          if (!needToCopy && !isSrcLocal) {
            for (int counter=1; !destFs.rename(srcP,destPath); counter++) {
              destPath=new Path(destf,name + ("_copy_" + counter) + filetype);
            }
          }
 else {
            destPath=mvFile(conf,srcP,destPath,isSrcLocal,srcFs,destFs,name,filetype);
          }
          if (inheritPerms) {
            HdfsUtils.setFullFileStatus(conf,fullDestStatus,destFs,destPath,false);
          }
          if (null != newFiles) {
            newFiles.add(destPath);
          }
          return ObjectPair.create(srcP,destPath);
        }
      }
));
    }
  }
  pool.shutdown();
  for (  Future<ObjectPair<Path,Path>> future : futures) {
    try {
      ObjectPair<Path,Path> pair=future.get();
      LOG.debug("Moved src: {}",pair.getFirst().toString(),", to dest: {}",pair.getSecond().toString());
    }
 catch (    Exception e) {
      LOG.error("Failed to move: {}",e.getMessage());
      pool.shutdownNow();
      throw new HiveException(e.getCause());
    }
  }
}
