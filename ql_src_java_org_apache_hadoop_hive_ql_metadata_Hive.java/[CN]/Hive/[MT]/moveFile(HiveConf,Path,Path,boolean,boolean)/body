{
  final FileSystem srcFs, destFs;
  try {
    destFs=destf.getFileSystem(conf);
  }
 catch (  IOException e) {
    LOG.error("Failed to get dest fs",e);
    throw new HiveException(e.getMessage(),e);
  }
  try {
    srcFs=srcf.getFileSystem(conf);
  }
 catch (  IOException e) {
    LOG.error("Failed to get dest fs",e);
    throw new HiveException(e.getMessage(),e);
  }
  final boolean inheritPerms=HiveConf.getBoolVar(conf,HiveConf.ConfVars.HIVE_WAREHOUSE_SUBDIR_INHERIT_PERMS);
  HdfsUtils.HadoopFileStatus destStatus=null;
  boolean destIsSubDir=isSubDir(srcf,destf,srcFs,destFs,isSrcLocal);
  try {
    if (inheritPerms || replace) {
      try {
        destStatus=new HdfsUtils.HadoopFileStatus(conf,destFs,destf);
        if (replace && !destIsSubDir) {
          destFs.delete(destf,true);
          LOG.debug("The path " + destf.toString() + " is deleted");
        }
      }
 catch (      FileNotFoundException ignore) {
        if (inheritPerms) {
          destStatus=new HdfsUtils.HadoopFileStatus(conf,destFs,destf.getParent());
        }
      }
    }
    final HdfsUtils.HadoopFileStatus desiredStatus=destStatus;
    final SessionState parentSession=SessionState.get();
    if (isSrcLocal) {
      destFs.copyFromLocalFile(srcf,destf);
      if (inheritPerms) {
        try {
          HdfsUtils.setFullFileStatus(conf,destStatus,destFs,destf,true);
        }
 catch (        IOException e) {
          LOG.warn("Error setting permission of file " + destf + ": "+ e.getMessage(),e);
        }
      }
      return true;
    }
 else {
      if (needToCopy(srcf,destf,srcFs,destFs)) {
        LOG.debug("Copying source " + srcf + " to "+ destf+ " because HDFS encryption zones are different.");
        return FileUtils.copy(srcf.getFileSystem(conf),srcf,destf.getFileSystem(conf),destf,true,replace,conf);
      }
 else {
        if (destIsSubDir) {
          FileStatus[] srcs=destFs.listStatus(srcf,FileUtils.HIDDEN_FILES_PATH_FILTER);
          List<Future<Void>> futures=new LinkedList<>();
          final ExecutorService pool=conf.getInt(ConfVars.HIVE_MOVE_FILES_THREAD_COUNT.varname,25) > 0 ? Executors.newFixedThreadPool(conf.getInt(ConfVars.HIVE_MOVE_FILES_THREAD_COUNT.varname,25),new ThreadFactoryBuilder().setDaemon(true).setNameFormat("Move-Thread-%d").build()) : null;
          for (          final FileStatus srcStatus : srcs) {
            if (null == pool) {
              if (!destFs.rename(srcStatus.getPath(),destf)) {
                throw new IOException("rename for src path: " + srcStatus.getPath() + " to dest:"+ destf+ " returned false");
              }
            }
 else {
              futures.add(pool.submit(new Callable<Void>(){
                @Override public Void call() throws Exception {
                  SessionState.setCurrentSessionState(parentSession);
                  final Path destPath=new Path(destf,srcStatus.getPath().getName());
                  final String group=srcStatus.getGroup();
                  if (destFs.rename(srcStatus.getPath(),destf)) {
                    if (inheritPerms) {
                      HdfsUtils.setFullFileStatus(conf,desiredStatus,group,destFs,destPath,false);
                    }
                  }
 else {
                    throw new IOException("rename for src path: " + srcStatus.getPath() + " to dest path:"+ destPath+ " returned false");
                  }
                  return null;
                }
              }
));
            }
          }
          if (null == pool) {
            if (inheritPerms) {
              HdfsUtils.setFullFileStatus(conf,desiredStatus,null,destFs,destf,true);
            }
          }
 else {
            pool.shutdown();
            for (            Future<Void> future : futures) {
              try {
                future.get();
              }
 catch (              Exception e) {
                LOG.debug(e.getMessage());
                pool.shutdownNow();
                throw new HiveException(e.getCause());
              }
            }
          }
          return true;
        }
 else {
          if (destFs.rename(srcf,destf)) {
            if (inheritPerms) {
              HdfsUtils.setFullFileStatus(conf,destStatus,destFs,destf,true);
            }
            return true;
          }
          return false;
        }
      }
    }
  }
 catch (  IOException ioe) {
    throw new HiveException("Unable to move source " + srcf + " to destination "+ destf,ioe);
  }
}
