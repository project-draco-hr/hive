{
  FileStatus[] statuses=fs.listStatus(f,FileUtils.HIDDEN_FILES_PATH_FILTER);
  boolean result=true;
  final List<Future<Boolean>> futures=new LinkedList<>();
  final ExecutorService pool=conf.getInt(ConfVars.HIVE_MOVE_FILES_THREAD_COUNT.varname,25) > 0 ? Executors.newFixedThreadPool(conf.getInt(ConfVars.HIVE_MOVE_FILES_THREAD_COUNT.varname,25),new ThreadFactoryBuilder().setDaemon(true).setNameFormat("Delete-Thread-%d").build()) : null;
  final SessionState parentSession=SessionState.get();
  for (  final FileStatus status : statuses) {
    if (null == pool) {
      result&=FileUtils.moveToTrash(fs,status.getPath(),conf);
    }
 else {
      futures.add(pool.submit(new Callable<Boolean>(){
        @Override public Boolean call() throws Exception {
          SessionState.setCurrentSessionState(parentSession);
          return FileUtils.moveToTrash(fs,status.getPath(),conf);
        }
      }
));
    }
  }
  if (null != pool) {
    pool.shutdown();
    for (    Future<Boolean> future : futures) {
      try {
        result&=future.get();
      }
 catch (      InterruptedException|ExecutionException e) {
        LOG.error("Failed to delete: ",e);
        pool.shutdownNow();
        throw new IOException(e);
      }
    }
  }
  return result;
}
