{
  int fbo=(firstByte >>> 1) & 0x1f;
  int fb=utils.decodeBitWidth(fbo);
  int len=(firstByte & 0x01) << 8;
  len|=input.read();
  len+=1;
  int thirdByte=input.read();
  int bw=(thirdByte >>> 5) & 0x07;
  bw+=1;
  int pwo=thirdByte & 0x1f;
  int pw=utils.decodeBitWidth(pwo);
  int fourthByte=input.read();
  int pgw=(fourthByte >>> 5) & 0x07;
  pgw+=1;
  int pl=fourthByte & 0x1f;
  long base=utils.bytesToLongBE(input,bw);
  long mask=(1L << ((bw * 8) - 1));
  if ((base & mask) != 0) {
    base=base & ~mask;
    base=-base;
  }
  long[] unpacked=new long[len];
  utils.readInts(unpacked,0,len,fb,input);
  long[] unpackedPatch=new long[pl];
  if ((pw + pgw) > 64 && !skipCorrupt) {
    throw new IOException(ErrorMsg.ORC_CORRUPTED_READ.getMsg());
  }
  int bitSize=utils.getClosestFixedBits(pw + pgw);
  utils.readInts(unpackedPatch,0,pl,bitSize,input);
  int patchIdx=0;
  long currGap=0;
  long currPatch=0;
  long patchMask=((1L << pw) - 1);
  currGap=unpackedPatch[patchIdx] >>> pw;
  currPatch=unpackedPatch[patchIdx] & patchMask;
  long actualGap=0;
  while (currGap == 255 && currPatch == 0) {
    actualGap+=255;
    patchIdx++;
    currGap=unpackedPatch[patchIdx] >>> pw;
    currPatch=unpackedPatch[patchIdx] & patchMask;
  }
  actualGap+=currGap;
  for (int i=0; i < unpacked.length; i++) {
    if (i == actualGap) {
      long patchedVal=unpacked[i] | (currPatch << fb);
      literals[numLiterals++]=base + patchedVal;
      patchIdx++;
      if (patchIdx < pl) {
        currGap=unpackedPatch[patchIdx] >>> pw;
        currPatch=unpackedPatch[patchIdx] & patchMask;
        actualGap=0;
        while (currGap == 255 && currPatch == 0) {
          actualGap+=255;
          patchIdx++;
          currGap=unpackedPatch[patchIdx] >>> pw;
          currPatch=unpackedPatch[patchIdx] & patchMask;
        }
        actualGap+=currGap;
        actualGap+=i;
      }
    }
 else {
      literals[numLiterals++]=base + unpacked[i];
    }
  }
}
