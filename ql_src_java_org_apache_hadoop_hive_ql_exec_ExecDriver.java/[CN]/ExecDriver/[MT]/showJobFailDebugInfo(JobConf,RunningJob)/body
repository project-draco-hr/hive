{
  Map<String,Integer> failures=new HashMap<String,Integer>();
  Set<String> successes=new HashSet<String>();
  Map<String,String> taskToJob=new HashMap<String,String>();
  int startIndex=0;
  while (true) {
    TaskCompletionEvent[] taskCompletions=rj.getTaskCompletionEvents(startIndex);
    if (taskCompletions == null || taskCompletions.length == 0) {
      break;
    }
    boolean more=true;
    for (    TaskCompletionEvent t : taskCompletions) {
      String[] taskJobIds=ShimLoader.getHadoopShims().getTaskJobIDs(t);
      if (taskJobIds == null) {
        console.printError("Task attempt info is unavailable in this Hadoop version");
        more=false;
        break;
      }
      String taskId=taskJobIds[0];
      String jobId=taskJobIds[1];
      taskToJob.put(taskId,jobId);
      if (t.getTaskStatus() != TaskCompletionEvent.Status.SUCCEEDED) {
        Integer failAttempts=failures.get(taskId);
        if (failAttempts == null) {
          failAttempts=Integer.valueOf(0);
        }
        failAttempts=Integer.valueOf(failAttempts.intValue() + 1);
        failures.put(taskId,failAttempts);
      }
 else {
        successes.add(taskId);
      }
    }
    if (!more) {
      break;
    }
    startIndex+=taskCompletions.length;
  }
  for (  String task : successes) {
    failures.remove(task);
  }
  if (failures.keySet().size() == 0) {
    return;
  }
  int maxFailures=0;
  for (  Integer failCount : failures.values()) {
    if (maxFailures < failCount.intValue())     maxFailures=failCount.intValue();
  }
  console.printError("\nFailed tasks with most" + "(" + maxFailures + ")"+ " failures "+ ": ");
  String jtUrl=JobTrackerURLResolver.getURL(conf);
  for (  String task : failures.keySet()) {
    if (failures.get(task).intValue() == maxFailures) {
      String jobId=taskToJob.get(task);
      String taskUrl=jtUrl + "/taskdetails.jsp?jobid=" + jobId+ "&tipid="+ task.toString();
      console.printError("Task URL: " + taskUrl + "\n");
      break;
    }
  }
  return;
}
