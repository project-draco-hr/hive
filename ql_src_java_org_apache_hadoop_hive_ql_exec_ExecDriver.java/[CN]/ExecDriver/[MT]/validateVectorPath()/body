{
  System.out.println("Validating if vectorized execution is applicable");
  LOG.info("Validating if vectorized execution is applicable");
  MapredWork thePlan=this.getWork();
  for (  String path : thePlan.getPathToPartitionInfo().keySet()) {
    PartitionDesc pd=thePlan.getPathToPartitionInfo().get(path);
    List<Class<?>> interfaceList=Arrays.asList(pd.getInputFileFormatClass().getInterfaces());
    if (!interfaceList.contains(VectorizedInputFormatInterface.class)) {
      System.out.println("Input format: " + pd.getInputFileFormatClassName() + ", doesn't provide vectorized input");
      LOG.info("Input format: " + pd.getInputFileFormatClassName() + ", doesn't provide vectorized input");
      return false;
    }
  }
  VectorizationContext vc=new VectorizationContext(null,0);
  for (  String onefile : thePlan.getPathToAliases().keySet()) {
    List<String> aliases=thePlan.getPathToAliases().get(onefile);
    for (    String onealias : aliases) {
      Operator<? extends OperatorDesc> op=thePlan.getAliasToWork().get(onealias);
      Operator<? extends OperatorDesc> vectorOp=null;
      try {
        vectorOp=VectorMapOperator.vectorizeOperator(op,vc);
      }
 catch (      Exception e) {
        LOG.info("Cannot vectorize the plan",e);
        System.out.println("Cannot vectorize the plan: " + e);
        return false;
      }
      if (vectorOp == null) {
        LOG.info("Cannot vectorize the plan");
        System.out.println("Cannot vectorize the plan");
        return false;
      }
      try {
        validateVectorOperator(vectorOp);
      }
 catch (      HiveException e) {
        LOG.info("Cannot vectorize the plan",e);
        System.out.println("Cannot vectorize the plan");
        return false;
      }
    }
  }
  System.out.println("Query can be vectorized");
  return true;
}
