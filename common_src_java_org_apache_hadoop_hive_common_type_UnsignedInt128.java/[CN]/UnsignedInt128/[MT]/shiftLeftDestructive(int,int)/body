{
  if (wordShifts == 0 && bitShiftsInWord == 0) {
    return;
  }
  assert(wordShifts >= 0);
  assert(bitShiftsInWord >= 0);
  assert(bitShiftsInWord < 32);
  if (wordShifts >= 4) {
    zeroClear();
    return;
  }
  final int shiftRestore=32 - bitShiftsInWord;
  final boolean noRestore=bitShiftsInWord == 0;
  int z0=0, z1=0, z2=0, z3=0;
switch (wordShifts) {
case 3:
    z3=this.v[0] << bitShiftsInWord;
  break;
case 2:
z2=(this.v[0] << bitShiftsInWord);
z3=(noRestore ? 0 : this.v[0] >>> shiftRestore) | this.v[1] << bitShiftsInWord;
break;
case 1:
z1=(this.v[0] << bitShiftsInWord);
z2=(noRestore ? 0 : this.v[0] >>> shiftRestore) | (this.v[1] << bitShiftsInWord);
z3=(noRestore ? 0 : this.v[1] >>> shiftRestore) | this.v[2] << bitShiftsInWord;
break;
case 0:
z0=(this.v[0] << bitShiftsInWord);
z1=(noRestore ? 0 : this.v[0] >>> shiftRestore) | (this.v[1] << bitShiftsInWord);
z2=(noRestore ? 0 : this.v[1] >>> shiftRestore) | (this.v[2] << bitShiftsInWord);
z3=(noRestore ? 0 : this.v[2] >>> shiftRestore) | this.v[3] << bitShiftsInWord;
break;
default :
assert(false);
}
update(z0,z1,z2,z3);
}
