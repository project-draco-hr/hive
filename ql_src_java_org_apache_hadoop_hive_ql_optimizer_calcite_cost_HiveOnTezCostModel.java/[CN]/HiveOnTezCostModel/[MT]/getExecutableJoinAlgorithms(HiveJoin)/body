{
  Set<JoinAlgorithm> possibleAlgorithms=new HashSet<JoinAlgorithm>();
  RelNode smallInput;
  if (join.getMapJoinStreamingSide() == MapJoinStreamingRelation.LEFT_RELATION) {
    smallInput=join.getRight();
  }
 else   if (join.getMapJoinStreamingSide() == MapJoinStreamingRelation.RIGHT_RELATION) {
    smallInput=join.getLeft();
  }
 else {
    smallInput=null;
  }
  if (smallInput != null) {
    JoinPredicateInfo joinPredInfo=HiveCalciteUtil.JoinPredicateInfo.constructJoinPredicateInfo(join);
    List<ImmutableIntList> joinKeysInChildren=new ArrayList<ImmutableIntList>();
    joinKeysInChildren.add(ImmutableIntList.copyOf(joinPredInfo.getProjsFromLeftPartOfJoinKeysInChildSchema()));
    joinKeysInChildren.add(ImmutableIntList.copyOf(joinPredInfo.getProjsFromRightPartOfJoinKeysInChildSchema()));
    Integer buckets=RelMetadataQuery.splitCount(smallInput);
    boolean bucketFitsMemory=false;
    boolean inputFitsMemory=false;
    if (buckets != null) {
      bucketFitsMemory=isFittingIntoMemory(maxMemory,smallInput,buckets);
    }
    inputFitsMemory=bucketFitsMemory ? isFittingIntoMemory(maxMemory,smallInput,1) : false;
    boolean orderedBucketed=true;
    boolean bucketed=true;
    for (int i=0; i < join.getInputs().size(); i++) {
      RelNode input=join.getInputs().get(i);
      if (orderedBucketed) {
        boolean orderFound=join.getSortedInputs().get(i);
        if (!orderFound) {
          orderedBucketed=false;
        }
      }
      if (bucketFitsMemory && bucketed) {
        RelDistribution distribution=RelMetadataQuery.distribution(input);
        if (distribution.getType() != Type.HASH_DISTRIBUTED) {
          orderedBucketed=false;
          bucketed=false;
        }
        if (!distribution.getKeys().containsAll(joinKeysInChildren.get(i))) {
          orderedBucketed=false;
          bucketed=false;
        }
      }
    }
    if (orderedBucketed) {
      possibleAlgorithms.add(JoinAlgorithm.SMB_JOIN);
    }
    if (bucketFitsMemory && bucketed) {
      possibleAlgorithms.add(JoinAlgorithm.BUCKET_JOIN);
    }
    if (inputFitsMemory) {
      possibleAlgorithms.add(JoinAlgorithm.MAP_JOIN);
    }
  }
  possibleAlgorithms.add(JoinAlgorithm.COMMON_JOIN);
  return EnumSet.copyOf(possibleAlgorithms);
}
