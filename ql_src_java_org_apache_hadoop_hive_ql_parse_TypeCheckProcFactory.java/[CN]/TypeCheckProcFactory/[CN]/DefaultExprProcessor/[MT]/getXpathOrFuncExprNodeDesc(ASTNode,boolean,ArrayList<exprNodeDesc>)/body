{
  if (isRedundantConversionFunction(expr,isFunction,children)) {
    assert(children.size() == 1);
    assert(children.get(0) != null);
    return children.get(0);
  }
  String funcText=getFunctionText(expr,isFunction);
  exprNodeDesc desc;
  if (funcText.equals(".")) {
    assert(children.size() == 2);
    assert(children.get(1) instanceof exprNodeConstantDesc);
    exprNodeDesc object=children.get(0);
    exprNodeConstantDesc fieldName=(exprNodeConstantDesc)children.get(1);
    assert(fieldName.getValue() instanceof String);
    String fieldNameString=(String)fieldName.getValue();
    TypeInfo objectTypeInfo=object.getTypeInfo();
    boolean isList=(object.getTypeInfo().getCategory() == ObjectInspector.Category.LIST);
    if (isList) {
      objectTypeInfo=((ListTypeInfo)objectTypeInfo).getListElementTypeInfo();
    }
    if (objectTypeInfo.getCategory() != Category.STRUCT) {
      throw new SemanticException(ErrorMsg.INVALID_DOT.getMsg(expr));
    }
    TypeInfo t=((StructTypeInfo)objectTypeInfo).getStructFieldTypeInfo(fieldNameString);
    if (isList) {
      t=TypeInfoFactory.getListTypeInfo(t);
    }
    desc=new exprNodeFieldDesc(t,children.get(0),fieldNameString,isList);
  }
 else   if (funcText.equals("[")) {
    assert(children.size() == 2);
    TypeInfo myt=children.get(0).getTypeInfo();
    if (myt.getCategory() == Category.LIST) {
      if (!(children.get(1) instanceof exprNodeConstantDesc) || !(((exprNodeConstantDesc)children.get(1)).getTypeInfo().equals(TypeInfoFactory.intTypeInfo))) {
        throw new SemanticException(ErrorMsg.INVALID_ARRAYINDEX_CONSTANT.getMsg(expr));
      }
      TypeInfo t=((ListTypeInfo)myt).getListElementTypeInfo();
      desc=new exprNodeGenericFuncDesc(t,FunctionRegistry.getGenericUDFForIndex(),children);
    }
 else     if (myt.getCategory() == Category.MAP) {
      if (!(children.get(1) instanceof exprNodeConstantDesc)) {
        throw new SemanticException(ErrorMsg.INVALID_MAPINDEX_CONSTANT.getMsg(expr));
      }
      if (!(((exprNodeConstantDesc)children.get(1)).getTypeInfo().equals(((MapTypeInfo)myt).getMapKeyTypeInfo()))) {
        throw new SemanticException(ErrorMsg.INVALID_MAPINDEX_TYPE.getMsg(expr));
      }
      TypeInfo t=((MapTypeInfo)myt).getMapValueTypeInfo();
      desc=new exprNodeGenericFuncDesc(t,FunctionRegistry.getGenericUDFForIndex(),children);
    }
 else {
      throw new SemanticException(ErrorMsg.NON_COLLECTION_TYPE.getMsg(expr,myt.getTypeName()));
    }
  }
 else {
    FunctionInfo fi=FunctionRegistry.getFunctionInfo(funcText);
    if (fi == null) {
      if (isFunction)       throw new SemanticException(ErrorMsg.INVALID_FUNCTION.getMsg((ASTNode)expr.getChild(0)));
 else       throw new SemanticException(ErrorMsg.INVALID_FUNCTION.getMsg((ASTNode)expr));
    }
    if (fi.getGenericUDTF() != null) {
      throw new SemanticException(ErrorMsg.UDTF_INVALID_LOCATION.getMsg());
    }
    try {
      desc=getFuncExprNodeDesc(funcText,children);
    }
 catch (    AmbiguousMethodException e) {
      ArrayList<Class<?>> argumentClasses=new ArrayList<Class<?>>(children.size());
      for (int i=0; i < children.size(); i++) {
        argumentClasses.add(((PrimitiveTypeInfo)children.get(i).getTypeInfo()).getPrimitiveWritableClass());
      }
      if (isFunction) {
        String reason="Looking for UDF \"" + expr.getChild(0).getText() + "\" with parameters "+ argumentClasses;
        throw new SemanticException(ErrorMsg.INVALID_FUNCTION_SIGNATURE.getMsg((ASTNode)expr.getChild(0),reason),e);
      }
 else {
        String reason="Looking for Operator \"" + expr.getText() + "\" with parameters "+ argumentClasses;
        throw new SemanticException(ErrorMsg.INVALID_OPERATOR_SIGNATURE.getMsg(expr,reason),e);
      }
    }
  }
  if (FunctionRegistry.isOpPositive(desc)) {
    assert(desc.getChildren().size() == 1);
    desc=desc.getChildren().get(0);
  }
  assert(desc != null);
  return desc;
}
