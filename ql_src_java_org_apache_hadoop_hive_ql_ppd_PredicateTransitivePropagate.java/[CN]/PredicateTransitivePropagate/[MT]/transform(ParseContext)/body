{
  pGraphContext=pctx;
  Map<Rule,NodeProcessor> opRules=new LinkedHashMap<Rule,NodeProcessor>();
  opRules.put(new RuleRegExp("R1","(" + FilterOperator.getOperatorName() + "%"+ ReduceSinkOperator.getOperatorName()+ "%"+ JoinOperator.getOperatorName()+ "%)"),new JoinTransitive());
  TransitiveContext context=new TransitiveContext();
  Dispatcher disp=new DefaultRuleDispatcher(null,opRules,context);
  GraphWalker ogw=new PreOrderWalker(disp);
  List<Node> topNodes=new ArrayList<Node>();
  topNodes.addAll(pGraphContext.getTopOps().values());
  ogw.startWalking(topNodes,null);
  Map<ReduceSinkOperator,List<ExprNodeDesc>> newFilters=context.getNewfilters();
  for (  Map.Entry<ReduceSinkOperator,List<ExprNodeDesc>> entry : newFilters.entrySet()) {
    ReduceSinkOperator reducer=entry.getKey();
    Operator<?> parent=reducer.getParentOperators().get(0);
    List<ExprNodeDesc> exprs=entry.getValue();
    if (parent instanceof FilterOperator) {
      exprs=ExprNodeDescUtils.split(((FilterOperator)parent).getConf().getPredicate(),exprs);
      ExprNodeDesc merged=ExprNodeDescUtils.mergePredicates(exprs);
      ((FilterOperator)parent).getConf().setPredicate(merged);
    }
 else {
      ExprNodeDesc merged=ExprNodeDescUtils.mergePredicates(exprs);
      RowResolver parentRR=pGraphContext.getOpParseCtx().get(parent).getRowResolver();
      Operator<FilterDesc> newFilter=createFilter(reducer,parent,parentRR,merged);
      pGraphContext.getOpParseCtx().put(newFilter,new OpParseContext(parentRR));
    }
  }
  return pGraphContext;
}
