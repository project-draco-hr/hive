{
  try {
    alias=order[tag];
    ArrayList<Object> key=JoinUtil.computeKeys(row,joinKeys.get(alias),joinKeysObjectInspectors.get(alias));
    ArrayList<Object> value=JoinUtil.computeValues(row,joinValues.get(alias),joinValuesObjectInspectors.get(alias),joinFilters.get(alias),joinFilterObjectInspectors.get(alias),noOuterJoin);
    if (firstRow) {
      metadataKeyTag=-1;
      TableDesc keyTableDesc=conf.getKeyTblDesc();
      SerDe keySerializer=(SerDe)ReflectionUtils.newInstance(keyTableDesc.getDeserializerClass(),null);
      keySerializer.initialize(null,keyTableDesc.getProperties());
      MapJoinMetaData.clear();
      MapJoinMetaData.put(Integer.valueOf(metadataKeyTag),new JDBMSinkObjectCtx(ObjectInspectorUtils.getStandardObjectInspector(keySerializer.getObjectInspector(),ObjectInspectorCopyOption.WRITABLE),keySerializer,keyTableDesc,hconf));
      firstRow=false;
    }
    numMapRowsRead++;
    if ((numMapRowsRead > maxMapJoinSize) && (counterNameToEnum != null)) {
      LOG.warn("Too many rows in map join tables. Fatal error counter will be incremented!!");
      incrCounter(fatalErrorCntr,1);
      fatalError=true;
      return;
    }
    HashMapWrapper<MapJoinObjectKey,MapJoinObjectValue> hashTable=mapJoinTables.get((byte)tag);
    MapJoinObjectKey keyMap=new MapJoinObjectKey(metadataKeyTag,key);
    MapJoinObjectValue o=hashTable.get(keyMap);
    RowContainer res=null;
    boolean needNewKey=true;
    if (o == null) {
      int bucketSize=HiveConf.getIntVar(hconf,HiveConf.ConfVars.HIVEMAPJOINBUCKETCACHESIZE);
      res=JoinUtil.getRowContainer(hconf,rowContainerStandardObjectInspectors.get((byte)tag),order[tag],bucketSize,spillTableDesc,conf,noOuterJoin);
      res.add(value);
    }
 else {
      res=o.getObj();
      res.add(value);
      if (hashTable.cacheSize() > 0) {
        o.setObj(res);
        needNewKey=false;
      }
    }
    if (metadataValueTag[tag] == -1) {
      metadataValueTag[tag]=order[tag];
      TableDesc valueTableDesc=conf.getValueTblDescs().get(tag);
      SerDe valueSerDe=(SerDe)ReflectionUtils.newInstance(valueTableDesc.getDeserializerClass(),null);
      valueSerDe.initialize(null,valueTableDesc.getProperties());
      MapJoinMetaData.put(Integer.valueOf(metadataValueTag[tag]),new JDBMSinkObjectCtx(ObjectInspectorUtils.getStandardObjectInspector(valueSerDe.getObjectInspector(),ObjectInspectorCopyOption.WRITABLE),valueSerDe,valueTableDesc,hconf));
    }
    if (needNewKey) {
      MapJoinObjectKey keyObj=new MapJoinObjectKey(metadataKeyTag,key);
      MapJoinObjectValue valueObj=new MapJoinObjectValue(metadataValueTag[tag],res);
      valueObj.setConf(hconf);
      if (res.size() > mapJoinRowsKey) {
        if (res.size() % 100 == 0) {
          LOG.warn("Number of values for a given key " + keyObj + " are "+ res.size());
          LOG.warn("used memory " + Runtime.getRuntime().totalMemory());
        }
      }
      hashTable.put(keyObj,valueObj);
    }
  }
 catch (  SerDeException e) {
    e.printStackTrace();
    throw new HiveException(e);
  }
}
