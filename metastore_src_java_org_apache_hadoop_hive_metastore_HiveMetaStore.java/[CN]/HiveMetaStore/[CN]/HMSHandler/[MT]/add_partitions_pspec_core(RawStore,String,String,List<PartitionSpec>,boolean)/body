{
  boolean success=false;
  final Map<PartValEqWrapperLite,Boolean> addedPartitions=Collections.synchronizedMap(new HashMap<PartValEqWrapperLite,Boolean>());
  PartitionSpecProxy partitionSpecProxy=PartitionSpecProxy.Factory.get(partSpecs);
  final PartitionSpecProxy.PartitionIterator partitionIterator=partitionSpecProxy.getPartitionIterator();
  Table tbl=null;
  try {
    ms.openTransaction();
    tbl=ms.getTable(dbName,tblName);
    if (tbl == null) {
      throw new InvalidObjectException("Unable to add partitions because " + "database or table " + dbName + "."+ tblName+ " does not exist");
    }
    firePreEvent(new PreAddPartitionEvent(tbl,partitionSpecProxy,this));
    List<Future<Partition>> partFutures=Lists.newArrayList();
    final Table table=tbl;
    while (partitionIterator.hasNext()) {
      final Partition part=partitionIterator.getCurrent();
      if (!part.getTableName().equals(tblName) || !part.getDbName().equals(dbName)) {
        throw new MetaException("Partition does not belong to target table " + dbName + "."+ tblName+ ": "+ part);
      }
      boolean shouldAdd=startAddPartition(ms,part,ifNotExists);
      if (!shouldAdd) {
        LOG.info("Not adding partition " + part + " as it already exists");
        continue;
      }
      partFutures.add(threadPool.submit(new Callable(){
        @Override public Object call() throws Exception {
          boolean madeDir=createLocationForAddedPartition(table,part);
          if (addedPartitions.put(new PartValEqWrapperLite(part),madeDir) != null) {
            throw new MetaException("Duplicate partitions in the list: " + part);
          }
          initializeAddedPartition(table,part,madeDir);
          return part;
        }
      }
));
      partitionIterator.next();
    }
    try {
      for (      Future<Partition> partFuture : partFutures) {
        Partition part=partFuture.get();
      }
    }
 catch (    InterruptedException|ExecutionException e) {
      for (      Future<Partition> partFuture : partFutures) {
        partFuture.cancel(true);
      }
      throw new MetaException(e.getMessage());
    }
    success=ms.addPartitions(dbName,tblName,partitionSpecProxy,ifNotExists) && ms.commitTransaction();
    return addedPartitions.size();
  }
  finally {
    if (!success) {
      ms.rollbackTransaction();
      for (      Map.Entry<PartValEqWrapperLite,Boolean> e : addedPartitions.entrySet()) {
        if (e.getValue()) {
          wh.deleteDir(new Path(e.getKey().location),true);
        }
      }
    }
    fireMetaStoreAddPartitionEvent(tbl,partitionSpecProxy,null,true);
  }
}
