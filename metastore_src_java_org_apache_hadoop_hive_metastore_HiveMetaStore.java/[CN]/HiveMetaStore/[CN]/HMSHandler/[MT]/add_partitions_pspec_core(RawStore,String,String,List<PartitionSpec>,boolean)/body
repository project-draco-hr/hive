{
  boolean success=false;
  Map<PartValEqWrapperLite,Boolean> addedPartitions=new HashMap<PartValEqWrapperLite,Boolean>();
  PartitionSpecProxy partitionSpecProxy=PartitionSpecProxy.Factory.get(partSpecs);
  PartitionSpecProxy.PartitionIterator partitionIterator=partitionSpecProxy.getPartitionIterator();
  Table tbl=null;
  try {
    ms.openTransaction();
    tbl=ms.getTable(dbName,tblName);
    if (tbl == null) {
      throw new InvalidObjectException("Unable to add partitions because " + "database or table " + dbName + "."+ tblName+ " does not exist");
    }
    firePreEvent(new PreAddPartitionEvent(tbl,partitionSpecProxy,this));
    int nPartitions=0;
    while (partitionIterator.hasNext()) {
      Partition part=partitionIterator.getCurrent();
      if (!part.getTableName().equals(tblName) || !part.getDbName().equals(dbName)) {
        throw new MetaException("Partition does not belong to target table " + dbName + "."+ tblName+ ": "+ part);
      }
      boolean shouldAdd=startAddPartition(ms,part,ifNotExists);
      if (!shouldAdd) {
        LOG.info("Not adding partition " + part + " as it already exists");
        continue;
      }
      boolean madeDir=createLocationForAddedPartition(tbl,part);
      if (addedPartitions.put(new PartValEqWrapperLite(part),madeDir) != null) {
        throw new MetaException("Duplicate partitions in the list: " + part);
      }
      initializeAddedPartition(tbl,partitionIterator,madeDir);
      ++nPartitions;
      partitionIterator.next();
    }
    success=ms.addPartitions(dbName,tblName,partitionSpecProxy,ifNotExists) && ms.commitTransaction();
    return nPartitions;
  }
  finally {
    if (!success) {
      ms.rollbackTransaction();
      for (      Entry<PartValEqWrapperLite,Boolean> e : addedPartitions.entrySet()) {
        if (e.getValue()) {
          wh.deleteDir(new Path(e.getKey().location),true);
        }
      }
    }
    fireMetaStoreAddPartitionEvent(tbl,partitionSpecProxy,null,true);
  }
}
