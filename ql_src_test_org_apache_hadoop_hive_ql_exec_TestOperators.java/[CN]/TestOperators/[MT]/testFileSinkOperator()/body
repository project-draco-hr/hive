{
  try {
    exprNodeDesc exprDesc1=new exprNodeColumnDesc(TypeInfo.getPrimitiveTypeInfo(String.class),"col[1]");
    ArrayList<exprNodeDesc> exprDesc2children=new ArrayList<exprNodeDesc>();
    exprNodeDesc expr1=new exprNodeColumnDesc(String.class,"col[0]");
    exprNodeDesc expr2=new exprNodeConstantDesc("1");
    exprNodeDesc exprDesc2=SemanticAnalyzer.getFuncExprNodeDesc("concat",expr1,expr2);
    ArrayList<exprNodeDesc> earr=new ArrayList<exprNodeDesc>();
    earr.add(exprDesc1);
    earr.add(exprDesc2);
    selectDesc selectCtx=new selectDesc(earr);
    Operator<selectDesc> op=OperatorFactory.get(selectDesc.class);
    op.setConf(selectCtx);
    fileSinkDesc fsd=new fileSinkDesc("file:///tmp" + File.separator + System.getProperty("user.name")+ File.separator+ "TestFileSinkOperator",Utilities.defaultTd);
    Operator<fileSinkDesc> flop=OperatorFactory.get(fileSinkDesc.class);
    flop.setConf(fsd);
    ArrayList<Operator<? extends Serializable>> nextOp=new ArrayList<Operator<? extends Serializable>>();
    nextOp.add(flop);
    op.setChildOperators(nextOp);
    op.initialize(new JobConf(TestOperators.class));
    for (int i=0; i < 5; i++) {
      op.process(r[i]);
    }
    op.close(false);
    System.out.println("FileSink Operator ok");
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw e;
  }
}
