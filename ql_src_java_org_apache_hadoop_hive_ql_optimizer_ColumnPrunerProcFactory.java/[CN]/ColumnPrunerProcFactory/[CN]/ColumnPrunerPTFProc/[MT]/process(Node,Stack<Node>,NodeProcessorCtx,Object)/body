{
  ColumnPrunerProcCtx cppCtx=(ColumnPrunerProcCtx)ctx;
  PTFOperator op=(PTFOperator)nd;
  PTFDesc conf=op.getConf();
  PartitionedTableFunctionDef funcDef=conf.getFuncDef();
  List<String> referencedColumns=funcDef.getReferencedColumns();
  if (!conf.forWindowing() && !conf.forNoop() && referencedColumns == null) {
    return super.process(nd,stack,cppCtx,nodeOutputs);
  }
  List<String> prunedCols=cppCtx.getPrunedColList(op.getChildOperators().get(0));
  if (conf.forWindowing()) {
    WindowTableFunctionDef def=(WindowTableFunctionDef)funcDef;
    prunedCols=Utilities.mergeUniqElems(getWindowFunctionColumns(def),prunedCols);
  }
 else   if (conf.forNoop()) {
    prunedCols=new ArrayList(cppCtx.getPrunedColList(op.getChildOperators().get(0)));
  }
 else {
    prunedCols=referencedColumns;
  }
  List<ColumnInfo> newRS=prunedColumnsList(prunedCols,op.getSchema(),funcDef);
  op.getSchema().setSignature(new ArrayList<ColumnInfo>(newRS));
  ShapeDetails outputShape=funcDef.getStartOfChain().getInput().getOutputShape();
  cppCtx.getPrunedColLists().put(op,outputShape.getColumnNames());
  return null;
}
