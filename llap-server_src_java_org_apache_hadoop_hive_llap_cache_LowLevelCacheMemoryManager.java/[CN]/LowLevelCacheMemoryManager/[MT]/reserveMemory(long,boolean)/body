{
  int badCallCount=0;
  int nextLog=4;
  long evictedTotalMetric=0, reservedTotalMetric=0, remainingToReserve=memoryToReserve;
  boolean result=true;
  while (remainingToReserve > 0) {
    long usedMem=usedMemory.get(), newUsedMem=usedMem + remainingToReserve;
    if (newUsedMem <= maxSize) {
      if (usedMemory.compareAndSet(usedMem,newUsedMem)) {
        reservedTotalMetric+=remainingToReserve;
        break;
      }
      continue;
    }
    if (evictor == null)     return false;
    long evicted=evictor.evictSomeBlocks(remainingToReserve);
    if (evicted == 0) {
      if (!waitForEviction) {
        result=false;
        break;
      }
      ++badCallCount;
      if (badCallCount == nextLog) {
        LlapIoImpl.LOG.warn("Cannot evict blocks for " + badCallCount + " calls; cache full?");
        nextLog<<=1;
        try {
          Thread.sleep(Math.min(1000,nextLog));
        }
 catch (        InterruptedException e) {
          Thread.currentThread().interrupt();
          result=false;
          break;
        }
      }
      continue;
    }
    evictedTotalMetric+=evicted;
    badCallCount=0;
    while (true) {
      long availableToReserveAfterEvict=maxSize - usedMem + evicted;
      long reservedAfterEvict=Math.min(remainingToReserve,availableToReserveAfterEvict);
      if (usedMemory.compareAndSet(usedMem,usedMem - evicted + reservedAfterEvict)) {
        remainingToReserve-=reservedAfterEvict;
        reservedTotalMetric+=reservedAfterEvict;
        break;
      }
      usedMem=usedMemory.get();
    }
  }
  metrics.incrCacheCapacityUsed(reservedTotalMetric - evictedTotalMetric);
  return result;
}
