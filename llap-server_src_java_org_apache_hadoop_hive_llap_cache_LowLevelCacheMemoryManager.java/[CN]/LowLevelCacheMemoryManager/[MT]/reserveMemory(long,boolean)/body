{
  int badCallCount=0;
  int nextLog=4;
  while (memoryToReserve > 0) {
    long usedMem=usedMemory.get(), newUsedMem=usedMem + memoryToReserve;
    if (newUsedMem <= maxSize) {
      if (usedMemory.compareAndSet(usedMem,newUsedMem))       break;
      continue;
    }
    long evicted=evictor.evictSomeBlocks(memoryToReserve);
    if (evicted == 0) {
      if (!waitForEviction)       return false;
      ++badCallCount;
      if (badCallCount == nextLog) {
        LlapIoImpl.LOG.warn("Cannot evict blocks for " + badCallCount + " calls; cache full?");
        nextLog<<=1;
        try {
          Thread.sleep(Math.min(1000,nextLog));
        }
 catch (        InterruptedException e) {
          Thread.currentThread().interrupt();
          return false;
        }
      }
      continue;
    }
    badCallCount=0;
    while (true) {
      long reserveWithEviction=Math.min(memoryToReserve,maxSize - usedMem + evicted);
      if (usedMemory.compareAndSet(usedMem,usedMem - evicted + reserveWithEviction)) {
        memoryToReserve-=reserveWithEviction;
        break;
      }
      usedMem=usedMemory.get();
    }
  }
  metrics.incrCacheCapacityUsed(memoryToReserve);
  return true;
}
