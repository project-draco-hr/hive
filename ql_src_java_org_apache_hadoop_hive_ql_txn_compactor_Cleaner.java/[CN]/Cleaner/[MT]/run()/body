{
  if (cleanerCheckInterval == 0) {
    cleanerCheckInterval=conf.getTimeVar(HiveConf.ConfVars.HIVE_COMPACTOR_CLEANER_RUN_INTERVAL,TimeUnit.MILLISECONDS);
  }
  do {
    boolean setLooped=!looped.boolVal;
    try {
      long startedAt=System.currentTimeMillis();
      List<CompactionInfo> toClean=txnHandler.findReadyToClean();
      if (toClean.size() > 0 || compactId2LockMap.size() > 0) {
        ShowLocksResponse locksResponse=txnHandler.showLocks(new ShowLocksRequest());
        for (        CompactionInfo ci : toClean) {
          if (!compactId2LockMap.containsKey(ci.id)) {
            compactId2LockMap.put(ci.id,findRelatedLocks(ci,locksResponse));
            compactId2CompactInfoMap.put(ci.id,ci);
          }
        }
        Set<Long> currentLocks=buildCurrentLockSet(locksResponse);
        List<Long> expiredLocks=new ArrayList<Long>();
        List<Long> compactionsCleaned=new ArrayList<Long>();
        try {
          for (          Map.Entry<Long,Set<Long>> queueEntry : compactId2LockMap.entrySet()) {
            boolean sawLock=false;
            for (            Long lockId : queueEntry.getValue()) {
              if (currentLocks.contains(lockId)) {
                sawLock=true;
                break;
              }
 else {
                expiredLocks.add(lockId);
              }
            }
            if (!sawLock) {
              compactionsCleaned.add(queueEntry.getKey());
              clean(compactId2CompactInfoMap.get(queueEntry.getKey()));
            }
 else {
              for (              Long lockId : expiredLocks) {
                queueEntry.getValue().remove(lockId);
              }
            }
          }
        }
  finally {
          if (compactionsCleaned.size() > 0) {
            for (            Long compactId : compactionsCleaned) {
              compactId2LockMap.remove(compactId);
              compactId2CompactInfoMap.remove(compactId);
            }
          }
        }
      }
      long elapsedTime=System.currentTimeMillis() - startedAt;
      if (elapsedTime >= cleanerCheckInterval || stop.boolVal)       continue;
 else       Thread.sleep(cleanerCheckInterval - elapsedTime);
    }
 catch (    Throwable t) {
      LOG.error("Caught an exception in the main loop of compactor cleaner, " + StringUtils.stringifyException(t));
    }
    if (setLooped) {
      looped.boolVal=true;
    }
  }
 while (!stop.boolVal);
}
