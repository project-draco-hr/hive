{
  VectorExpression udf=null;
  if (isPositive) {
switch (colType1) {
case DATE:
      udf=new VectorUDFDateAddScalarCol(scalar1,0,1);
    break;
case TIMESTAMP:
  udf=new VectorUDFDateAddScalarCol(toTimestamp(scalar1),0,1);
break;
case STRING:
udf=new VectorUDFDateAddScalarCol(toString(scalar1),0,1);
break;
}
}
 else {
switch (colType1) {
case DATE:
udf=new VectorUDFDateSubScalarCol(scalar1,0,1);
break;
case TIMESTAMP:
udf=new VectorUDFDateSubScalarCol(toTimestamp(scalar1),0,1);
break;
case STRING:
udf=new VectorUDFDateSubScalarCol(toString(scalar1),0,1);
break;
}
}
udf.setInputTypes(colType1,VectorExpression.Type.OTHER);
udf.evaluate(batch);
BytesColumnVector output=(BytesColumnVector)batch.cols[1];
try {
for (int i=0; i < date2.vector.length; i++) {
String expected;
if (isPositive) {
expected=new String(toString(scalar1 + date2.vector[i]),"UTF-8");
}
 else {
expected=new String(toString(scalar1 - date2.vector[i]),"UTF-8");
}
if (date2.isNull[i]) {
Assert.assertTrue(output.isNull[i]);
}
 else {
Assert.assertEquals(expected,new String(output.vector[i],output.start[i],output.start[i] + output.length[i],"UTF-8"));
}
}
}
 catch (Exception e) {
throw new RuntimeException(e);
}
}
