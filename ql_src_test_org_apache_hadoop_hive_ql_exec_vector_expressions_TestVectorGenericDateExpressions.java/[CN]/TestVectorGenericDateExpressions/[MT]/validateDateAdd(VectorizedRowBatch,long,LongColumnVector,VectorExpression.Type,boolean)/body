{
  VectorExpression udf=null;
  if (isPositive) {
switch (colType1) {
case DATE:
      udf=new VectorUDFDateAddScalarCol(scalar1,0,1);
    break;
case TIMESTAMP:
  udf=new VectorUDFDateAddScalarCol(toTimestamp(scalar1),0,1);
break;
case STRING:
case CHAR:
case VARCHAR:
udf=new VectorUDFDateAddScalarCol(toString(scalar1),0,1);
break;
default :
throw new Error("Invalid input type: " + colType1.name());
}
}
 else {
switch (colType1) {
case DATE:
udf=new VectorUDFDateSubScalarCol(scalar1,0,1);
break;
case TIMESTAMP:
udf=new VectorUDFDateSubScalarCol(toTimestamp(scalar1),0,1);
break;
case STRING:
case CHAR:
case VARCHAR:
udf=new VectorUDFDateSubScalarCol(toString(scalar1),0,1);
break;
default :
throw new Error("Invalid input type: " + colType1.name());
}
}
udf.setInputTypes(colType1,VectorExpression.Type.OTHER);
udf.evaluate(batch);
LongColumnVector output=(LongColumnVector)batch.cols[1];
try {
for (int i=0; i < date2.vector.length; i++) {
String expected;
if (isPositive) {
expected=new String(toString(scalar1 + date2.vector[i]),utf8);
}
 else {
expected=new String(toString(scalar1 - date2.vector[i]),utf8);
}
if (date2.isNull[i]) {
Assert.assertTrue(output.isNull[i]);
}
 else {
Assert.assertEquals(expected,new String(toString(output.vector[i])));
}
}
}
 catch (Exception e) {
throw new RuntimeException(e);
}
}
