{
  int colIndex;
  Object value;
  PrimitiveCategory pCategory;
  if (partitionValues != null) {
    for (    String key : partitionValues.keySet()) {
      colIndex=getColIndexBasedOnColName(key);
      value=partitionValues.get(key);
      pCategory=partitionTypes.get(key);
switch (pCategory) {
case BOOLEAN:
{
          LongColumnVector lcv=(LongColumnVector)batch.cols[colIndex];
          if (value == null) {
            lcv.noNulls=false;
            lcv.isNull[0]=true;
            lcv.isRepeating=true;
          }
 else {
            lcv.fill((Boolean)value == true ? 1 : 0);
            lcv.isNull[0]=false;
          }
        }
      break;
case BYTE:
{
      LongColumnVector lcv=(LongColumnVector)batch.cols[colIndex];
      if (value == null) {
        lcv.noNulls=false;
        lcv.isNull[0]=true;
        lcv.isRepeating=true;
      }
 else {
        lcv.fill((Byte)value);
        lcv.isNull[0]=false;
      }
    }
  break;
case SHORT:
{
  LongColumnVector lcv=(LongColumnVector)batch.cols[colIndex];
  if (value == null) {
    lcv.noNulls=false;
    lcv.isNull[0]=true;
    lcv.isRepeating=true;
  }
 else {
    lcv.fill((Short)value);
    lcv.isNull[0]=false;
  }
}
break;
case INT:
{
LongColumnVector lcv=(LongColumnVector)batch.cols[colIndex];
if (value == null) {
lcv.noNulls=false;
lcv.isNull[0]=true;
lcv.isRepeating=true;
}
 else {
lcv.fill((Integer)value);
lcv.isNull[0]=false;
}
}
break;
case LONG:
{
LongColumnVector lcv=(LongColumnVector)batch.cols[colIndex];
if (value == null) {
lcv.noNulls=false;
lcv.isNull[0]=true;
lcv.isRepeating=true;
}
 else {
lcv.fill((Long)value);
lcv.isNull[0]=false;
}
}
break;
case DATE:
{
LongColumnVector lcv=(LongColumnVector)batch.cols[colIndex];
if (value == null) {
lcv.noNulls=false;
lcv.isNull[0]=true;
lcv.isRepeating=true;
}
 else {
lcv.fill(DateWritable.dateToDays((Date)value));
lcv.isNull[0]=false;
}
}
break;
case TIMESTAMP:
{
LongColumnVector lcv=(LongColumnVector)batch.cols[colIndex];
if (value == null) {
lcv.noNulls=false;
lcv.isNull[0]=true;
lcv.isRepeating=true;
}
 else {
lcv.fill(TimestampUtils.getTimeNanoSec((Timestamp)value));
lcv.isNull[0]=false;
}
}
break;
case FLOAT:
{
DoubleColumnVector dcv=(DoubleColumnVector)batch.cols[colIndex];
if (value == null) {
dcv.noNulls=false;
dcv.isNull[0]=true;
dcv.isRepeating=true;
}
 else {
dcv.fill((Float)value);
dcv.isNull[0]=false;
}
}
break;
case DOUBLE:
{
DoubleColumnVector dcv=(DoubleColumnVector)batch.cols[colIndex];
if (value == null) {
dcv.noNulls=false;
dcv.isNull[0]=true;
dcv.isRepeating=true;
}
 else {
dcv.fill((Double)value);
dcv.isNull[0]=false;
}
}
break;
case DECIMAL:
{
DecimalColumnVector dv=(DecimalColumnVector)batch.cols[colIndex];
if (value == null) {
dv.noNulls=false;
dv.isNull[0]=true;
dv.isRepeating=true;
}
 else {
HiveDecimal hd=(HiveDecimal)value;
dv.vector[0]=new Decimal128(hd.toString(),(short)hd.scale());
dv.isRepeating=true;
dv.isNull[0]=false;
}
}
break;
case BINARY:
{
BytesColumnVector bcv=(BytesColumnVector)batch.cols[colIndex];
byte[] bytes=(byte[])value;
if (bytes == null) {
bcv.noNulls=false;
bcv.isNull[0]=true;
bcv.isRepeating=true;
}
 else {
bcv.fill(bytes);
bcv.isNull[0]=false;
}
}
break;
case STRING:
case CHAR:
case VARCHAR:
{
BytesColumnVector bcv=(BytesColumnVector)batch.cols[colIndex];
String sVal=(String)value;
if (sVal == null) {
bcv.noNulls=false;
bcv.isNull[0]=true;
bcv.isRepeating=true;
}
 else {
bcv.fill(sVal.getBytes());
bcv.isNull[0]=false;
}
}
break;
default :
throw new HiveException("Unable to recognize the partition type " + pCategory + " for column "+ key);
}
}
}
}
