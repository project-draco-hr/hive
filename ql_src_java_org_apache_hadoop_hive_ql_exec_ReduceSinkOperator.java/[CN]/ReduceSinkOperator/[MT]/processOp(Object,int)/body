{
  try {
    ObjectInspector rowInspector=inputObjInspectors[tag];
    if (isFirstRow) {
      isFirstRow=false;
      keyObjectInspector=initEvaluatorsAndReturnStruct(keyEval,distinctColIndices,conf.getOutputKeyColumnNames(),numDistributionKeys,rowInspector);
      valueObjectInspector=initEvaluatorsAndReturnStruct(valueEval,conf.getOutputValueColumnNames(),rowInspector);
      partitionObjectInspectors=initEvaluators(partitionEval,rowInspector);
      int numKeys=numDistinctExprs > 0 ? numDistinctExprs : 1;
      int keyLen=numDistinctExprs > 0 ? numDistributionKeys + 1 : numDistributionKeys;
      cachedKeys=new Object[numKeys][keyLen];
      cachedValues=new Object[valueEval.length];
    }
    int keyHashCode=0;
    if (partitionEval.length == 0) {
      if (random == null) {
        random=new Random(12345);
      }
      keyHashCode=random.nextInt();
    }
 else {
      for (int i=0; i < partitionEval.length; i++) {
        Object o=partitionEval[i].evaluate(row);
        keyHashCode=keyHashCode * 31 + ObjectInspectorUtils.hashCode(o,partitionObjectInspectors[i]);
      }
    }
    for (int i=0; i < valueEval.length; i++) {
      cachedValues[i]=valueEval[i].evaluate(row);
    }
    value=valueSerializer.serialize(cachedValues,valueObjectInspector);
    Object[] distributionKeys=new Object[numDistributionKeys];
    for (int i=0; i < numDistributionKeys; i++) {
      distributionKeys[i]=keyEval[i].evaluate(row);
    }
    if (numDistinctExprs > 0) {
      for (int i=0; i < numDistinctExprs; i++) {
        System.arraycopy(distributionKeys,0,cachedKeys[i],0,numDistributionKeys);
        Object[] distinctParameters=new Object[distinctColIndices.get(i).size()];
        for (int j=0; j < distinctParameters.length; j++) {
          distinctParameters[j]=keyEval[distinctColIndices.get(i).get(j)].evaluate(row);
        }
        cachedKeys[i][numDistributionKeys]=new StandardUnion((byte)i,distinctParameters);
      }
    }
 else {
      System.arraycopy(distributionKeys,0,cachedKeys[0],0,numDistributionKeys);
    }
    for (int i=0; i < cachedKeys.length; i++) {
      if (keyIsText) {
        Text key=(Text)keySerializer.serialize(cachedKeys[i],keyObjectInspector);
        if (tag == -1) {
          keyWritable.set(key.getBytes(),0,key.getLength());
        }
 else {
          int keyLength=key.getLength();
          if (!this.getConf().getNeedsOperationPathTagging()) {
            keyWritable.setSize(keyLength + 1);
          }
 else {
            keyWritable.setSize(keyLength + 2);
          }
          System.arraycopy(key.getBytes(),0,keyWritable.get(),0,keyLength);
          if (!this.getConf().getNeedsOperationPathTagging()) {
            keyWritable.get()[keyLength]=tagByte[0];
          }
 else {
            keyWritable.get()[keyLength]=operationPathTagsByte[0];
            keyWritable.get()[keyLength + 1]=tagByte[0];
          }
        }
      }
 else {
        BytesWritable key=(BytesWritable)keySerializer.serialize(cachedKeys[i],keyObjectInspector);
        if (tag == -1) {
          keyWritable.set(key.getBytes(),0,key.getLength());
        }
 else {
          int keyLength=key.getLength();
          if (!this.getConf().getNeedsOperationPathTagging()) {
            keyWritable.setSize(keyLength + 1);
          }
 else {
            keyWritable.setSize(keyLength + 2);
          }
          System.arraycopy(key.getBytes(),0,keyWritable.get(),0,keyLength);
          if (!this.getConf().getNeedsOperationPathTagging()) {
            keyWritable.get()[keyLength]=tagByte[0];
          }
 else {
            keyWritable.get()[keyLength]=operationPathTagsByte[0];
            keyWritable.get()[keyLength + 1]=tagByte[0];
          }
        }
      }
      keyWritable.setHashCode(keyHashCode);
      if (out != null) {
        out.collect(keyWritable,value);
        if (counterNameToEnum != null) {
          ++outputRows;
          if (outputRows % 1000 == 0) {
            incrCounter(numOutputRowsCntr,outputRows);
            outputRows=0;
          }
        }
      }
    }
  }
 catch (  SerDeException e) {
    throw new HiveException(e);
  }
catch (  IOException e) {
    throw new HiveException(e);
  }
}
