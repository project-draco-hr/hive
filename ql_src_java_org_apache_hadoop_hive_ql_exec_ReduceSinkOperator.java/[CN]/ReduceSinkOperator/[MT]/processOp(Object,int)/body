{
  try {
    ObjectInspector rowInspector=inputObjInspectors[tag];
    if (firstRow) {
      firstRow=false;
      keyObjectInspector=initEvaluatorsAndReturnStruct(keyEval,distinctColIndices,conf.getOutputKeyColumnNames(),numDistributionKeys,rowInspector);
      valueObjectInspector=initEvaluatorsAndReturnStruct(valueEval,conf.getOutputValueColumnNames(),rowInspector);
      partitionObjectInspectors=initEvaluators(partitionEval,rowInspector);
      int numKeys=numDistinctExprs > 0 ? numDistinctExprs : 1;
      int keyLen=numDistinctExprs > 0 ? numDistributionKeys + 1 : numDistributionKeys;
      cachedKeys=new Object[numKeys][keyLen];
      cachedValues=new Object[valueEval.length];
    }
    int keyHashCode=0;
    if (partitionEval.length == 0) {
      if (random == null) {
        random=new Random(12345);
      }
      keyHashCode=random.nextInt();
    }
 else {
      for (int i=0; i < partitionEval.length; i++) {
        Object o=partitionEval[i].evaluate(row);
        keyHashCode=keyHashCode * 31 + ObjectInspectorUtils.hashCode(o,partitionObjectInspectors[i]);
      }
    }
    for (int i=0; i < valueEval.length; i++) {
      cachedValues[i]=valueEval[i].evaluate(row);
    }
    for (int i=0; i < numDistributionKeys; i++) {
      cachedKeys[0][i]=keyEval[i].evaluate(row);
    }
    if (numDistinctExprs > 0) {
      for (int i=0; i < numDistinctExprs; i++) {
        if (i > 0) {
          System.arraycopy(cachedKeys[0],0,cachedKeys[i],0,numDistributionKeys);
        }
        StandardUnion union=(StandardUnion)cachedKeys[i][numDistributionKeys];
        if (union == null) {
          cachedKeys[i][numDistributionKeys]=union=new StandardUnion((byte)i,new Object[distinctColIndices.get(i).size()]);
        }
        Object[] distinctParameters=(Object[])union.getObject();
        for (int j=0; j < distinctParameters.length; j++) {
          distinctParameters[j]=keyEval[distinctColIndices.get(i).get(j)].evaluate(row);
        }
        union.setTag((byte)i);
      }
    }
    BytesWritable value=null;
    for (int i=0; i < cachedKeys.length; i++) {
      if (keyIsText) {
        Text key=(Text)keySerializer.serialize(cachedKeys[i],keyObjectInspector);
        if (tag == -1) {
          keyWritable.set(key.getBytes(),0,key.getLength());
        }
 else {
          int keyLength=key.getLength();
          keyWritable.setSize(keyLength + 1);
          System.arraycopy(key.getBytes(),0,keyWritable.get(),0,keyLength);
          keyWritable.get()[keyLength]=tagByte[0];
        }
      }
 else {
        BytesWritable key=(BytesWritable)keySerializer.serialize(cachedKeys[i],keyObjectInspector);
        if (tag == -1) {
          keyWritable.set(key.getBytes(),0,key.getLength());
        }
 else {
          int keyLength=key.getLength();
          keyWritable.setSize(keyLength + 1);
          System.arraycopy(key.getBytes(),0,keyWritable.get(),0,keyLength);
          keyWritable.get()[keyLength]=tagByte[0];
        }
      }
      keyWritable.setHashCode(keyHashCode);
      if (reducerHash == null) {
        if (null != out) {
          collect(keyWritable,value=getValue(row,value));
        }
      }
 else {
        int index=reducerHash.indexOf(keyWritable);
        if (index == TopNHash.EXCLUDED) {
          continue;
        }
        value=getValue(row,value);
        if (index >= 0) {
          reducerHash.set(index,value);
        }
 else {
          if (index == TopNHash.FORWARD) {
            collect(keyWritable,value);
          }
 else           if (index == TopNHash.FLUSH) {
            LOG.info("Top-N hash is flushed");
            reducerHash.flush();
            collect(keyWritable,value);
          }
 else           if (index == TopNHash.DISABLE) {
            LOG.info("Top-N hash is disabled");
            reducerHash.flush();
            collect(keyWritable,value);
            reducerHash=null;
          }
        }
      }
    }
  }
 catch (  HiveException e) {
    throw e;
  }
catch (  Exception e) {
    throw new HiveException(e);
  }
}
