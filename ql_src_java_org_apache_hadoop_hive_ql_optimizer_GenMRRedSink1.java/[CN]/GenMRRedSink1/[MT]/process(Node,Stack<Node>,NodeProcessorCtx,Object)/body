{
  ReduceSinkOperator op=(ReduceSinkOperator)nd;
  GenMRProcContext ctx=(GenMRProcContext)opProcCtx;
  Map<Operator<? extends OperatorDesc>,GenMapRedCtx> mapCurrCtx=ctx.getMapCurrCtx();
  GenMapRedCtx mapredCtx=mapCurrCtx.get(stack.get(stack.size() - 2));
  Task<? extends Serializable> currTask=mapredCtx.getCurrTask();
  MapredWork currPlan=(MapredWork)currTask.getWork();
  String currAliasId=mapredCtx.getCurrAliasId();
  if (op.getNumChild() != 1) {
    throw new IllegalStateException("Expecting operator " + op + " to have one child. "+ "But found multiple children : "+ op.getChildOperators());
  }
  Operator<? extends OperatorDesc> reducer=op.getChildOperators().get(0);
  Task<? extends Serializable> oldTask=ctx.getOpTaskMap().get(reducer);
  ctx.setCurrAliasId(currAliasId);
  ctx.setCurrTask(currTask);
  if (oldTask == null) {
    if (currPlan.getReducer() == null) {
      GenMapRedUtils.initPlan(op,ctx);
    }
 else {
      GenMapRedUtils.splitPlan(op,ctx);
    }
  }
 else {
    GenMapRedUtils.joinPlan(currTask,oldTask,ctx);
    currTask=oldTask;
    ctx.setCurrTask(currTask);
  }
  mapCurrCtx.put(op,new GenMapRedCtx(ctx.getCurrTask(),ctx.getCurrAliasId()));
  if (GenMapRedUtils.hasBranchFinished(nodeOutputs)) {
    ctx.addRootIfPossible(currTask);
    return false;
  }
  return true;
}
