{
  int[] skippedColumns=new int[allColumnsNumber - 2];
  for (int i=0; i < skippedColumns.length; i++) {
    skippedColumns[i]=i + 1;
  }
  byte[][] checkBytes=null;
  BytesRefArrayWritable checkRow=new BytesRefArrayWritable(allColumnsNumber);
  if (chechCorrect) {
    this.resetRandomGenerators();
    checkBytes=new byte[allColumnsNumber][];
  }
  int actualReadCount=0;
  RCFile.setSkipColumnIDs(conf,skippedColumns);
  RCFile.Reader reader=new RCFile.Reader(fs,file,conf);
  LongWritable rowID=new LongWritable();
  BytesRefArrayWritable cols=new BytesRefArrayWritable();
  while (reader.next(rowID)) {
    reader.getCurrentRow(cols);
    boolean ok=true;
    if (chechCorrect) {
      this.nextRandomRow(checkBytes,checkRow);
      ok=ok && (checkRow.get(0).equals(cols.get(0)));
      ok=ok && checkRow.get(allColumnsNumber - 1).equals(cols.get(allColumnsNumber - 1));
    }
    if (!ok)     throw new IllegalStateException("Compare read and write error.");
    actualReadCount++;
  }
  return actualReadCount;
}
