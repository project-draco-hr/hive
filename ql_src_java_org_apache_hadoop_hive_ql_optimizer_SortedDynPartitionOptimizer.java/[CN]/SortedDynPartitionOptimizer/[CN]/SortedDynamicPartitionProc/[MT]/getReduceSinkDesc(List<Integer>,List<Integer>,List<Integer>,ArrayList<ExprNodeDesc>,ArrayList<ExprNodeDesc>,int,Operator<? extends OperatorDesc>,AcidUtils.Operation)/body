{
  List<Integer> keyColsPosInVal=Lists.newArrayList();
  ArrayList<ExprNodeDesc> newKeyCols=Lists.newArrayList();
  List<Integer> newSortOrder=Lists.newArrayList();
  int numPartAndBuck=partitionPositions.size();
  keyColsPosInVal.addAll(partitionPositions);
  if (!bucketColumns.isEmpty()) {
    keyColsPosInVal.add(-1);
    numPartAndBuck+=1;
  }
  keyColsPosInVal.addAll(sortPositions);
  Integer order=1;
  if (sortOrder != null && !sortOrder.isEmpty()) {
    if (sortOrder.get(0).intValue() == 0) {
      order=0;
    }
  }
  for (int i=0; i < numPartAndBuck; i++) {
    newSortOrder.add(order);
  }
  newSortOrder.addAll(sortOrder);
  String orderStr="";
  for (  Integer i : newSortOrder) {
    if (i.intValue() == 1) {
      orderStr+="+";
    }
 else {
      orderStr+="-";
    }
  }
  ArrayList<ExprNodeDesc> newPartCols=Lists.newArrayList();
  for (  Integer idx : keyColsPosInVal) {
    if (idx < 0) {
      ExprNodeConstantDesc encd=new ExprNodeConstantDesc(TypeInfoFactory.stringTypeInfo,BUCKET_NUMBER_COL_NAME);
      newKeyCols.add(encd);
      newValueCols.add(encd);
    }
 else {
      newKeyCols.add(newValueCols.get(idx).clone());
    }
  }
  for (  Integer idx : partitionPositions) {
    newPartCols.add(newValueCols.get(idx).clone());
  }
  ReduceSinkOperator parentRSOp=OperatorUtils.findSingleOperatorUpstream(parent,ReduceSinkOperator.class);
  if (parentRSOp != null && parseCtx.getQueryProperties().hasOuterOrderBy()) {
    String parentRSOpOrder=parentRSOp.getConf().getOrder();
    if (parentRSOpOrder != null && !parentRSOpOrder.isEmpty() && sortPositions.isEmpty()) {
      newKeyCols.addAll(parentRSOp.getConf().getKeyCols());
      orderStr+=parentRSOpOrder;
    }
  }
  List<FieldSchema> fields=PlanUtils.getFieldSchemasFromColumnList(newKeyCols,"reducesinkkey");
  TableDesc keyTable=PlanUtils.getReduceKeyTableDesc(fields,orderStr);
  ArrayList<String> outputKeyCols=Lists.newArrayList();
  for (int i=0; i < newKeyCols.size(); i++) {
    outputKeyCols.add("reducesinkkey" + i);
  }
  List<String> outCols=Utilities.getInternalColumnNamesFromSignature(parent.getSchema().getSignature());
  ArrayList<String> outValColNames=Lists.newArrayList(outCols);
  if (!bucketColumns.isEmpty()) {
    outValColNames.add(BUCKET_NUMBER_COL_NAME);
  }
  List<FieldSchema> valFields=PlanUtils.getFieldSchemasFromColumnList(newValueCols,outValColNames,0,"");
  TableDesc valueTable=PlanUtils.getReduceValueTableDesc(valFields);
  List<List<Integer>> distinctColumnIndices=Lists.newArrayList();
  ReduceSinkDesc rsConf=new ReduceSinkDesc(newKeyCols,newKeyCols.size(),newValueCols,outputKeyCols,distinctColumnIndices,outValColNames,-1,newPartCols,-1,keyTable,valueTable,writeType);
  rsConf.setBucketCols(bucketColumns);
  rsConf.setNumBuckets(numBuckets);
  return rsConf;
}
