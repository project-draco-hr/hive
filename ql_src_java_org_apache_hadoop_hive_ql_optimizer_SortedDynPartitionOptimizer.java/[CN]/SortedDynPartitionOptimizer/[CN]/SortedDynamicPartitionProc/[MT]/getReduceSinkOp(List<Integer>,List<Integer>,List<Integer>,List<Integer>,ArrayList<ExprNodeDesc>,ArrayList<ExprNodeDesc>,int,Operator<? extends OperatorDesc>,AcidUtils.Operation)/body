{
  Set<Integer> keyColsPosInVal=Sets.newLinkedHashSet();
  ArrayList<ExprNodeDesc> keyCols=Lists.newArrayList();
  List<Integer> newSortOrder=Lists.newArrayList();
  List<Integer> newSortNullOrder=Lists.newArrayList();
  int numPartAndBuck=partitionPositions.size();
  keyColsPosInVal.addAll(partitionPositions);
  if (!bucketColumns.isEmpty()) {
    keyColsPosInVal.add(-1);
    numPartAndBuck+=1;
  }
  keyColsPosInVal.addAll(sortPositions);
  Integer order=1;
  if (sortOrder != null && !sortOrder.isEmpty()) {
    if (sortOrder.get(0).intValue() == 0) {
      order=0;
    }
  }
  for (int i=0; i < numPartAndBuck; i++) {
    newSortOrder.add(order);
  }
  newSortOrder.addAll(sortOrder);
  String orderStr="";
  for (  Integer i : newSortOrder) {
    if (i.intValue() == 1) {
      orderStr+="+";
    }
 else {
      orderStr+="-";
    }
  }
  Integer nullOrder=order == 1 ? 0 : 1;
  if (sortNullOrder != null && !sortNullOrder.isEmpty()) {
    if (sortNullOrder.get(0).intValue() == 0) {
      nullOrder=0;
    }
 else {
      nullOrder=1;
    }
  }
  for (int i=0; i < numPartAndBuck; i++) {
    newSortNullOrder.add(nullOrder);
  }
  newSortNullOrder.addAll(sortNullOrder);
  String nullOrderStr="";
  for (  Integer i : newSortNullOrder) {
    if (i.intValue() == 0) {
      nullOrderStr+="a";
    }
 else {
      nullOrderStr+="z";
    }
  }
  Map<String,ExprNodeDesc> colExprMap=Maps.newHashMap();
  ArrayList<ExprNodeDesc> partCols=Lists.newArrayList();
  for (  Integer idx : keyColsPosInVal) {
    if (idx < 0) {
      ExprNodeConstantDesc bucketNumCol=new ExprNodeConstantDesc(TypeInfoFactory.stringTypeInfo,BUCKET_NUMBER_COL_NAME);
      keyCols.add(bucketNumCol);
      colExprMap.put(Utilities.ReduceField.KEY + ".'" + BUCKET_NUMBER_COL_NAME+ "'",bucketNumCol);
    }
 else {
      keyCols.add(allCols.get(idx).clone());
    }
  }
  ArrayList<ExprNodeDesc> valCols=Lists.newArrayList();
  for (int i=0; i < allCols.size(); i++) {
    if (!keyColsPosInVal.contains(i)) {
      valCols.add(allCols.get(i).clone());
    }
  }
  for (  Integer idx : partitionPositions) {
    partCols.add(allCols.get(idx).clone());
  }
  ReduceSinkOperator parentRSOp=OperatorUtils.findSingleOperatorUpstream(parent,ReduceSinkOperator.class);
  if (parentRSOp != null && parseCtx.getQueryProperties().hasOuterOrderBy()) {
    String parentRSOpOrder=parentRSOp.getConf().getOrder();
    String parentRSOpNullOrder=parentRSOp.getConf().getNullOrder();
    if (parentRSOpOrder != null && !parentRSOpOrder.isEmpty() && sortPositions.isEmpty()) {
      keyCols.addAll(parentRSOp.getConf().getKeyCols());
      orderStr+=parentRSOpOrder;
      nullOrderStr+=parentRSOpNullOrder;
    }
  }
  Map<String,String> nameMapping=new HashMap<>();
  ArrayList<String> keyColNames=Lists.newArrayList();
  for (  ExprNodeDesc keyCol : keyCols) {
    String keyColName=keyCol.getExprString();
    keyColNames.add(keyColName);
    colExprMap.put(Utilities.ReduceField.KEY + "." + keyColName,keyCol);
    nameMapping.put(keyColName,Utilities.ReduceField.KEY + "." + keyColName);
  }
  ArrayList<String> valColNames=Lists.newArrayList();
  for (  ExprNodeDesc valCol : valCols) {
    String colName=valCol.getExprString();
    valColNames.add(colName);
    colExprMap.put(Utilities.ReduceField.VALUE + "." + colName,valCol);
    nameMapping.put(colName,Utilities.ReduceField.VALUE + "." + colName);
  }
  List<FieldSchema> fields=PlanUtils.getFieldSchemasFromColumnList(keyCols,keyColNames,0,"");
  TableDesc keyTable=PlanUtils.getReduceKeyTableDesc(fields,orderStr,nullOrderStr);
  List<FieldSchema> valFields=PlanUtils.getFieldSchemasFromColumnList(valCols,valColNames,0,"");
  TableDesc valueTable=PlanUtils.getReduceValueTableDesc(valFields);
  List<List<Integer>> distinctColumnIndices=Lists.newArrayList();
  ReduceSinkDesc rsConf=new ReduceSinkDesc(keyCols,keyCols.size(),valCols,keyColNames,distinctColumnIndices,valColNames,-1,partCols,-1,keyTable,valueTable,writeType);
  rsConf.setBucketCols(bucketColumns);
  rsConf.setNumBuckets(numBuckets);
  ArrayList<ColumnInfo> signature=new ArrayList<>();
  for (int index=0; index < parent.getSchema().getSignature().size(); index++) {
    ColumnInfo colInfo=new ColumnInfo(parent.getSchema().getSignature().get(index));
    colInfo.setInternalName(nameMapping.get(colInfo.getInternalName()));
    signature.add(colInfo);
  }
  ReduceSinkOperator op=(ReduceSinkOperator)OperatorFactory.getAndMakeChild(rsConf,new RowSchema(signature),parent);
  op.setColumnExprMap(colExprMap);
  return op;
}
