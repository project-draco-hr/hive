{
  FileSinkOperator fsOp=(FileSinkOperator)nd;
  LOG.info("Sorted dynamic partitioning optimization kicked in..");
  if (fsOp.getConf().getDynPartCtx() == null) {
    LOG.debug("Bailing out of sort dynamic partition optimization as dynamic partitioning context is null");
    return null;
  }
  ListBucketingCtx lbCtx=fsOp.getConf().getLbCtx();
  if (lbCtx != null && !lbCtx.getSkewedColNames().isEmpty() && !lbCtx.getSkewedColValues().isEmpty()) {
    LOG.debug("Bailing out of sort dynamic partition optimization as list bucketing is enabled");
    return null;
  }
  Table destTable=fsOp.getConf().getTable();
  if (destTable == null) {
    LOG.debug("Bailing out of sort dynamic partition optimization as destination table is null");
    return null;
  }
  if (!removeRSInsertedByEnforceBucketing(fsOp)) {
    LOG.debug("Bailing out of sort dynamic partition optimization as some partition columns " + "got constant folded.");
    return null;
  }
  Operator<? extends OperatorDesc> fsParent=fsOp.getParentOperators().get(0);
  fsParent.getChildOperators().clear();
  DynamicPartitionCtx dpCtx=fsOp.getConf().getDynPartCtx();
  int numBuckets=destTable.getNumBuckets();
  dpCtx.setNumBuckets(numBuckets);
  List<Integer> bucketPositions=getBucketPositions(destTable.getBucketCols(),destTable.getCols());
  ObjectPair<List<Integer>,List<Integer>> sortOrderPositions=getSortPositionsOrder(destTable.getSortCols(),destTable.getCols());
  List<Integer> sortPositions=null;
  List<Integer> sortOrder=null;
  if (fsOp.getConf().getWriteType() == AcidUtils.Operation.UPDATE || fsOp.getConf().getWriteType() == AcidUtils.Operation.DELETE) {
    sortPositions=Arrays.asList(0);
    sortOrder=Arrays.asList(1);
  }
 else {
    sortPositions=sortOrderPositions.getFirst();
    sortOrder=sortOrderPositions.getSecond();
  }
  LOG.debug("Got sort order");
  for (  int i : sortPositions)   LOG.debug("sort position " + i);
  for (  int i : sortOrder)   LOG.debug("sort order " + i);
  List<Integer> partitionPositions=getPartitionPositions(dpCtx,fsParent.getSchema());
  List<ColumnInfo> colInfos=fsParent.getSchema().getSignature();
  ArrayList<ExprNodeDesc> bucketColumns=getPositionsToExprNodes(bucketPositions,colInfos);
  fsOp.getConf().setMultiFileSpray(false);
  fsOp.getConf().setNumFiles(1);
  fsOp.getConf().setTotalFiles(1);
  RowSchema outRS=new RowSchema(fsParent.getSchema());
  ArrayList<ColumnInfo> valColInfo=Lists.newArrayList(fsParent.getSchema().getSignature());
  ArrayList<ExprNodeDesc> newValueCols=Lists.newArrayList();
  Map<String,ExprNodeDesc> colExprMap=Maps.newHashMap();
  for (  ColumnInfo ci : valColInfo) {
    newValueCols.add(new ExprNodeColumnDesc(ci));
    colExprMap.put(ci.getInternalName(),newValueCols.get(newValueCols.size() - 1));
  }
  ReduceSinkDesc rsConf=getReduceSinkDesc(partitionPositions,sortPositions,sortOrder,newValueCols,bucketColumns,numBuckets,fsParent,fsOp.getConf().getWriteType());
  if (!bucketColumns.isEmpty()) {
    String tableAlias=outRS.getSignature().get(0).getTabAlias();
    ColumnInfo ci=new ColumnInfo(BUCKET_NUMBER_COL_NAME,TypeInfoFactory.stringTypeInfo,tableAlias,true,true);
    outRS.getSignature().add(ci);
  }
  ReduceSinkOperator rsOp=(ReduceSinkOperator)OperatorFactory.getAndMakeChild(rsConf,new RowSchema(outRS.getSignature()),fsParent);
  rsOp.setColumnExprMap(colExprMap);
  RowSchema exRR=new RowSchema(outRS);
  ExtractDesc exConf=new ExtractDesc(new ExprNodeColumnDesc(TypeInfoFactory.stringTypeInfo,Utilities.ReduceField.VALUE.toString(),"",false));
  ExtractOperator exOp=(ExtractOperator)OperatorFactory.getAndMakeChild(exConf,exRR,rsOp);
  fsOp.getParentOperators().clear();
  fsOp.getParentOperators().add(exOp);
  exOp.getChildOperators().add(fsOp);
  fsOp.getConf().setDpSortState(FileSinkDesc.DPSortState.PARTITION_SORTED);
  if (bucketColumns.size() > 0) {
    fsOp.getConf().setDpSortState(FileSinkDesc.DPSortState.PARTITION_BUCKET_SORTED);
  }
  ArrayList<ExprNodeDesc> partitionColumns=getPositionsToExprNodes(partitionPositions,rsOp.getSchema().getSignature());
  fsOp.getConf().setPartitionCols(partitionColumns);
  LOG.info("Inserted " + rsOp.getOperatorId() + " and "+ exOp.getOperatorId()+ " as parent of "+ fsOp.getOperatorId()+ " and child of "+ fsParent.getOperatorId());
  return null;
}
