{
  FileSinkOperator fsOp=(FileSinkOperator)nd;
  LOG.info("Sorted dynamic partitioning optimization kicked in..");
  if (fsOp.getConf().getDynPartCtx() == null) {
    LOG.debug("Bailing out of sort dynamic partition optimization as dynamic partitioning context is null");
    return null;
  }
  ListBucketingCtx lbCtx=fsOp.getConf().getLbCtx();
  if (lbCtx != null && !lbCtx.getSkewedColNames().isEmpty() && !lbCtx.getSkewedColValues().isEmpty()) {
    LOG.debug("Bailing out of sort dynamic partition optimization as list bucketing is enabled");
    return null;
  }
  Table destTable=fsOp.getConf().getTable();
  if (destTable == null) {
    LOG.debug("Bailing out of sort dynamic partition optimization as destination table is null");
    return null;
  }
  Operator<? extends OperatorDesc> fsParent=fsOp.getParentOperators().get(0);
  if (allStaticPartitions(fsParent,fsOp.getConf().getDynPartCtx())) {
    LOG.debug("Bailing out of sorted dynamic partition optimizer as all dynamic partition" + " columns got constant folded (static partitioning)");
    return null;
  }
  if (!removeRSInsertedByEnforceBucketing(fsOp)) {
    LOG.debug("Bailing out of sort dynamic partition optimization as some partition columns " + "got constant folded.");
    return null;
  }
  fsParent=fsOp.getParentOperators().get(0);
  fsParent.getChildOperators().clear();
  DynamicPartitionCtx dpCtx=fsOp.getConf().getDynPartCtx();
  int numBuckets=destTable.getNumBuckets();
  dpCtx.setNumBuckets(numBuckets);
  List<Integer> bucketPositions=getBucketPositions(destTable.getBucketCols(),destTable.getCols());
  ObjectPair<List<Integer>,List<Integer>> sortOrderPositions=getSortPositionsOrder(destTable.getSortCols(),destTable.getCols());
  List<Integer> sortPositions=null;
  List<Integer> sortOrder=null;
  if (fsOp.getConf().getWriteType() == AcidUtils.Operation.UPDATE || fsOp.getConf().getWriteType() == AcidUtils.Operation.DELETE) {
    sortPositions=Arrays.asList(0);
    sortOrder=Arrays.asList(1);
  }
 else {
    sortPositions=sortOrderPositions.getFirst();
    sortOrder=sortOrderPositions.getSecond();
  }
  LOG.debug("Got sort order");
  for (  int i : sortPositions)   LOG.debug("sort position " + i);
  for (  int i : sortOrder)   LOG.debug("sort order " + i);
  List<Integer> partitionPositions=getPartitionPositions(dpCtx,fsParent.getSchema());
  List<ColumnInfo> colInfos=fsParent.getSchema().getSignature();
  ArrayList<ExprNodeDesc> bucketColumns=getPositionsToExprNodes(bucketPositions,colInfos);
  fsOp.getConf().setMultiFileSpray(false);
  fsOp.getConf().setNumFiles(1);
  fsOp.getConf().setTotalFiles(1);
  RowSchema outRS=new RowSchema(fsParent.getSchema());
  ArrayList<ColumnInfo> valColInfo=Lists.newArrayList(fsParent.getSchema().getSignature());
  ArrayList<ExprNodeDesc> newValueCols=Lists.newArrayList();
  for (  ColumnInfo ci : valColInfo) {
    newValueCols.add(new ExprNodeColumnDesc(ci));
  }
  ReduceSinkDesc rsConf=getReduceSinkDesc(partitionPositions,sortPositions,sortOrder,newValueCols,bucketColumns,numBuckets,fsParent,fsOp.getConf().getWriteType());
  if (!bucketColumns.isEmpty()) {
    String tableAlias=outRS.getSignature().get(0).getTabAlias();
    ColumnInfo ci=new ColumnInfo(BUCKET_NUMBER_COL_NAME,TypeInfoFactory.stringTypeInfo,tableAlias,true,true);
    outRS.getSignature().add(ci);
  }
  ReduceSinkOperator rsOp=(ReduceSinkOperator)OperatorFactory.getAndMakeChild(rsConf,new RowSchema(outRS.getSignature()),fsParent);
  List<String> valueColNames=rsConf.getOutputValueColumnNames();
  Map<String,ExprNodeDesc> colExprMap=Maps.newHashMap();
  for (int i=0; i < valueColNames.size(); i++) {
    colExprMap.put(Utilities.ReduceField.VALUE + "." + valueColNames.get(i),newValueCols.get(i));
  }
  rsOp.setColumnExprMap(colExprMap);
  List<ExprNodeDesc> valCols=rsConf.getValueCols();
  List<ExprNodeDesc> descs=new ArrayList<ExprNodeDesc>(valCols.size());
  List<String> colNames=new ArrayList<String>();
  String colName;
  for (  ExprNodeDesc valCol : valCols) {
    colName=PlanUtils.stripQuotes(valCol.getExprString());
    colNames.add(colName);
    descs.add(new ExprNodeColumnDesc(valCol.getTypeInfo(),ReduceField.VALUE.toString() + "." + colName,null,false));
  }
  SelectDesc selConf=new SelectDesc(descs,colNames);
  RowSchema selRS=new RowSchema(outRS);
  SelectOperator selOp=(SelectOperator)OperatorFactory.getAndMakeChild(selConf,selRS,rsOp);
  fsOp.getParentOperators().clear();
  fsOp.getParentOperators().add(selOp);
  selOp.getChildOperators().add(fsOp);
  fsOp.getConf().setDpSortState(FileSinkDesc.DPSortState.PARTITION_SORTED);
  if (bucketColumns.size() > 0) {
    fsOp.getConf().setDpSortState(FileSinkDesc.DPSortState.PARTITION_BUCKET_SORTED);
  }
  ArrayList<ExprNodeDesc> partitionColumns=getPositionsToExprNodes(partitionPositions,rsOp.getSchema().getSignature());
  fsOp.getConf().setPartitionCols(partitionColumns);
  LOG.info("Inserted " + rsOp.getOperatorId() + " and "+ selOp.getOperatorId()+ " as parent of "+ fsOp.getOperatorId()+ " and child of "+ fsParent.getOperatorId());
  parseCtx.setReduceSinkAddedBySortedDynPartition(true);
  return null;
}
