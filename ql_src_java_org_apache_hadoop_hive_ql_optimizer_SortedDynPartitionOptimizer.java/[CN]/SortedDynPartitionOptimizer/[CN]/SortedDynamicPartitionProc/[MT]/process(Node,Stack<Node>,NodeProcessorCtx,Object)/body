{
  FileSinkOperator fsOp=(FileSinkOperator)nd;
  LOG.info("Sorted dynamic partitioning optimization kicked in..");
  if (fsOp.getConf().getDynPartCtx() == null) {
    LOG.debug("Bailing out of sort dynamic partition optimization as dynamic partitioning context is null");
    return null;
  }
  ListBucketingCtx lbCtx=fsOp.getConf().getLbCtx();
  if (lbCtx != null && !lbCtx.getSkewedColNames().isEmpty() && !lbCtx.getSkewedColValues().isEmpty()) {
    LOG.debug("Bailing out of sort dynamic partition optimization as list bucketing is enabled");
    return null;
  }
  Table destTable=fsOp.getConf().getTable();
  if (destTable == null) {
    LOG.debug("Bailing out of sort dynamic partition optimization as destination table is null");
    return null;
  }
  Operator<? extends OperatorDesc> fsParent=fsOp.getParentOperators().get(0);
  if (allStaticPartitions(fsParent,fsOp.getConf().getDynPartCtx())) {
    LOG.debug("Bailing out of sorted dynamic partition optimizer as all dynamic partition" + " columns got constant folded (static partitioning)");
    return null;
  }
  if (!removeRSInsertedByEnforceBucketing(fsOp)) {
    LOG.debug("Bailing out of sort dynamic partition optimization as some partition columns " + "got constant folded.");
    return null;
  }
  fsParent=fsOp.getParentOperators().get(0);
  fsParent.getChildOperators().clear();
  DynamicPartitionCtx dpCtx=fsOp.getConf().getDynPartCtx();
  int numBuckets=destTable.getNumBuckets();
  dpCtx.setNumBuckets(numBuckets);
  List<Integer> bucketPositions=getBucketPositions(destTable.getBucketCols(),destTable.getCols());
  List<Integer> sortPositions=null;
  List<Integer> sortOrder=null;
  if (fsOp.getConf().getWriteType() == AcidUtils.Operation.UPDATE || fsOp.getConf().getWriteType() == AcidUtils.Operation.DELETE) {
    sortPositions=Arrays.asList(0);
    sortOrder=Arrays.asList(1);
  }
 else {
    sortPositions=getSortPositions(destTable.getSortCols(),destTable.getCols());
    sortOrder=getSortOrders(destTable.getSortCols(),destTable.getCols());
  }
  List<Integer> sortNullOrder=new ArrayList<Integer>();
  for (  int order : sortOrder) {
    sortNullOrder.add(order == 1 ? 0 : 1);
  }
  LOG.debug("Got sort order");
  for (  int i : sortPositions)   LOG.debug("sort position " + i);
  for (  int i : sortOrder)   LOG.debug("sort order " + i);
  for (  int i : sortNullOrder)   LOG.debug("sort null order " + i);
  List<Integer> partitionPositions=getPartitionPositions(dpCtx,fsParent.getSchema());
  List<ColumnInfo> colInfos=fsParent.getSchema().getSignature();
  ArrayList<ExprNodeDesc> bucketColumns=getPositionsToExprNodes(bucketPositions,colInfos);
  fsOp.getConf().setMultiFileSpray(false);
  fsOp.getConf().setNumFiles(1);
  fsOp.getConf().setTotalFiles(1);
  ArrayList<ColumnInfo> parentCols=Lists.newArrayList(fsParent.getSchema().getSignature());
  ArrayList<ExprNodeDesc> allRSCols=Lists.newArrayList();
  for (  ColumnInfo ci : parentCols) {
    allRSCols.add(new ExprNodeColumnDesc(ci));
  }
  ReduceSinkOperator rsOp=getReduceSinkOp(partitionPositions,sortPositions,sortOrder,sortNullOrder,allRSCols,bucketColumns,numBuckets,fsParent,fsOp.getConf().getWriteType());
  List<ExprNodeDesc> descs=new ArrayList<ExprNodeDesc>(allRSCols.size());
  List<String> colNames=new ArrayList<String>();
  String colName;
  for (int i=0; i < allRSCols.size(); i++) {
    ExprNodeDesc col=allRSCols.get(i);
    colName=col.getExprString();
    colNames.add(colName);
    if (partitionPositions.contains(i) || sortPositions.contains(i)) {
      descs.add(new ExprNodeColumnDesc(col.getTypeInfo(),ReduceField.KEY.toString() + "." + colName,null,false));
    }
 else {
      descs.add(new ExprNodeColumnDesc(col.getTypeInfo(),ReduceField.VALUE.toString() + "." + colName,null,false));
    }
  }
  RowSchema selRS=new RowSchema(fsParent.getSchema());
  if (!bucketColumns.isEmpty()) {
    descs.add(new ExprNodeColumnDesc(TypeInfoFactory.stringTypeInfo,ReduceField.KEY.toString() + ".'" + BUCKET_NUMBER_COL_NAME+ "'",null,false));
    colNames.add("'" + BUCKET_NUMBER_COL_NAME + "'");
    ColumnInfo ci=new ColumnInfo(BUCKET_NUMBER_COL_NAME,TypeInfoFactory.stringTypeInfo,selRS.getSignature().get(0).getTabAlias(),true,true);
    selRS.getSignature().add(ci);
    fsParent.getSchema().getSignature().add(ci);
  }
  SelectDesc selConf=new SelectDesc(descs,colNames);
  SelectOperator selOp=(SelectOperator)OperatorFactory.getAndMakeChild(selConf,selRS,rsOp);
  fsOp.getParentOperators().clear();
  fsOp.getParentOperators().add(selOp);
  selOp.getChildOperators().add(fsOp);
  fsOp.getConf().setDpSortState(FileSinkDesc.DPSortState.PARTITION_SORTED);
  if (bucketColumns.size() > 0) {
    fsOp.getConf().setDpSortState(FileSinkDesc.DPSortState.PARTITION_BUCKET_SORTED);
  }
  fsOp.getConf().setPartitionCols(rsOp.getConf().getPartitionCols());
  LOG.info("Inserted " + rsOp.getOperatorId() + " and "+ selOp.getOperatorId()+ " as parent of "+ fsOp.getOperatorId()+ " and child of "+ fsParent.getOperatorId());
  parseCtx.setReduceSinkAddedBySortedDynPartition(true);
  return null;
}
