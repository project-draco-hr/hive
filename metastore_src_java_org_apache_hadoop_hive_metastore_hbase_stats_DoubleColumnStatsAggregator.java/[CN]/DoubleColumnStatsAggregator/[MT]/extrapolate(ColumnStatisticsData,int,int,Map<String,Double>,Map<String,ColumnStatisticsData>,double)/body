{
  int rightBorderInd=numParts;
  DoubleColumnStatsData extrapolateDoubleData=new DoubleColumnStatsData();
  Map<String,DoubleColumnStatsData> extractedAdjustedStatsMap=new HashMap<>();
  for (  Map.Entry<String,ColumnStatisticsData> entry : adjustedStatsMap.entrySet()) {
    extractedAdjustedStatsMap.put(entry.getKey(),entry.getValue().getDoubleStats());
  }
  List<Map.Entry<String,DoubleColumnStatsData>> list=new LinkedList<Map.Entry<String,DoubleColumnStatsData>>(extractedAdjustedStatsMap.entrySet());
  Collections.sort(list,new Comparator<Map.Entry<String,DoubleColumnStatsData>>(){
    public int compare(    Map.Entry<String,DoubleColumnStatsData> o1,    Map.Entry<String,DoubleColumnStatsData> o2){
      return o1.getValue().getLowValue() < o2.getValue().getLowValue() ? -1 : 1;
    }
  }
);
  double minInd=adjustedIndexMap.get(list.get(0).getKey());
  double maxInd=adjustedIndexMap.get(list.get(list.size() - 1).getKey());
  double lowValue=0;
  double min=list.get(0).getValue().getLowValue();
  double max=list.get(list.size() - 1).getValue().getLowValue();
  if (minInd == maxInd) {
    lowValue=min;
  }
 else   if (minInd < maxInd) {
    lowValue=(max - (max - min) * maxInd / (maxInd - minInd));
  }
 else {
    lowValue=(max - (max - min) * (rightBorderInd - maxInd) / (minInd - maxInd));
  }
  Collections.sort(list,new Comparator<Map.Entry<String,DoubleColumnStatsData>>(){
    public int compare(    Map.Entry<String,DoubleColumnStatsData> o1,    Map.Entry<String,DoubleColumnStatsData> o2){
      return o1.getValue().getHighValue() < o2.getValue().getHighValue() ? -1 : 1;
    }
  }
);
  minInd=adjustedIndexMap.get(list.get(0).getKey());
  maxInd=adjustedIndexMap.get(list.get(list.size() - 1).getKey());
  double highValue=0;
  min=list.get(0).getValue().getHighValue();
  max=list.get(list.size() - 1).getValue().getHighValue();
  if (minInd == maxInd) {
    highValue=min;
  }
 else   if (minInd < maxInd) {
    highValue=(min + (max - min) * (rightBorderInd - minInd) / (maxInd - minInd));
  }
 else {
    highValue=(min + (max - min) * minInd / (minInd - maxInd));
  }
  long numNulls=0;
  for (  Map.Entry<String,DoubleColumnStatsData> entry : extractedAdjustedStatsMap.entrySet()) {
    numNulls+=entry.getValue().getNumNulls();
  }
  numNulls=numNulls * numParts / numPartsWithStats;
  long ndv=0;
  long ndvMin=0;
  long ndvMax=0;
  Collections.sort(list,new Comparator<Map.Entry<String,DoubleColumnStatsData>>(){
    public int compare(    Map.Entry<String,DoubleColumnStatsData> o1,    Map.Entry<String,DoubleColumnStatsData> o2){
      return o1.getValue().getNumDVs() < o2.getValue().getNumDVs() ? -1 : 1;
    }
  }
);
  long lowerBound=list.get(list.size() - 1).getValue().getNumDVs();
  long higherBound=0;
  for (  Map.Entry<String,DoubleColumnStatsData> entry : list) {
    higherBound+=entry.getValue().getNumDVs();
  }
  if (useDensityFunctionForNDVEstimation && densityAvg != 0.0) {
    ndv=(long)((highValue - lowValue) / densityAvg);
    if (ndv < lowerBound) {
      ndv=lowerBound;
    }
 else     if (ndv > higherBound) {
      ndv=higherBound;
    }
  }
 else {
    minInd=adjustedIndexMap.get(list.get(0).getKey());
    maxInd=adjustedIndexMap.get(list.get(list.size() - 1).getKey());
    ndvMin=list.get(0).getValue().getNumDVs();
    ndvMax=list.get(list.size() - 1).getValue().getNumDVs();
    if (minInd == maxInd) {
      ndv=ndvMin;
    }
 else     if (minInd < maxInd) {
      ndv=(long)(ndvMin + (ndvMax - ndvMin) * (rightBorderInd - minInd) / (maxInd - minInd));
    }
 else {
      ndv=(long)(ndvMin + (ndvMax - ndvMin) * minInd / (minInd - maxInd));
    }
  }
  extrapolateDoubleData.setLowValue(lowValue);
  extrapolateDoubleData.setHighValue(highValue);
  extrapolateDoubleData.setNumNulls(numNulls);
  extrapolateDoubleData.setNumDVs(ndv);
  extrapolateData.setDoubleStats(extrapolateDoubleData);
}
