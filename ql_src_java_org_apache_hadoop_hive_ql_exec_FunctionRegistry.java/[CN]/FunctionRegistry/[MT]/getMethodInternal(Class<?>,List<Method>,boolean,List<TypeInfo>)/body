{
  List<Method> udfMethods=new ArrayList<Method>();
  int leastConversionCost=Integer.MAX_VALUE;
  for (  Method m : mlist) {
    List<TypeInfo> argumentsAccepted=TypeInfoUtils.getParameterTypeInfos(m,argumentsPassed.size());
    if (argumentsAccepted == null) {
      continue;
    }
    boolean match=(argumentsAccepted.size() == argumentsPassed.size());
    int conversionCost=0;
    for (int i=0; i < argumentsPassed.size() && match; i++) {
      int cost=matchCost(argumentsPassed.get(i),argumentsAccepted.get(i),exact);
      if (cost == -1) {
        match=false;
      }
 else {
        conversionCost+=cost;
      }
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("Method " + (match ? "did" : "didn't") + " match: passed = "+ argumentsPassed+ " accepted = "+ argumentsAccepted+ " method = "+ m);
    }
    if (match) {
      if (conversionCost < leastConversionCost) {
        udfMethods.clear();
        udfMethods.add(m);
        leastConversionCost=conversionCost;
        if (leastConversionCost == 0) {
          break;
        }
      }
 else       if (conversionCost == leastConversionCost) {
        udfMethods.add(m);
      }
 else {
      }
    }
  }
  if (udfMethods.size() == 0) {
    throw new NoMatchingMethodException(udfClass,argumentsPassed,mlist);
  }
  if (udfMethods.size() > 1) {
    filterMethodsByTypeAffinity(udfMethods,argumentsPassed);
  }
  if (udfMethods.size() > 1) {
    int lowestNumericType=Integer.MAX_VALUE;
    boolean multiple=true;
    Method candidate=null;
    List<TypeInfo> referenceArguments=null;
    for (    Method m : udfMethods) {
      int maxNumericType=0;
      List<TypeInfo> argumentsAccepted=TypeInfoUtils.getParameterTypeInfos(m,argumentsPassed.size());
      if (referenceArguments == null) {
        referenceArguments=argumentsAccepted;
      }
      Iterator<TypeInfo> referenceIterator=referenceArguments.iterator();
      for (      TypeInfo accepted : argumentsAccepted) {
        TypeInfo reference=referenceIterator.next();
        boolean acceptedIsPrimitive=false;
        PrimitiveCategory acceptedPrimCat=PrimitiveCategory.UNKNOWN;
        if (accepted.getCategory() == Category.PRIMITIVE) {
          acceptedIsPrimitive=true;
          acceptedPrimCat=((PrimitiveTypeInfo)accepted).getPrimitiveCategory();
        }
        if (acceptedIsPrimitive && TypeInfoUtils.numericTypes.containsKey(acceptedPrimCat)) {
          int typeValue=TypeInfoUtils.numericTypes.get(acceptedPrimCat);
          maxNumericType=typeValue > maxNumericType ? typeValue : maxNumericType;
        }
 else         if (!accepted.equals(reference)) {
          throw new AmbiguousMethodException(udfClass,argumentsPassed,mlist);
        }
      }
      if (lowestNumericType > maxNumericType) {
        multiple=false;
        lowestNumericType=maxNumericType;
        candidate=m;
      }
 else       if (maxNumericType == lowestNumericType) {
        multiple=true;
      }
    }
    if (!multiple) {
      return candidate;
    }
 else {
      throw new AmbiguousMethodException(udfClass,argumentsPassed,mlist);
    }
  }
  return udfMethods.get(0);
}
