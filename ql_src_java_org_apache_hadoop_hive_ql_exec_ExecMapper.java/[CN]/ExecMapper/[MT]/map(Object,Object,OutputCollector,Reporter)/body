{
  if (oc == null) {
    oc=output;
    rp=reporter;
    mo.setOutputCollector(oc);
    mo.setReporter(rp);
    if (fetchOperators != null) {
      try {
        mapredLocalWork localWork=mo.getConf().getMapLocalWork();
        int fetchOpNum=0;
        for (        Map.Entry<String,FetchOperator> entry : fetchOperators.entrySet()) {
          int fetchOpRows=0;
          String alias=entry.getKey();
          FetchOperator fetchOp=entry.getValue();
          Operator<? extends Serializable> forwardOp=localWork.getAliasToWork().get(alias);
          while (true) {
            InspectableObject row=fetchOp.getNextRow();
            if (row == null) {
              forwardOp.close(false);
              break;
            }
            fetchOpRows++;
            forwardOp.process(row.o,0);
            if (forwardOp.getDone()) {
              done=true;
              break;
            }
          }
          if (l4j.isInfoEnabled()) {
            l4j.info("fetch " + fetchOpNum++ + " processed "+ fetchOpRows+ " used mem: "+ memoryMXBean.getHeapMemoryUsage().getUsed());
          }
        }
      }
 catch (      Throwable e) {
        abort=true;
        if (e instanceof OutOfMemoryError) {
          throw (OutOfMemoryError)e;
        }
 else {
          throw new RuntimeException("Map local work failed",e);
        }
      }
    }
  }
  try {
    if (mo.getDone())     done=true;
 else {
      mo.process((Writable)value);
      if (l4j.isInfoEnabled()) {
        numRows++;
        if (numRows == nextCntr) {
          long used_memory=memoryMXBean.getHeapMemoryUsage().getUsed();
          l4j.info("ExecMapper: processing " + numRows + " rows: used memory = "+ used_memory);
          nextCntr=getNextCntr(numRows);
        }
      }
    }
  }
 catch (  Throwable e) {
    abort=true;
    e.printStackTrace();
    if (e instanceof OutOfMemoryError) {
      throw (OutOfMemoryError)e;
    }
 else {
      throw new RuntimeException(e.getMessage(),e);
    }
  }
}
