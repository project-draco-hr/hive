{
  memoryMXBean=ManagementFactory.getMemoryMXBean();
  l4j.info("maximum memory = " + memoryMXBean.getHeapMemoryUsage().getMax());
  isLogInfoEnabled=l4j.isInfoEnabled();
  try {
    l4j.info("conf classpath = " + Arrays.asList(((URLClassLoader)job.getClassLoader()).getURLs()));
    l4j.info("thread classpath = " + Arrays.asList(((URLClassLoader)Thread.currentThread().getContextClassLoader()).getURLs()));
  }
 catch (  Exception e) {
    l4j.info("cannot get classpath: " + e.getMessage());
  }
  try {
    jc=job;
    execContext.setJc(jc);
    MapredWork mrwork=Utilities.getMapRedWork(job);
    mo=new MapOperator();
    mo.setConf(mrwork);
    mo.setChildren(job);
    l4j.info(mo.dump(0));
    mo.setExecContext(execContext);
    mo.initializeLocalWork(jc);
    mo.initialize(jc,null);
    localWork=mrwork.getMapLocalWork();
    if (localWork == null) {
      return;
    }
    fetchOperators=new HashMap<String,FetchOperator>();
    Map<FetchOperator,JobConf> fetchOpJobConfMap=new HashMap<FetchOperator,JobConf>();
    for (    Map.Entry<String,FetchWork> entry : localWork.getAliasToFetchWork().entrySet()) {
      JobConf jobClone=new JobConf(job);
      Operator<? extends Serializable> tableScan=localWork.getAliasToWork().get(entry.getKey());
      boolean setColumnsNeeded=false;
      if (tableScan instanceof TableScanOperator) {
        ArrayList<Integer> list=((TableScanOperator)tableScan).getNeededColumnIDs();
        if (list != null) {
          ColumnProjectionUtils.appendReadColumnIDs(jobClone,list);
          setColumnsNeeded=true;
        }
      }
      if (!setColumnsNeeded) {
        ColumnProjectionUtils.setFullyReadColumns(jobClone);
      }
      FetchOperator fetchOp=new FetchOperator(entry.getValue(),jobClone);
      fetchOpJobConfMap.put(fetchOp,jobClone);
      fetchOperators.put(entry.getKey(),fetchOp);
      l4j.info("fetchoperator for " + entry.getKey() + " created");
    }
    for (    Map.Entry<String,FetchOperator> entry : fetchOperators.entrySet()) {
      Operator<? extends Serializable> forwardOp=localWork.getAliasToWork().get(entry.getKey());
      forwardOp.setExecContext(execContext);
      FetchOperator fetchOp=entry.getValue();
      JobConf jobConf=fetchOpJobConfMap.get(fetchOp);
      if (jobConf == null) {
        jobConf=job;
      }
      forwardOp.initialize(jobConf,new ObjectInspector[]{fetchOp.getOutputObjectInspector()});
      l4j.info("fetchoperator for " + entry.getKey() + " initialized");
    }
    this.execContext.setLocalWork(localWork);
    this.execContext.setFetchOperators(fetchOperators);
  }
 catch (  Throwable e) {
    abort=true;
    if (e instanceof OutOfMemoryError) {
      throw (OutOfMemoryError)e;
    }
 else {
      throw new RuntimeException("Map operator initialization failed",e);
    }
  }
}
