{
  RelDataType lType=literal.getType();
switch (literal.getType().getSqlTypeName()) {
case BOOLEAN:
    return new ExprNodeConstantDesc(TypeInfoFactory.booleanTypeInfo,Boolean.valueOf(RexLiteral.booleanValue(literal)));
case TINYINT:
  return new ExprNodeConstantDesc(TypeInfoFactory.byteTypeInfo,Byte.valueOf(((Number)literal.getValue3()).byteValue()));
case SMALLINT:
return new ExprNodeConstantDesc(TypeInfoFactory.shortTypeInfo,Short.valueOf(((Number)literal.getValue3()).shortValue()));
case INTEGER:
return new ExprNodeConstantDesc(TypeInfoFactory.intTypeInfo,Integer.valueOf(((Number)literal.getValue3()).intValue()));
case BIGINT:
return new ExprNodeConstantDesc(TypeInfoFactory.longTypeInfo,Long.valueOf(((Number)literal.getValue3()).longValue()));
case FLOAT:
return new ExprNodeConstantDesc(TypeInfoFactory.floatTypeInfo,Float.valueOf(((Number)literal.getValue3()).floatValue()));
case DOUBLE:
return new ExprNodeConstantDesc(TypeInfoFactory.doubleTypeInfo,Double.valueOf(((Number)literal.getValue3()).doubleValue()));
case DATE:
return new ExprNodeConstantDesc(TypeInfoFactory.dateTypeInfo,new Date(((Calendar)literal.getValue()).getTimeInMillis()));
case TIMESTAMP:
{
Object value=literal.getValue3();
if (value instanceof Long) {
value=new Timestamp((Long)value);
}
return new ExprNodeConstantDesc(TypeInfoFactory.timestampTypeInfo,value);
}
case BINARY:
return new ExprNodeConstantDesc(TypeInfoFactory.binaryTypeInfo,literal.getValue3());
case DECIMAL:
return new ExprNodeConstantDesc(TypeInfoFactory.getDecimalTypeInfo(lType.getPrecision(),lType.getScale()),literal.getValue3());
case VARCHAR:
return new ExprNodeConstantDesc(TypeInfoFactory.getVarcharTypeInfo(lType.getPrecision()),new HiveVarchar((String)literal.getValue3(),lType.getPrecision()));
case CHAR:
return new ExprNodeConstantDesc(TypeInfoFactory.getCharTypeInfo(lType.getPrecision()),new HiveChar((String)literal.getValue3(),lType.getPrecision()));
case OTHER:
default :
return new ExprNodeConstantDesc(TypeInfoFactory.voidTypeInfo,literal.getValue3());
}
}
