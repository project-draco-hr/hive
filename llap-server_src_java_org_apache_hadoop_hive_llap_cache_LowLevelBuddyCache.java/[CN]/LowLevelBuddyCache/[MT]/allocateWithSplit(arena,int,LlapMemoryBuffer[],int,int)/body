{
  if (arena.data == null)   return -1;
  FreeList freeList=arena.freeLists[freeListIndex];
  int remaining=-1;
  freeList.lock.lock();
  try {
    ix=allocateFromFreeListUnderLock(arena,freeList,freeListIndex,dest,ix,allocationSize);
    remaining=dest.length - ix;
    if (remaining == 0)     return ix;
  }
  finally {
    freeList.lock.unlock();
  }
  int splitListIndex=freeListIndex;
  byte headerData=(byte)((freeListIndex << 1) | 1);
  while (remaining > 0) {
    ++splitListIndex;
    int splitWays=1 << (splitListIndex - freeListIndex);
    int headerStep=1 << splitListIndex;
    int lastSplitBlocksRemaining=-1, lastSplitNextHeader=-1;
    FreeList splitList=arena.freeLists[splitListIndex];
    splitList.lock.lock();
    try {
      int headerIx=splitList.listHead;
      while (headerIx >= 0 && remaining > 0) {
        int origOffset=offsetFromHeaderIndex(headerIx), offset=origOffset;
        int toTake=Math.min(splitWays,remaining);
        remaining-=toTake;
        lastSplitBlocksRemaining=splitWays - toTake;
        for (; toTake > 0; ++ix, --toTake, headerIx+=headerStep, offset+=allocationSize) {
          arena.headers[headerIx]=headerData;
          dest[ix].initialize(arena.data,offset,allocationSize);
        }
        lastSplitNextHeader=headerIx;
        headerIx=arena.data.getInt(origOffset + 4);
        arena.data.putLong(origOffset,-1);
      }
      splitList.listHead=headerIx;
    }
  finally {
      splitList.lock.unlock();
    }
    if (remaining == 0) {
      int newListIndex=freeListIndex;
      while (lastSplitBlocksRemaining > 0) {
        if ((lastSplitBlocksRemaining & 1) == 1) {
          arena.headers[lastSplitNextHeader]=(byte)((newListIndex << 1) | 1);
          int offset=offsetFromHeaderIndex(lastSplitNextHeader);
          FreeList newFreeList=arena.freeLists[newListIndex];
          newFreeList.lock.lock();
          try {
            arena.data.putInt(offset,-1);
            arena.data.putInt(offset,newFreeList.listHead);
            newFreeList.listHead=lastSplitNextHeader;
          }
  finally {
            newFreeList.lock.unlock();
          }
          lastSplitNextHeader+=(1 << newListIndex);
        }
        lastSplitBlocksRemaining>>>=1;
        ++newListIndex;
        continue;
      }
    }
  }
  return ix;
}
