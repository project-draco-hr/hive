{
  minAllocation=HiveConf.getIntVar(conf,ConfVars.LLAP_ORC_CACHE_MIN_ALLOC);
  maxAllocation=HiveConf.getIntVar(conf,ConfVars.LLAP_ORC_CACHE_MAX_ALLOC);
  arenaSize=HiveConf.getLongVar(conf,ConfVars.LLAP_ORC_CACHE_ARENA_SIZE);
  maxSize=HiveConf.getLongVar(conf,ConfVars.LLAP_ORC_CACHE_MAX_SIZE);
  if (maxSize < arenaSize || arenaSize > maxAllocation || maxAllocation < minAllocation) {
    throw new AssertionError("Inconsistent sizes of cache, arena and allocations: " + minAllocation + ", "+ maxAllocation+ ", "+ arenaSize+ ", "+ maxSize);
  }
  if ((Integer.bitCount(minAllocation) != 1) || (Integer.bitCount(maxAllocation) != 1) || (Long.bitCount(arenaSize) != 1)|| (minAllocation == 1)) {
    throw new AssertionError("Allocation and arena sizes must be powers of two > 1: " + minAllocation + ", "+ maxAllocation+ ", "+ arenaSize);
  }
  if ((maxSize % arenaSize) > 0 || (maxSize / arenaSize) > Integer.MAX_VALUE) {
    throw new AssertionError("Cache size not consistent with arena size: " + arenaSize + ","+ maxSize);
  }
  minAllocLog2=31 - Integer.numberOfLeadingZeros(minAllocation);
  maxAllocLog2=31 - Integer.numberOfLeadingZeros(maxAllocation);
  arenaSizeLog2=31 - Long.numberOfLeadingZeros(arenaSize);
  maxArenas=(int)(maxSize / arenaSize);
  arenas=new ArrayList<arena>(maxArenas);
  for (int i=0; i < maxArenas; ++i) {
    arenas.add(new arena());
  }
  arenas.get(0).init();
  cachePolicy=HiveConf.getBoolVar(conf,HiveConf.ConfVars.LLAP_USE_LRFU) ? new LowLevelLrfuCachePolicy(conf,minAllocation,maxSize,this) : new LowLevelFifoCachePolicy(minAllocation,maxSize,this);
  cleanupThread=new CleanupThread();
  cleanupThread.start();
}
