{
  boolean isCascade=desc != null && desc.getIsCascade();
  boolean alterPartitions=partSpec != null && !partSpec.isEmpty();
  if (isCascade && alterPartitions) {
    throw new SemanticException(ErrorMsg.ALTER_TABLE_PARTITION_CASCADE_NOT_SUPPORTED,op.getName());
  }
  Table tab=getTable(tableName,true);
  WriteEntity.WriteType writeType=WriteEntity.determineAlterTableWriteType(op);
  if (!alterPartitions) {
    inputs.add(new ReadEntity(tab));
    outputs.add(new WriteEntity(tab,writeType));
    if (isCascade) {
      for (      Partition part : getPartitions(tab,partSpec,false)) {
        outputs.add(new WriteEntity(part,WriteEntity.WriteType.DDL_NO_LOCK));
      }
    }
  }
 else {
    ReadEntity re=new ReadEntity(tab);
    re.noLockNeeded();
    inputs.add(re);
    if (isFullSpec(tab,partSpec)) {
      Partition part=getPartition(tab,partSpec,true);
      outputs.add(new WriteEntity(part,writeType));
    }
 else {
      if (!AlterTableDesc.doesAlterTableTypeSupportPartialPartitionSpec(op)) {
        throw new SemanticException(ErrorMsg.ALTER_TABLE_TYPE_PARTIAL_PARTITION_SPEC_NO_SUPPORTED,op.getName());
      }
 else       if (!conf.getBoolVar(HiveConf.ConfVars.DYNAMICPARTITIONING)) {
        throw new SemanticException(ErrorMsg.DYNAMIC_PARTITION_DISABLED);
      }
      for (      Partition part : getPartitions(tab,partSpec,true)) {
        outputs.add(new WriteEntity(part,writeType));
      }
    }
  }
  if (desc != null) {
    validateAlterTableType(tab,op,desc.getExpectView());
    if (op == AlterTableDesc.AlterTableTypes.DROPPROPS && !desc.getIsDropIfExists()) {
      Map<String,String> tableParams=tab.getTTable().getParameters();
      for (      String currKey : desc.getProps().keySet()) {
        if (!tableParams.containsKey(currKey)) {
          String errorMsg="The following property " + currKey + " does not exist in "+ tab.getTableName();
          throw new SemanticException(ErrorMsg.ALTER_TBL_UNSET_NON_EXIST_PROPERTY.getMsg(errorMsg));
        }
      }
    }
  }
}
