{
switch (ast.getToken().getType()) {
case HiveParser.TOK_ALTERTABLE_PARTITION:
{
      TablePartition tblPart=new TablePartition((ASTNode)ast.getChild(0));
      String tableName=tblPart.tableName;
      HashMap<String,String> partSpec=tblPart.partSpec;
      ast=(ASTNode)ast.getChild(1);
      if (ast.getToken().getType() == HiveParser.TOK_ALTERTABLE_FILEFORMAT) {
        analyzeAlterTableFileFormat(ast,tableName,partSpec);
      }
 else       if (ast.getToken().getType() == HiveParser.TOK_ALTERTABLE_ALTERPARTS_PROTECTMODE) {
        analyzeAlterTableProtectMode(ast,tableName,partSpec);
      }
 else       if (ast.getToken().getType() == HiveParser.TOK_ALTERTABLE_LOCATION) {
        analyzeAlterTableLocation(ast,tableName,partSpec);
      }
      break;
    }
case HiveParser.TOK_DROPTABLE:
  analyzeDropTable(ast,false);
break;
case HiveParser.TOK_CREATEINDEX:
analyzeCreateIndex(ast);
break;
case HiveParser.TOK_DROPINDEX:
analyzeDropIndex(ast);
break;
case HiveParser.TOK_DESCTABLE:
ctx.setResFile(new Path(ctx.getLocalTmpFileURI()));
analyzeDescribeTable(ast);
break;
case TOK_SHOWDATABASES:
ctx.setResFile(new Path(ctx.getLocalTmpFileURI()));
analyzeShowDatabases(ast);
break;
case HiveParser.TOK_SHOWTABLES:
ctx.setResFile(new Path(ctx.getLocalTmpFileURI()));
analyzeShowTables(ast);
break;
case HiveParser.TOK_SHOW_TABLESTATUS:
ctx.setResFile(new Path(ctx.getLocalTmpFileURI()));
analyzeShowTableStatus(ast);
break;
case HiveParser.TOK_SHOWFUNCTIONS:
ctx.setResFile(new Path(ctx.getLocalTmpFileURI()));
analyzeShowFunctions(ast);
break;
case HiveParser.TOK_SHOWLOCKS:
ctx.setResFile(new Path(ctx.getLocalTmpFileURI()));
analyzeShowLocks(ast);
break;
case HiveParser.TOK_DESCFUNCTION:
ctx.setResFile(new Path(ctx.getLocalTmpFileURI()));
analyzeDescFunction(ast);
break;
case HiveParser.TOK_DESCDATABASE:
ctx.setResFile(new Path(ctx.getLocalTmpFileURI()));
analyzeDescDatabase(ast);
break;
case HiveParser.TOK_MSCK:
ctx.setResFile(new Path(ctx.getLocalTmpFileURI()));
analyzeMetastoreCheck(ast);
break;
case HiveParser.TOK_DROPVIEW:
analyzeDropTable(ast,true);
break;
case HiveParser.TOK_ALTERVIEW_PROPERTIES:
analyzeAlterTableProps(ast,true);
break;
case HiveParser.TOK_ALTERTABLE_RENAME:
analyzeAlterTableRename(ast);
break;
case HiveParser.TOK_ALTERTABLE_TOUCH:
analyzeAlterTableTouch(ast);
break;
case HiveParser.TOK_ALTERTABLE_ARCHIVE:
analyzeAlterTableArchive(ast,false);
break;
case HiveParser.TOK_ALTERTABLE_UNARCHIVE:
analyzeAlterTableArchive(ast,true);
break;
case HiveParser.TOK_ALTERTABLE_ADDCOLS:
analyzeAlterTableModifyCols(ast,AlterTableTypes.ADDCOLS);
break;
case HiveParser.TOK_ALTERTABLE_REPLACECOLS:
analyzeAlterTableModifyCols(ast,AlterTableTypes.REPLACECOLS);
break;
case HiveParser.TOK_ALTERTABLE_RENAMECOL:
analyzeAlterTableRenameCol(ast);
break;
case HiveParser.TOK_ALTERTABLE_ADDPARTS:
analyzeAlterTableAddParts(ast);
break;
case HiveParser.TOK_ALTERTABLE_DROPPARTS:
analyzeAlterTableDropParts(ast);
break;
case HiveParser.TOK_ALTERTABLE_PROPERTIES:
analyzeAlterTableProps(ast,false);
break;
case HiveParser.TOK_ALTERTABLE_SERDEPROPERTIES:
analyzeAlterTableSerdeProps(ast);
break;
case HiveParser.TOK_ALTERTABLE_SERIALIZER:
analyzeAlterTableSerde(ast);
break;
case HiveParser.TOK_ALTERTABLE_CLUSTER_SORT:
analyzeAlterTableClusterSort(ast);
break;
case HiveParser.TOK_ALTERINDEX_REBUILD:
analyzeAlterIndexRebuild(ast);
break;
case HiveParser.TOK_ALTERINDEX_PROPERTIES:
analyzeAlterIndexProps(ast);
break;
case HiveParser.TOK_SHOWPARTITIONS:
ctx.setResFile(new Path(ctx.getLocalTmpFileURI()));
analyzeShowPartitions(ast);
break;
case HiveParser.TOK_SHOWINDEXES:
ctx.setResFile(new Path(ctx.getLocalTmpFileURI()));
analyzeShowIndexes(ast);
break;
case HiveParser.TOK_LOCKTABLE:
analyzeLockTable(ast);
break;
case HiveParser.TOK_UNLOCKTABLE:
analyzeUnlockTable(ast);
break;
case HiveParser.TOK_CREATEDATABASE:
analyzeCreateDatabase(ast);
break;
case HiveParser.TOK_DROPDATABASE:
analyzeDropDatabase(ast);
break;
case HiveParser.TOK_SWITCHDATABASE:
analyzeSwitchDatabase(ast);
break;
case HiveParser.TOK_ALTERDATABASE_PROPERTIES:
analyzeAlterDatabase(ast);
break;
default :
throw new SemanticException("Unsupported command.");
}
}
