{
  Map<String,String> colTypes=new HashMap<String,String>();
  for (  FieldSchema fs : tab.getPartitionKeys()) {
    colTypes.put(fs.getName().toLowerCase(),fs.getType());
  }
  for (int childIndex=1; childIndex < ast.getChildCount(); childIndex++) {
    Tree partSpecTree=ast.getChild(childIndex);
    if (partSpecTree.getType() != HiveParser.TOK_PARTSPEC)     continue;
    ExprNodeGenericFuncDesc expr=null;
    List<String> names=new ArrayList<String>(partSpecTree.getChildCount());
    for (int i=0; i < partSpecTree.getChildCount(); ++i) {
      CommonTree partSpecSingleKey=(CommonTree)partSpecTree.getChild(i);
      assert(partSpecSingleKey.getType() == HiveParser.TOK_PARTVAL);
      String key=partSpecSingleKey.getChild(0).getText().toLowerCase();
      String operator=partSpecSingleKey.getChild(1).getText();
      String val=stripQuotes(partSpecSingleKey.getChild(2).getText());
      String type=colTypes.get(key);
      if (type == null) {
        throw new SemanticException("Column " + key + " not found");
      }
      ExprNodeColumnDesc column=new ExprNodeColumnDesc(TypeInfoFactory.getPrimitiveTypeInfo(type),key,null,true);
      ExprNodeGenericFuncDesc op=new ExprNodeGenericFuncDesc(TypeInfoFactory.booleanTypeInfo,FunctionRegistry.getFunctionInfo(operator).getGenericUDF(),Lists.newArrayList(column,new ExprNodeConstantDesc(val)));
      expr=(expr == null) ? op : new ExprNodeGenericFuncDesc(TypeInfoFactory.booleanTypeInfo,FunctionRegistry.getGenericUDFForAnd(),Lists.<ExprNodeDesc>newArrayList(expr,op));
      names.add(key);
    }
    if (expr != null) {
      exprs.add(expr);
      cols.add(names);
    }
  }
}
