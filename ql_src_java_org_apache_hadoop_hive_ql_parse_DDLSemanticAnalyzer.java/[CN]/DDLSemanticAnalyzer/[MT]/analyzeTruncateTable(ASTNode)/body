{
  ASTNode root=(ASTNode)ast.getChild(0);
  String tableName=getUnescapedName((ASTNode)root.getChild(0));
  Table table=getTable(tableName,true);
  if (table.getTableType() != TableType.MANAGED_TABLE) {
    throw new SemanticException(ErrorMsg.TRUNCATE_FOR_NON_MANAGED_TABLE.format(tableName));
  }
  if (table.isNonNative()) {
    throw new SemanticException(ErrorMsg.TRUNCATE_FOR_NON_NATIVE_TABLE.format(tableName));
  }
  if (!table.isPartitioned() && root.getChildCount() > 1) {
    throw new SemanticException(ErrorMsg.PARTSPEC_FOR_NON_PARTITIONED_TABLE.format(tableName));
  }
  Map<String,String> partSpec=getPartSpec((ASTNode)root.getChild(1));
  if (partSpec == null) {
    if (!table.isPartitioned()) {
      outputs.add(new WriteEntity(table));
    }
 else {
      for (      Partition partition : getPartitions(table,null,false)) {
        outputs.add(new WriteEntity(partition));
      }
    }
  }
 else {
    if (isFullSpec(table,partSpec)) {
      Partition partition=getPartition(table,partSpec,true);
      outputs.add(new WriteEntity(partition));
    }
 else {
      for (      Partition partition : getPartitions(table,partSpec,false)) {
        outputs.add(new WriteEntity(partition));
      }
    }
  }
  TruncateTableDesc truncateTblDesc=new TruncateTableDesc(tableName,partSpec);
  DDLWork ddlWork=new DDLWork(getInputs(),getOutputs(),truncateTblDesc);
  Task<? extends Serializable> truncateTask=TaskFactory.get(ddlWork,conf);
  List<String> columnNames=null;
  if (ast.getChildCount() == 2) {
    try {
      columnNames=getColumnNames((ASTNode)ast.getChild(1));
      List<Index> indexes=db.getIndexes(table.getDbName(),tableName,(short)1);
      if (indexes != null && indexes.size() > 0) {
        throw new SemanticException(ErrorMsg.TRUNCATE_COLUMN_INDEXED_TABLE.getMsg());
      }
      List<String> bucketCols=null;
      Class<? extends InputFormat> inputFormatClass=null;
      boolean isArchived=false;
      Path newTblPartLoc=null;
      Path oldTblPartLoc=null;
      List<FieldSchema> cols=null;
      ListBucketingCtx lbCtx=null;
      boolean isListBucketed=false;
      List<String> listBucketColNames=null;
      if (table.isPartitioned()) {
        Partition part=db.getPartition(table,partSpec,false);
        Path tabPath=table.getPath();
        Path partPath=part.getPartitionPath();
        newTblPartLoc=new Path(tabPath.toUri().getScheme(),tabPath.toUri().getAuthority(),partPath.toUri().getPath());
        oldTblPartLoc=partPath;
        cols=part.getCols();
        bucketCols=part.getBucketCols();
        inputFormatClass=part.getInputFormatClass();
        isArchived=ArchiveUtils.isArchived(part);
        lbCtx=constructListBucketingCtx(part.getSkewedColNames(),part.getSkewedColValues(),part.getSkewedColValueLocationMaps(),part.isStoredAsSubDirectories(),conf);
        isListBucketed=part.isStoredAsSubDirectories();
        listBucketColNames=part.getSkewedColNames();
      }
 else {
        oldTblPartLoc=table.getPath();
        newTblPartLoc=table.getPath();
        cols=table.getCols();
        bucketCols=table.getBucketCols();
        inputFormatClass=table.getInputFormatClass();
        lbCtx=constructListBucketingCtx(table.getSkewedColNames(),table.getSkewedColValues(),table.getSkewedColValueLocationMaps(),table.isStoredAsSubDirectories(),conf);
        isListBucketed=table.isStoredAsSubDirectories();
        listBucketColNames=table.getSkewedColNames();
      }
      if (!inputFormatClass.equals(RCFileInputFormat.class)) {
        throw new SemanticException(ErrorMsg.TRUNCATE_COLUMN_NOT_RC.getMsg());
      }
      if (isArchived) {
        throw new SemanticException(ErrorMsg.TRUNCATE_COLUMN_ARCHIVED.getMsg());
      }
      Set<Integer> columnIndexes=new HashSet<Integer>();
      for (      String columnName : columnNames) {
        boolean found=false;
        for (int columnIndex=0; columnIndex < cols.size(); columnIndex++) {
          if (columnName.equalsIgnoreCase(cols.get(columnIndex).getName())) {
            columnIndexes.add(columnIndex);
            found=true;
            break;
          }
        }
        if (!found) {
          throw new SemanticException(ErrorMsg.INVALID_COLUMN.getMsg(columnName));
        }
        for (        String bucketCol : bucketCols) {
          if (bucketCol.equalsIgnoreCase(columnName)) {
            throw new SemanticException(ErrorMsg.TRUNCATE_BUCKETED_COLUMN.getMsg(columnName));
          }
        }
        if (isListBucketed) {
          for (          String listBucketCol : listBucketColNames) {
            if (listBucketCol.equalsIgnoreCase(columnName)) {
              throw new SemanticException(ErrorMsg.TRUNCATE_LIST_BUCKETED_COLUMN.getMsg(columnName));
            }
          }
        }
      }
      truncateTblDesc.setColumnIndexes(new ArrayList<Integer>(columnIndexes));
      truncateTblDesc.setInputDir(oldTblPartLoc.toString());
      addInputsOutputsAlterTable(tableName,partSpec);
      truncateTblDesc.setLbCtx(lbCtx);
      addInputsOutputsAlterTable(tableName,partSpec);
      ddlWork.setNeedLock(true);
      TableDesc tblDesc=Utilities.getTableDesc(table);
      String queryTmpdir=ctx.getExternalTmpFileURI(newTblPartLoc.toUri());
      truncateTblDesc.setOutputDir(queryTmpdir);
      LoadTableDesc ltd=new LoadTableDesc(new Path(queryTmpdir),queryTmpdir,tblDesc,partSpec == null ? new HashMap<String,String>() : partSpec);
      ltd.setLbCtx(lbCtx);
      Task<MoveWork> moveTsk=TaskFactory.get(new MoveWork(null,null,ltd,null,false),conf);
      truncateTask.addDependentTask(moveTsk);
      if (conf.getBoolVar(HiveConf.ConfVars.HIVESTATSAUTOGATHER)) {
        StatsWork statDesc;
        if (oldTblPartLoc.equals(newTblPartLoc)) {
          tableSpec tablepart=new tableSpec(this.db,conf,root);
          statDesc=new StatsWork(tablepart);
        }
 else {
          statDesc=new StatsWork(ltd);
        }
        statDesc.setNoStatsAggregator(true);
        statDesc.setClearAggregatorStats(true);
        statDesc.setStatsReliable(conf.getBoolVar(HiveConf.ConfVars.HIVE_STATS_RELIABLE));
        Task<? extends Serializable> statTask=TaskFactory.get(statDesc,conf);
        moveTsk.addDependentTask(statTask);
      }
    }
 catch (    HiveException e) {
      throw new SemanticException(e);
    }
  }
  rootTasks.add(truncateTask);
}
