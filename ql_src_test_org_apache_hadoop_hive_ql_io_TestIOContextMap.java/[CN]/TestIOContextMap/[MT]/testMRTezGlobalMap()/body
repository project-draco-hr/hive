{
  final int THREAD_COUNT=2, ITER_COUNT=1000;
  final AtomicInteger countdown=new AtomicInteger(ITER_COUNT);
  final CountDownLatch phase1End=new CountDownLatch(THREAD_COUNT);
  final IOContext[] results=new IOContext[ITER_COUNT];
  ExecutorService executor=Executors.newFixedThreadPool(THREAD_COUNT);
  final CountDownLatch cdlIn=new CountDownLatch(THREAD_COUNT), cdlOut=new CountDownLatch(1);
  @SuppressWarnings("unchecked") FutureTask<Void>[] tasks=new FutureTask[THREAD_COUNT];
  for (int i=0; i < tasks.length; ++i) {
    tasks[i]=new FutureTask<Void>(new Callable<Void>(){
      public Void call() throws Exception {
        Configuration conf=new Configuration();
        syncThreadStart(cdlIn,cdlOut);
        while (true) {
          int nextIx=countdown.decrementAndGet();
          if (nextIx < 0)           break;
          conf.set(Utilities.INPUT_NAME,"Input " + nextIx);
          results[nextIx]=IOContextMap.get(conf);
          if (nextIx == 0)           break;
        }
        phase1End.countDown();
        phase1End.await();
        for (int i=0; i < ITER_COUNT; ++i) {
          conf.set(Utilities.INPUT_NAME,"Input " + i);
          IOContext ctx=IOContextMap.get(conf);
          assertSame(results[i],ctx);
        }
        return null;
      }
    }
);
    executor.execute(tasks[i]);
  }
  cdlIn.await();
  cdlOut.countDown();
  for (int i=0; i < tasks.length; ++i) {
    tasks[i].get();
  }
  Set<IOContext> resultSet=Sets.newIdentityHashSet();
  for (int i=0; i < results.length; ++i) {
    assertTrue(resultSet.add(results[i]));
  }
}
