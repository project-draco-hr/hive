{
  DAG dag=DAG.create(work.getName());
  dag.setCredentials(job.getCredentials());
  DagUtils utils=DagUtils.getInstance();
  Context ctx=new Context(job);
  MapWork mapWork=(MapWork)work.getAllWork().get(0);
  JobConf wxConf=utils.initializeVertexConf(job,ctx,mapWork);
  Path scratchDir=utils.createTezDir(ctx.getMRScratchDir(),job);
  FileSystem fs=scratchDir.getFileSystem(job);
  try {
    LocalResource appJarLr=createJarLocalResource(utils.getExecJarPathLocal(),utils,job);
    Vertex wx=utils.createVertex(wxConf,mapWork,scratchDir,appJarLr,new ArrayList<LocalResource>(),fs,ctx,false,work,work.getVertexType(mapWork));
    String vertexName=wx.getName();
    dag.addVertex(wx);
    utils.addCredentials(mapWork,dag);
    Preconditions.checkState(HiveConf.getBoolVar(wxConf,HiveConf.ConfVars.HIVE_TEZ_GENERATE_CONSISTENT_SPLITS));
    Preconditions.checkState(HiveConf.getBoolVar(wxConf,HiveConf.ConfVars.LLAP_CLIENT_CONSISTENT_SPLITS));
    HiveSplitGenerator splitGenerator=new HiveSplitGenerator(wxConf,mapWork);
    List<Event> eventList=splitGenerator.initialize();
    InputSplit[] result=new InputSplit[eventList.size() - 1];
    InputConfigureVertexTasksEvent configureEvent=(InputConfigureVertexTasksEvent)eventList.get(0);
    List<TaskLocationHint> hints=configureEvent.getLocationHint().getTaskLocationHints();
    Preconditions.checkState(hints.size() == eventList.size() - 1);
    if (LOG.isDebugEnabled()) {
      LOG.debug("NumEvents=" + eventList.size());
      LOG.debug("NumSplits=" + result.length);
    }
    LlapCoordinator coordinator=LlapCoordinator.getInstance();
    if (coordinator == null) {
      throw new IOException("LLAP coordinator is not initialized; must be running in HS2 with " + ConfVars.LLAP_HS2_ENABLE_COORDINATOR.varname + " enabled");
    }
    ApplicationId fakeApplicationId=coordinator.createExtClientAppId();
    String llapUser=UserGroupInformation.getLoginUser().getShortUserName();
    LlapSigner signer=UserGroupInformation.isSecurityEnabled() ? coordinator.getLlapSigner(job) : null;
    LOG.info("Number of splits: " + (eventList.size() - 1));
    SignedMessage signedSvs=null;
    DataOutputBuffer dob=new DataOutputBuffer();
    for (int i=0; i < eventList.size() - 1; i++) {
      TaskSpec taskSpec=new TaskSpecBuilder().constructTaskSpec(dag,vertexName,eventList.size() - 1,fakeApplicationId,i);
      if (i == 0) {
        signedSvs=createSignedVertexSpec(signer,taskSpec,fakeApplicationId);
      }
      SubmitWorkInfo submitWorkInfo=new SubmitWorkInfo(fakeApplicationId,System.currentTimeMillis(),taskSpec.getVertexParallelism(),signedSvs.message,signedSvs.signature);
      EventMetaData sourceMetaData=new EventMetaData(EventMetaData.EventProducerConsumerType.INPUT,vertexName,"NULL_VERTEX",null);
      EventMetaData destinationMetaInfo=new TaskSpecBuilder().getDestingationMetaData(wx);
      Event event=eventList.get(i + 1);
      TaskLocationHint hint=hints.get(i);
      Set<String> hosts=hint.getHosts();
      if (hosts.size() != 1) {
        LOG.warn("Bad # of locations: " + hosts.size());
      }
      SplitLocationInfo[] locations=new SplitLocationInfo[hosts.size()];
      int j=0;
      for (      String host : hosts) {
        locations[j++]=new SplitLocationInfo(host,false);
      }
      TezEvent tezEvent=new TezEvent(event,sourceMetaData,System.currentTimeMillis());
      tezEvent.setDestinationInfo(destinationMetaInfo);
      bos.reset();
      dob.reset();
      tezEvent.write(dob);
      byte[] submitWorkBytes=SubmitWorkInfo.toBytes(submitWorkInfo);
      result[i]=new LlapInputSplit(i,submitWorkBytes,dob.getData(),locations,schema,llapUser);
    }
    return result;
  }
 catch (  Exception e) {
    throw new IOException(e);
  }
}
