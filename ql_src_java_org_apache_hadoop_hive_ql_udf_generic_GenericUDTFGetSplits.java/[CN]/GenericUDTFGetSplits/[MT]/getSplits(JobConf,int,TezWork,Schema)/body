{
  DAG dag=DAG.create(work.getName());
  dag.setCredentials(job.getCredentials());
  DagUtils utils=DagUtils.getInstance();
  Context ctx=new Context(job);
  MapWork mapWork=(MapWork)work.getAllWork().get(0);
  JobConf wxConf=utils.initializeVertexConf(job,ctx,mapWork);
  Path scratchDir=utils.createTezDir(ctx.getMRScratchDir(),job);
  FileSystem fs=scratchDir.getFileSystem(job);
  try {
    LocalResource appJarLr=createJarLocalResource(utils.getExecJarPathLocal(),utils,job);
    Vertex wx=utils.createVertex(wxConf,mapWork,scratchDir,appJarLr,new ArrayList<LocalResource>(),fs,ctx,false,work,work.getVertexType(mapWork));
    String vertexName=wx.getName();
    dag.addVertex(wx);
    utils.addCredentials(mapWork,dag);
    Preconditions.checkState(HiveConf.getBoolVar(wxConf,ConfVars.HIVE_TEZ_GENERATE_CONSISTENT_SPLITS));
    Preconditions.checkState(HiveConf.getBoolVar(wxConf,ConfVars.LLAP_CLIENT_CONSISTENT_SPLITS));
    HiveSplitGenerator splitGenerator=new HiveSplitGenerator(wxConf,mapWork);
    List<Event> eventList=splitGenerator.initialize();
    InputSplit[] result=new InputSplit[eventList.size() - 1];
    InputConfigureVertexTasksEvent configureEvent=(InputConfigureVertexTasksEvent)eventList.get(0);
    List<TaskLocationHint> hints=configureEvent.getLocationHint().getTaskLocationHints();
    Preconditions.checkState(hints.size() == eventList.size() - 1);
    if (LOG.isDebugEnabled()) {
      LOG.debug("NumEvents=" + eventList.size() + ", NumSplits="+ result.length);
    }
    LlapCoordinator coordinator=LlapCoordinator.getInstance();
    if (coordinator == null) {
      throw new IOException("LLAP coordinator is not initialized; must be running in HS2 with " + ConfVars.LLAP_HS2_ENABLE_COORDINATOR.varname + " enabled");
    }
    ApplicationId applicationId=coordinator.createExtClientAppId();
    String llapUser=UserGroupInformation.getLoginUser().getShortUserName();
    String queryUser=null;
    byte[] tokenBytes=null;
    LlapSigner signer=null;
    if (UserGroupInformation.isSecurityEnabled()) {
      signer=coordinator.getLlapSigner(job);
      queryUser=SessionState.getUserFromAuthenticator();
      if (queryUser == null) {
        queryUser=UserGroupInformation.getCurrentUser().getUserName();
        LOG.warn("Cannot determine the session user; using " + queryUser + " instead");
      }
      LlapTokenLocalClient tokenClient=coordinator.getLocalTokenClient(job,llapUser);
      Token<LlapTokenIdentifier> token=tokenClient.createToken(applicationId.toString(),queryUser,true);
      bos.reset();
      token.write(dos);
      tokenBytes=bos.toByteArray();
    }
 else {
      queryUser=UserGroupInformation.getCurrentUser().getUserName();
    }
    LOG.info("Number of splits: " + (eventList.size() - 1));
    SignedMessage signedSvs=null;
    for (int i=0; i < eventList.size() - 1; i++) {
      TaskSpec taskSpec=new TaskSpecBuilder().constructTaskSpec(dag,vertexName,eventList.size() - 1,applicationId,i);
      if (i == 0) {
        signedSvs=createSignedVertexSpec(signer,taskSpec,applicationId,queryUser,applicationId.toString());
      }
      SubmitWorkInfo submitWorkInfo=new SubmitWorkInfo(applicationId,System.currentTimeMillis(),taskSpec.getVertexParallelism(),signedSvs.message,signedSvs.signature);
      byte[] submitWorkBytes=SubmitWorkInfo.toBytes(submitWorkInfo);
      SignedMessage eventBytes=makeEventBytes(wx,vertexName,eventList.get(i + 1),signer);
      SplitLocationInfo[] locations=makeLocationHints(hints.get(i));
      result[i]=new LlapInputSplit(i,submitWorkBytes,eventBytes.message,eventBytes.signature,locations,schema,llapUser,tokenBytes);
    }
    return result;
  }
 catch (  Exception e) {
    throw new IOException(e);
  }
}
