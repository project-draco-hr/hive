{
  if (input == null) {
    return null;
  }
switch (inputOI.getPrimitiveCategory()) {
case VOID:
    return null;
case BOOLEAN:
  t.set(((BooleanObjectInspector)inputOI).get(input) ? trueBytes : falseBytes);
return t;
case BYTE:
out.reset();
LazyInteger.writeUTF8NoException(out,((ByteObjectInspector)inputOI).get(input));
t.set(out.getData(),0,out.getCount());
return t;
case SHORT:
out.reset();
LazyInteger.writeUTF8NoException(out,((ShortObjectInspector)inputOI).get(input));
t.set(out.getData(),0,out.getCount());
return t;
case INT:
out.reset();
LazyInteger.writeUTF8NoException(out,((IntObjectInspector)inputOI).get(input));
t.set(out.getData(),0,out.getCount());
return t;
case LONG:
out.reset();
LazyLong.writeUTF8NoException(out,((LongObjectInspector)inputOI).get(input));
t.set(out.getData(),0,out.getCount());
return t;
case FLOAT:
t.set(String.valueOf(((FloatObjectInspector)inputOI).get(input)));
return t;
case DOUBLE:
t.set(String.valueOf(((DoubleObjectInspector)inputOI).get(input)));
return t;
case STRING:
if (inputOI.preferWritable()) {
t.set(((StringObjectInspector)inputOI).getPrimitiveWritableObject(input));
}
 else {
t.set(((StringObjectInspector)inputOI).getPrimitiveJavaObject(input));
}
return t;
case TIMESTAMP:
t.set(((TimestampObjectInspector)inputOI).getPrimitiveWritableObject(input).toString());
return t;
case BINARY:
t.set(((BinaryObjectInspector)inputOI).getPrimitiveWritableObject(input).getBytes());
return t;
case DECIMAL:
t.set(((HiveDecimalObjectInspector)inputOI).getPrimitiveWritableObject(input).toString());
return t;
default :
throw new RuntimeException("Hive 2 Internal error: type = " + inputOI.getTypeName());
}
}
