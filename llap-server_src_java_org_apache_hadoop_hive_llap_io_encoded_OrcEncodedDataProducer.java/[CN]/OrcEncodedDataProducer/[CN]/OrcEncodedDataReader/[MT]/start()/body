{
  LlapIoImpl.LOG.info("Processing split for " + internedFilePath);
  if (isStopped)   return;
  List<StripeInformation> stripes=metadataCache.getStripes(internedFilePath);
  List<Type> types=metadataCache.getTypes(internedFilePath);
  orcReader=null;
  if (stripes == null || types == null) {
    orcReader=createOrcReader(split);
    stripes=metadataCache.getStripes(internedFilePath);
    types=metadataCache.getTypes(internedFilePath);
  }
  if (columnIds == null) {
    columnIds=new ArrayList<Integer>(types.size());
    for (int i=1; i < types.size(); ++i) {
      columnIds.add(i);
    }
  }
  determineWhatToRead(stripes);
  if (isStopped)   return;
  List<Integer>[] stripeColumnsToRead=produceDataFromCache();
  for (int stripeIxMod=0; stripeIxMod < readState.length; ++stripeIxMod) {
    List<Integer> colsToRead=stripeColumnsToRead[stripeIxMod];
    long[][] colRgs=readState[stripeIxMod];
    if (colsToRead == null) {
      colsToRead=columnIds;
    }
    if (colsToRead.isEmpty())     continue;
    if (colsToRead.size() != colRgs.length) {
      long[][] colRgs2=new long[colsToRead.size()][];
      for (int i=0, i2=-1; i < colRgs.length; ++i) {
        if (colRgs[i] == null)         continue;
        colRgs2[++i2]=colRgs[i];
      }
      colRgs=colRgs2;
    }
    int stripeIx=stripeIxFrom + stripeIxMod;
    StripeInformation si=stripes.get(stripeIx);
    int rgCount=rgsPerStripe[stripeIxMod];
    boolean[] includes=OrcInputFormat.genIncludedColumns(types,colsToRead,true);
    if (orcReader == null) {
      orcReader=createOrcReader(split);
    }
    RecordReader stripeReader=orcReader.rows(si.getOffset(),si.getLength(),includes);
    stripeReader.readEncodedColumns(colRgs,rgCount,sarg,this,lowLevelCache);
    stripeReader.close();
  }
  consumer.setDone();
  if (DebugUtils.isTraceMttEnabled()) {
    LlapIoImpl.LOG.info("done processing " + split);
  }
}
