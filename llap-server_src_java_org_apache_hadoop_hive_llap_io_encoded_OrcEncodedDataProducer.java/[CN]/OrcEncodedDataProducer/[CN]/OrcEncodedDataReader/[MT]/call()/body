{
  LlapIoImpl.LOG.info("Processing split for " + internedFilePath);
  if (isStopped)   return null;
  orcReader=null;
  OrcFileMetadata metadata=null;
  try {
    metadata=getOrReadFileMetadata();
    if (columnIds == null) {
      columnIds=createColumnIds(metadata);
    }
    determineStripesToRead(metadata.getStripes());
  }
 catch (  Throwable t) {
    consumer.setError(t);
    return null;
  }
  if (readState.length == 0) {
    consumer.setDone();
    return null;
  }
  int stride=metadata.getRowIndexStride();
  ArrayList<OrcStripeMetadata> stripeMetadatas=null;
  boolean[] globalIncludes=null;
  try {
    globalIncludes=OrcInputFormat.genIncludedColumns(metadata.getTypes(),columnIds,true);
    if (sarg != null && stride != 0) {
      stripeMetadatas=readStripesMetadata(metadata,globalIncludes);
    }
    determineRgsToRead(metadata.getStripes(),metadata.getTypes(),globalIncludes,stride,stripeMetadatas);
  }
 catch (  Throwable t) {
    cleanupReaders(null);
    consumer.setError(t);
    return null;
  }
  if (isStopped) {
    cleanupReaders(null);
    return null;
  }
  List<Integer>[] stripeColsToRead=null;
  if (cache != null) {
    try {
      stripeColsToRead=produceDataFromCache(metadata.getStripes(),stride);
    }
 catch (    Throwable t) {
      consumer.setError(t);
      cleanupReaders(null);
      return null;
    }
  }
  ensureOrcReader();
  Consumer<EncodedColumnBatch<OrcBatchKey>> consumer=(cache == null) ? this.consumer : this;
  EncodedReader stripeReader=null;
  try {
    orcReader.encodedReader(lowLevelCache,consumer);
  }
 catch (  Throwable t) {
    consumer.setError(t);
    cleanupReaders(null);
    return null;
  }
  OrcBatchKey stripeKey=new OrcBatchKey(internedFilePath,-1,0);
  for (int stripeIxMod=0; stripeIxMod < readState.length; ++stripeIxMod) {
    try {
      List<Integer> cols=stripeColsToRead == null ? null : stripeColsToRead[stripeIxMod];
      if (cols != null && cols.isEmpty())       continue;
      int stripeIx=stripeIxFrom + stripeIxMod;
      StripeInformation si=metadata.getStripes().get(stripeIx);
      if (DebugUtils.isTraceOrcEnabled()) {
        LlapIoImpl.LOG.info("Reading stripe " + stripeIx + ": "+ si.getOffset()+ ", "+ si.getLength());
      }
      boolean[] stripeIncludes=null;
      boolean[][] colRgs=readState[stripeIxMod];
      if (cols == null || cols.size() == colRgs.length) {
        cols=columnIds;
        stripeIncludes=globalIncludes;
      }
 else {
        stripeIncludes=OrcInputFormat.genIncludedColumns(metadata.getTypes(),cols,true);
        boolean[][] colRgs2=new boolean[cols.size()][];
        for (int i=0, i2=-1; i < colRgs.length; ++i) {
          if (colRgs[i] == null)           continue;
          colRgs2[i2]=colRgs[i];
          ++i2;
        }
        colRgs=colRgs2;
      }
      OrcStripeMetadata stripeMetadata;
      if (stripeMetadatas != null) {
        stripeMetadata=stripeMetadatas.get(stripeIxMod);
      }
 else {
        stripeKey.stripeIx=stripeIx;
        stripeMetadata=metadataCache.getStripeMetadata(stripeKey);
        if (stripeMetadata == null) {
          ensureMetadataReader();
          stripeMetadata=new OrcStripeMetadata(metadataReader,si,stripeIncludes);
          if (DebugUtils.isTraceOrcEnabled()) {
            LlapIoImpl.LOG.info("Caching stripe " + stripeKey.stripeIx + " metadata with includes: "+ DebugUtils.toString(stripeIncludes));
          }
          metadataCache.putStripeMetadata(stripeKey,stripeMetadata);
          stripeKey=new OrcBatchKey(internedFilePath,-1,0);
        }
      }
      if (!stripeMetadata.hasAllIndexes(stripeIncludes)) {
        if (DebugUtils.isTraceOrcEnabled()) {
          LlapIoImpl.LOG.info("Updating indexes in stripe " + stripeKey.stripeIx + " metadata for includes: "+ DebugUtils.toString(stripeIncludes));
        }
        ensureMetadataReader();
        updateLoadedIndexes(stripeMetadata,si,stripeIncludes);
      }
      stripeReader.readEncodedColumns(stripeIx,si,stripeMetadata.getRowIndexes(),stripeMetadata.getEncodings(),stripeMetadata.getStreams(),stripeIncludes,colRgs);
      stripeReader.close();
    }
 catch (    Throwable t) {
      consumer.setError(t);
      cleanupReaders(stripeReader);
      return null;
    }
  }
  consumer.setDone();
  if (DebugUtils.isTraceMttEnabled()) {
    LlapIoImpl.LOG.info("done processing " + split);
  }
  return null;
}
