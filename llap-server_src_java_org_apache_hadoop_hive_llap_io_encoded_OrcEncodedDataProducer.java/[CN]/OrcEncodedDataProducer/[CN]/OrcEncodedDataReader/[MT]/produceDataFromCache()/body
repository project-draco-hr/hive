{
  if (cache == null)   return null;
  OrcCacheKey key=new OrcCacheKey(internedFilePath,-1,-1,-1);
  @SuppressWarnings("unchecked") List<Integer>[] stripeColsNotInCache=new List[readState.length];
  for (int stripeIxMod=0; stripeIxMod < readState.length; ++stripeIxMod) {
    key.stripeIx=stripeIxFrom + stripeIxMod;
    long[][] cols=readState[stripeIxMod];
    int rgCount=rgsPerStripe[stripeIxMod];
    for (int colIxMod=0; colIxMod < cols.length; ++colIxMod) {
      key.colIx=columnIds.get(colIxMod);
      long[] doneMask=cols[colIxMod];
      boolean areAllRgsInCache=true;
      for (int rgIx=0; rgIx < rgCount; ++rgIx) {
        int maskIndex=rgIx >>> 6, maskBit=1 << (rgIx & 63);
        if ((doneMask[maskIndex] & maskBit) != 0)         continue;
        key.rgIx=rgIx;
        ColumnBuffer cached=cache.get(key);
        if (cached == null) {
          areAllRgsInCache=false;
          continue;
        }
        EncodedColumn<OrcBatchKey> col=new EncodedColumn<OrcBatchKey>(key.copyToPureBatchKey(),key.colIx,cached);
        consumer.consumeData(col);
        doneMask[maskIndex]=doneMask[maskIndex] | maskBit;
      }
      boolean hasFetchList=stripeColsNotInCache[stripeIxMod] != null;
      if (areAllRgsInCache) {
        cols[colIxMod]=null;
        if (!hasFetchList) {
          stripeColsNotInCache[stripeIxMod]=new ArrayList<Integer>(cols.length);
          if (stripeIxMod > 0) {
            stripeColsNotInCache[stripeIxMod].addAll(columnIds.subList(0,colIxMod));
          }
        }
      }
 else       if (hasFetchList) {
        stripeColsNotInCache[stripeIxMod].add(columnIds.get(colIxMod));
      }
    }
  }
  return stripeColsNotInCache;
}
