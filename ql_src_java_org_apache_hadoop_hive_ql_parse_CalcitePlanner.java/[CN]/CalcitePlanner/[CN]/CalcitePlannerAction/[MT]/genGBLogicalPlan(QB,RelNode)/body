{
  RelNode gbRel=null;
  QBParseInfo qbp=getQBParseInfo(qb);
  String detsClauseName=qbp.getClauseNames().iterator().next();
  ASTNode selExprList=qb.getParseInfo().getSelForClause(detsClauseName);
  if (selExprList.getToken().getType() == HiveParser.TOK_SELECTDI && selExprList.getChildCount() == 1 && selExprList.getChild(0).getChildCount() == 1) {
    ASTNode node=(ASTNode)selExprList.getChild(0).getChild(0);
    if (node.getToken().getType() == HiveParser.TOK_ALLCOLREF) {
      srcRel=genSelectLogicalPlan(qb,srcRel,srcRel);
      RowResolver rr=this.relToHiveRR.get(srcRel);
      qbp.setSelExprForClause(detsClauseName,SemanticAnalyzer.genSelectDIAST(rr));
    }
  }
  List<ASTNode> grpByAstExprs=getGroupByForClause(qbp,detsClauseName);
  HashMap<String,ASTNode> aggregationTrees=qbp.getAggregationExprsForClause(detsClauseName);
  boolean hasGrpByAstExprs=(grpByAstExprs != null && !grpByAstExprs.isEmpty()) ? true : false;
  boolean hasAggregationTrees=(aggregationTrees != null && !aggregationTrees.isEmpty()) ? true : false;
  final boolean cubeRollupGrpSetPresent=(!qbp.getDestRollups().isEmpty() || !qbp.getDestGroupingSets().isEmpty() || !qbp.getDestCubes().isEmpty());
  if (conf.getBoolVar(HiveConf.ConfVars.HIVEGROUPBYSKEW) && qbp.getDistinctFuncExprsForClause(detsClauseName).size() > 1) {
    throw new SemanticException(ErrorMsg.UNSUPPORTED_MULTIPLE_DISTINCTS.getMsg());
  }
  if (cubeRollupGrpSetPresent) {
    if (!HiveConf.getBoolVar(conf,HiveConf.ConfVars.HIVEMAPSIDEAGGREGATE)) {
      throw new SemanticException(ErrorMsg.HIVE_GROUPING_SETS_AGGR_NOMAPAGGR.getMsg());
    }
    if (conf.getBoolVar(HiveConf.ConfVars.HIVEGROUPBYSKEW)) {
      checkExpressionsForGroupingSet(grpByAstExprs,qb.getParseInfo().getDistinctFuncExprsForClause(detsClauseName),aggregationTrees,this.relToHiveRR.get(srcRel));
      if (qbp.getDestGroupingSets().size() > conf.getIntVar(HiveConf.ConfVars.HIVE_NEW_JOB_GROUPING_SET_CARDINALITY)) {
        String errorMsg="The number of rows per input row due to grouping sets is " + qbp.getDestGroupingSets().size();
        throw new SemanticException(ErrorMsg.HIVE_GROUPING_SETS_THRESHOLD_NOT_ALLOWED_WITH_SKEW.getMsg(errorMsg));
      }
    }
  }
  if (hasGrpByAstExprs || hasAggregationTrees) {
    ArrayList<ExprNodeDesc> gbExprNDescLst=new ArrayList<ExprNodeDesc>();
    ArrayList<String> outputColumnNames=new ArrayList<String>();
    RowResolver groupByInputRowResolver=this.relToHiveRR.get(srcRel);
    RowResolver groupByOutputRowResolver=new RowResolver();
    groupByOutputRowResolver.setIsExprResolver(true);
    if (hasGrpByAstExprs) {
      for (int i=0; i < grpByAstExprs.size(); ++i) {
        ASTNode grpbyExpr=grpByAstExprs.get(i);
        Map<ASTNode,ExprNodeDesc> astToExprNDescMap=TypeCheckProcFactory.genExprNode(grpbyExpr,new TypeCheckCtx(groupByInputRowResolver));
        ExprNodeDesc grpbyExprNDesc=astToExprNDescMap.get(grpbyExpr);
        if (grpbyExprNDesc == null)         throw new CalciteSemanticException("Invalid Column Reference: " + grpbyExpr.dump(),UnsupportedFeature.Invalid_column_reference);
        addToGBExpr(groupByOutputRowResolver,groupByInputRowResolver,grpbyExpr,grpbyExprNDesc,gbExprNDescLst,outputColumnNames);
      }
    }
    int groupingColsSize=gbExprNDescLst.size();
    List<Integer> groupingSets=null;
    if (cubeRollupGrpSetPresent) {
      if (qbp.getDestRollups().contains(detsClauseName)) {
        groupingSets=getGroupingSetsForRollup(grpByAstExprs.size());
      }
 else       if (qbp.getDestCubes().contains(detsClauseName)) {
        groupingSets=getGroupingSetsForCube(grpByAstExprs.size());
      }
 else       if (qbp.getDestGroupingSets().contains(detsClauseName)) {
        groupingSets=getGroupingSets(grpByAstExprs,qbp,detsClauseName);
      }
      final int limit=groupingColsSize * 2;
      while (groupingColsSize < limit) {
        String field=getColumnInternalName(groupingColsSize);
        outputColumnNames.add(field);
        groupByOutputRowResolver.put(null,field,new ColumnInfo(field,TypeInfoFactory.booleanTypeInfo,null,false));
        groupingColsSize++;
      }
    }
    ArrayList<AggInfo> aggregations=new ArrayList<AggInfo>();
    if (hasAggregationTrees) {
      assert(aggregationTrees != null);
      for (      ASTNode value : aggregationTrees.values()) {
        String aggName=SemanticAnalyzer.unescapeIdentifier(value.getChild(0).getText());
        boolean isDistinct=value.getType() == HiveParser.TOK_FUNCTIONDI;
        boolean isAllColumns=value.getType() == HiveParser.TOK_FUNCTIONSTAR;
        ArrayList<ExprNodeDesc> aggParameters=new ArrayList<ExprNodeDesc>();
        for (int i=1; i < value.getChildCount(); i++) {
          ASTNode paraExpr=(ASTNode)value.getChild(i);
          ExprNodeDesc paraExprNode=genExprNodeDesc(paraExpr,groupByInputRowResolver);
          aggParameters.add(paraExprNode);
        }
        Mode amode=SemanticAnalyzer.groupByDescModeToUDAFMode(GroupByDesc.Mode.COMPLETE,isDistinct);
        GenericUDAFEvaluator genericUDAFEvaluator=SemanticAnalyzer.getGenericUDAFEvaluator(aggName,aggParameters,value,isDistinct,isAllColumns);
        assert(genericUDAFEvaluator != null);
        GenericUDAFInfo udaf=SemanticAnalyzer.getGenericUDAFInfo(genericUDAFEvaluator,amode,aggParameters);
        AggInfo aInfo=new AggInfo(aggParameters,udaf.returnType,aggName,isDistinct);
        aggregations.add(aInfo);
        String field=getColumnInternalName(groupingColsSize + aggregations.size() - 1);
        outputColumnNames.add(field);
        groupByOutputRowResolver.putExpression(value,new ColumnInfo(field,aInfo.m_returnType,"",false));
      }
    }
    if (groupingSets != null && !groupingSets.isEmpty()) {
      String field=getColumnInternalName(groupingColsSize + aggregations.size());
      outputColumnNames.add(field);
      groupByOutputRowResolver.put(null,VirtualColumn.GROUPINGID.getName(),new ColumnInfo(field,TypeInfoFactory.intTypeInfo,null,true));
    }
    gbRel=genGBRelNode(gbExprNDescLst,aggregations,groupingSets,srcRel);
    relToHiveColNameCalcitePosMap.put(gbRel,buildHiveToCalciteColumnMap(groupByOutputRowResolver,gbRel));
    this.relToHiveRR.put(gbRel,groupByOutputRowResolver);
  }
  return gbRel;
}
