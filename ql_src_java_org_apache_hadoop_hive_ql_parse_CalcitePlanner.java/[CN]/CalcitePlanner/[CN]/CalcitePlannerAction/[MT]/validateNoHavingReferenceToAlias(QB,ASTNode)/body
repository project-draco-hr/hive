{
  QBParseInfo qbPI=qb.getParseInfo();
  Map<ASTNode,String> exprToAlias=qbPI.getAllExprToColumnAlias();
  Set<String> aggExprs=qbPI.getDestToAggregationExprs().values().iterator().next().keySet();
  for (  Map.Entry<ASTNode,String> selExpr : exprToAlias.entrySet()) {
    ASTNode selAST=selExpr.getKey();
    if (!aggExprs.contains(selAST.toStringTree().toLowerCase())) {
      continue;
    }
    final String aliasToCheck=selExpr.getValue();
    final Set<Object> aliasReferences=new HashSet<Object>();
    TreeVisitorAction action=new TreeVisitorAction(){
      @Override public Object pre(      Object t){
        if (ParseDriver.adaptor.getType(t) == HiveParser.TOK_TABLE_OR_COL) {
          Object c=ParseDriver.adaptor.getChild(t,0);
          if (c != null && ParseDriver.adaptor.getType(c) == HiveParser.Identifier && ParseDriver.adaptor.getText(c).equals(aliasToCheck)) {
            aliasReferences.add(t);
          }
        }
        return t;
      }
      @Override public Object post(      Object t){
        return t;
      }
    }
;
    new TreeVisitor(ParseDriver.adaptor).visit(havingExpr,action);
    if (aliasReferences.size() > 0) {
      String havingClause=ctx.getTokenRewriteStream().toString(havingExpr.getTokenStartIndex(),havingExpr.getTokenStopIndex());
      String msg=String.format("Encountered Select alias '%s' in having clause '%s'" + " This non standard behavior is not supported with cbo on." + " Turn off cbo for these queries.",aliasToCheck,havingClause);
      LOG.debug(msg);
      throw new CalciteSemanticException(msg,UnsupportedFeature.Select_alias_in_having_clause);
    }
  }
}
