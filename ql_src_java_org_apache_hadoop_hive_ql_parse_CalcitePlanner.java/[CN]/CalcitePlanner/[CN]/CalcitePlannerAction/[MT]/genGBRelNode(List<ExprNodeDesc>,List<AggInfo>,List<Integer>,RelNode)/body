{
  ImmutableMap<String,Integer> posMap=this.relToHiveColNameCalcitePosMap.get(srcRel);
  RexNodeConverter converter=new RexNodeConverter(this.cluster,srcRel.getRowType(),posMap,0,false);
  final List<RexNode> gbChildProjLst=Lists.newArrayList();
  final HashMap<String,Integer> rexNodeToPosMap=new HashMap<String,Integer>();
  final List<Integer> groupSetPositions=Lists.newArrayList();
  Integer gbIndx=0;
  RexNode rnd;
  for (  ExprNodeDesc key : gbExprs) {
    rnd=converter.convert(key);
    gbChildProjLst.add(rnd);
    groupSetPositions.add(gbIndx);
    rexNodeToPosMap.put(rnd.toString(),gbIndx);
    gbIndx++;
  }
  final ImmutableBitSet groupSet=ImmutableBitSet.of(groupSetPositions);
  List<AggregateCall> aggregateCalls=Lists.newArrayList();
  for (  AggInfo agg : aggInfoLst) {
    aggregateCalls.add(convertGBAgg(agg,srcRel,gbChildProjLst,converter,rexNodeToPosMap,gbChildProjLst.size()));
  }
  if (gbChildProjLst.isEmpty()) {
    gbChildProjLst.add(this.cluster.getRexBuilder().makeInputRef(srcRel,0));
  }
  RelNode gbInputRel=HiveProject.create(srcRel,gbChildProjLst,null);
  List<ImmutableBitSet> transformedGroupSets=null;
  if (groupSets != null && !groupSets.isEmpty()) {
    Set<ImmutableBitSet> setTransformedGroupSets=new HashSet<ImmutableBitSet>(groupSets.size());
    for (    int val : groupSets) {
      setTransformedGroupSets.add(convert(val));
    }
    transformedGroupSets=new ArrayList<ImmutableBitSet>(setTransformedGroupSets);
    Collections.sort(transformedGroupSets,ImmutableBitSet.COMPARATOR);
  }
  HiveRelNode aggregateRel=null;
  try {
    aggregateRel=new HiveAggregate(cluster,cluster.traitSetOf(HiveRelNode.CONVENTION),gbInputRel,(transformedGroupSets != null ? true : false),groupSet,transformedGroupSets,aggregateCalls);
  }
 catch (  InvalidRelException e) {
    throw new SemanticException(e);
  }
  return aggregateRel;
}
