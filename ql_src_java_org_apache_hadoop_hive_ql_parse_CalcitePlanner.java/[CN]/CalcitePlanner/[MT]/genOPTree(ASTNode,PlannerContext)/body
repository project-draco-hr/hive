{
  Operator sinkOp=null;
  boolean skipCalcitePlan=false;
  if (!runCBO) {
    skipCalcitePlan=true;
  }
 else {
    PreCboCtx cboCtx=(PreCboCtx)plannerCtx;
    ASTNode queryForCbo=ast;
    if (cboCtx.type == PreCboCtx.Type.CTAS) {
      queryForCbo=cboCtx.nodeOfInterest;
    }
    runCBO=canHandleAstForCbo(queryForCbo,getQB(),cboCtx);
    if (runCBO) {
      disableJoinMerge=true;
      boolean reAnalyzeAST=false;
      try {
        ASTNode newAST=getOptimizedAST();
        newAST=fixUpCtasAndInsertAfterCbo(ast,newAST,cboCtx);
        init(false);
        if (cboCtx.type == PreCboCtx.Type.CTAS) {
          setAST(newAST);
          newAST=reAnalyzeCtasAfterCbo(newAST);
        }
        Phase1Ctx ctx_1=initPhase1Ctx();
        if (!doPhase1(newAST,getQB(),ctx_1,null)) {
          throw new RuntimeException("Couldn't do phase1 on CBO optimized query plan");
        }
        getMetaData(getQB());
        disableJoinMerge=false;
        sinkOp=genPlan(getQB());
        LOG.info("CBO Succeeded; optimized logical plan.");
        LOG.debug(newAST.dump());
      }
 catch (      Exception e) {
        boolean isMissingStats=noColsMissingStats.get() > 0;
        if (isMissingStats) {
          LOG.error("CBO failed due to missing column stats (see previous errors), skipping CBO");
        }
 else {
          LOG.error("CBO failed, skipping CBO. ",e);
        }
        if (!conf.getBoolVar(ConfVars.HIVE_IN_TEST) || isMissingStats || e instanceof CalciteSemanticException) {
          reAnalyzeAST=true;
        }
 else         if (e instanceof SemanticException) {
          throw (SemanticException)e;
        }
 else         if (e instanceof RuntimeException) {
          throw (RuntimeException)e;
        }
 else {
          throw new SemanticException(e);
        }
      }
 finally {
        runCBO=false;
        disableJoinMerge=false;
        if (reAnalyzeAST) {
          init(true);
          prunedPartitions.clear();
          super.genResolvedParseTree(ast,new PlannerContext());
          skipCalcitePlan=true;
        }
      }
    }
 else {
      skipCalcitePlan=true;
    }
  }
  if (skipCalcitePlan) {
    sinkOp=super.genOPTree(ast,plannerCtx);
  }
  return sinkOp;
}
