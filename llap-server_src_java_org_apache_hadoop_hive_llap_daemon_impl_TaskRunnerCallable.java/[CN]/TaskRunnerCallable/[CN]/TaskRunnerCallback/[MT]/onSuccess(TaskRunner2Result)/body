{
  isCompleted.set(true);
switch (result.getEndReason()) {
case SUCCESS:
    LOG.debug("Successfully finished {}",requestId);
  metrics.incrExecutorTotalSuccess();
break;
case CONTAINER_STOP_REQUESTED:
LOG.info("Received container stop request (AM preemption) for {}",requestId);
break;
case KILL_REQUESTED:
LOG.info("Killed task {}",requestId);
if (killtimerWatch.isRunning()) {
killtimerWatch.stop();
long elapsed=killtimerWatch.elapsedMillis();
LOG.info("Time to die for task {}",elapsed);
}
metrics.incrPreemptionTimeLost(runtimeWatch.elapsedMillis());
metrics.incrExecutorTotalKilled();
break;
case COMMUNICATION_FAILURE:
LOG.info("Failed to run {} due to communication failure",requestId);
metrics.incrExecutorTotalExecutionFailed();
break;
case TASK_ERROR:
LOG.info("Failed to run {} due to task error",requestId);
metrics.incrExecutorTotalExecutionFailed();
break;
}
fragmentCompletionHanler.fragmentComplete(fragmentInfo);
taskRunnerCallable.shutdown();
HistoryLogger.logFragmentEnd(request.getApplicationIdString(),request.getContainerIdString(),executionContext.getHostName(),request.getFragmentSpec().getDagName(),fragmentInfo.getQueryInfo().getDagIdentifier(),request.getFragmentSpec().getVertexName(),request.getFragmentSpec().getFragmentNumber(),request.getFragmentSpec().getAttemptNumber(),taskRunnerCallable.threadName,taskRunnerCallable.startTime,true);
metrics.decrExecutorNumQueuedRequests();
}
