{
  mLogger.info("Starting parallel execution on " + mHost.getName());
  List<ListenableFuture<Void>> droneResults=Lists.newArrayList();
  for (  final Drone drone : ImmutableList.copyOf(mDrones)) {
    droneResults.add(mExecutor.submit(new Callable<Void>(){
      @Override public Void call() throws Exception {
        TestBatch batch=null;
        try {
          do {
            batch=parallelWorkQueue.poll(mNumPollSeconds,TimeUnit.SECONDS);
            if (batch != null) {
              if (!executeTestBatch(drone,batch)) {
                failedTestResults.add(batch);
              }
            }
          }
 while (!parallelWorkQueue.isEmpty());
        }
 catch (        AbortDroneException ex) {
          mDrones.remove(drone);
          mLogger.error("Aborting drone during parallel execution",ex);
          if (batch != null) {
            Preconditions.checkState(parallelWorkQueue.add(batch),"Could not add batch to parallel queue " + batch);
          }
        }
        return null;
      }
    }
));
  }
  Futures.allAsList(droneResults).get();
  mLogger.info("Starting isolated execution on " + mHost.getName());
  for (  Drone drone : ImmutableList.copyOf(mDrones)) {
    TestBatch batch=null;
    try {
      do {
        batch=isolatedWorkQueue.poll(mNumPollSeconds,TimeUnit.SECONDS);
        if (batch != null) {
          if (!executeTestBatch(drone,batch)) {
            failedTestResults.add(batch);
          }
        }
      }
 while (!isolatedWorkQueue.isEmpty());
    }
 catch (    AbortDroneException ex) {
      mDrones.remove(drone);
      mLogger.error("Aborting drone during isolated execution",ex);
      if (batch != null) {
        Preconditions.checkState(isolatedWorkQueue.add(batch),"Could not add batch to isolated queue " + batch);
      }
    }
  }
}
