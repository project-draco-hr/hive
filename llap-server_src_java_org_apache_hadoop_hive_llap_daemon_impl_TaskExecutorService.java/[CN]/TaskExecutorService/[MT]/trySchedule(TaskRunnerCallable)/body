{
  boolean scheduled=false;
  try {
    ListenableFuture<TaskRunner2Result> future=executorService.submit(task);
    FutureCallback<TaskRunner2Result> wrappedCallback=new InternalCompletionListener(task);
    Futures.addCallback(future,wrappedCallback,executionCompletionExecutorService);
    if (isInfoEnabled) {
      LOG.info(task.getRequestId() + " scheduled for execution.");
    }
    if (enablePreemption && !task.canFinish()) {
      if (isInfoEnabled) {
        LOG.info(task.getRequestId() + " is not finishable. Adding it to pre-emption queue.");
      }
      preemptionQueue.add(task);
    }
    numSlotsAvailable.decrementAndGet();
    scheduled=true;
  }
 catch (  RejectedExecutionException e) {
    if (enablePreemption && task.canFinish() && !preemptionQueue.isEmpty()) {
      if (isDebugEnabled) {
        LOG.debug("Preemption Queue: " + preemptionQueue);
      }
      TaskRunnerCallable pRequest=preemptionQueue.remove();
      if (pRequest != null) {
        if (isInfoEnabled) {
          LOG.info("Invoking kill task for {} due to pre-emption to run {}",pRequest.getRequestId(),task.getRequestId());
        }
        pRequest.killTask();
      }
    }
  }
  return scheduled;
}
