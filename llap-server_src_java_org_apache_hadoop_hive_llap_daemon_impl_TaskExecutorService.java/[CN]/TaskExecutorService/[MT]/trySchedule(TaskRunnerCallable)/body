{
  boolean scheduled=false;
  try {
    ListenableFuture<TaskRunner2Result> future=executorService.submit(task);
    FutureCallback<TaskRunner2Result> wrappedCallback=new InternalCompletionListener(task.getCallback());
    Futures.addCallback(future,wrappedCallback);
    if (isInfoEnabled) {
      LOG.info(task.getRequestId() + " scheduled for execution.");
    }
    if (enablePreemption && !task.canFinish()) {
      if (isDebugEnabled) {
        LOG.debug(task.getRequestId() + " is not finishable and pre-emption is enabled." + "Adding it to pre-emption queue.");
      }
      addTaskToPreemptionList(task);
    }
    numSlotsAvailable.decrementAndGet();
    scheduled=true;
  }
 catch (  RejectedExecutionException e) {
    if (enablePreemption && task.canFinish() && !preemptionQueue.isEmpty()) {
      if (isTraceEnabled) {
        LOG.trace("idToTaskMap: " + idToTaskMap.keySet());
        LOG.trace("preemptionQueue: " + preemptionQueue);
      }
      TaskRunnerCallable pRequest=preemptionQueue.peek();
      if (pRequest != null) {
        if (isDebugEnabled) {
          LOG.debug("Kill task invoked for " + pRequest.getRequestId() + " due to pre-emption");
        }
        pRequest.killTask();
      }
    }
  }
  return scheduled;
}
