{
  boolean scheduled=false;
  try {
    ListenableFuture<TaskRunner2Result> future=executorService.submit(task);
    FutureCallback<TaskRunner2Result> wrappedCallback=new InternalCompletionListener(task);
    Futures.addCallback(future,wrappedCallback);
    if (isInfoEnabled) {
      LOG.info(task.getRequestId() + " scheduled for execution.");
    }
    if (enablePreemption && !task.canFinish()) {
      if (isInfoEnabled) {
        LOG.info(task.getRequestId() + " is not finishable. Adding it to pre-emption queue.");
      }
      preemptionQueue.add(task);
    }
    numSlotsAvailable.decrementAndGet();
    scheduled=true;
  }
 catch (  RejectedExecutionException e) {
    if (enablePreemption && task.canFinish() && !preemptionQueue.isEmpty()) {
      if (isDebugEnabled) {
        LOG.trace("preemptionQueue: " + preemptionQueue);
      }
      TaskRunnerCallable pRequest=preemptionQueue.remove();
      if (pRequest != null && !pRequest.isCompleted() && !pRequest.isKillInvoked()) {
        if (isInfoEnabled) {
          LOG.info("Kill task invoked for " + pRequest.getRequestId() + " due to pre-emption");
        }
        pRequest.setKillInvoked();
        pRequest.killTask();
      }
    }
  }
  return scheduled;
}
