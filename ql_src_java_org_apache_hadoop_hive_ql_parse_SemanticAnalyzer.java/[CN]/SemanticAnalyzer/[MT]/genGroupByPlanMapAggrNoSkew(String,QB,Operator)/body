{
  QBParseInfo parseInfo=qb.getParseInfo();
  ObjectPair<List<ASTNode>,List<Integer>> grpByExprsGroupingSets=getGroupByGroupingSetsForClause(parseInfo,dest);
  List<ASTNode> grpByExprs=grpByExprsGroupingSets.getFirst();
  List<Integer> groupingSets=grpByExprsGroupingSets.getSecond();
  boolean groupingSetsPresent=!groupingSets.isEmpty();
  int newMRJobGroupingSetsThreshold=conf.getIntVar(HiveConf.ConfVars.HIVE_NEW_JOB_GROUPING_SET_CARDINALITY);
  if (groupingSetsPresent) {
    checkExpressionsForGroupingSet(grpByExprs,parseInfo.getDistinctFuncExprsForClause(dest),parseInfo.getAggregationExprsForClause(dest),opParseCtx.get(inputOperatorInfo).getRowResolver());
  }
  Map<String,GenericUDAFEvaluator> genericUDAFEvaluators=new LinkedHashMap<String,GenericUDAFEvaluator>();
  boolean groupingSetsNeedAdditionalMRJob=groupingSetsPresent && groupingSets.size() > newMRJobGroupingSetsThreshold ? true : false;
  GroupByOperator groupByOperatorInfo=(GroupByOperator)genGroupByPlanMapGroupByOperator(qb,dest,grpByExprs,inputOperatorInfo,GroupByDesc.Mode.HASH,genericUDAFEvaluators,groupingSets,groupingSetsPresent && !groupingSetsNeedAdditionalMRJob);
  groupOpToInputTables.put(groupByOperatorInfo,opParseCtx.get(inputOperatorInfo).getRowResolver().getTableNames());
  int numReducers=-1;
  if (grpByExprs.isEmpty()) {
    numReducers=1;
  }
  boolean isDistinct=!qb.getParseInfo().getDistinctFuncExprsForClause(dest).isEmpty();
  if (groupingSetsNeedAdditionalMRJob && isDistinct) {
    String errorMsg="The number of rows per input row due to grouping sets is " + groupingSets.size();
    throw new SemanticException(ErrorMsg.HIVE_GROUPING_SETS_THRESHOLD_NOT_ALLOWED_WITH_DISTINCTS.getMsg(errorMsg));
  }
  Operator reduceSinkOperatorInfo=genGroupByPlanReduceSinkOperator(qb,dest,groupByOperatorInfo,grpByExprs,grpByExprs.size(),true,numReducers,true,groupingSetsPresent && !groupingSetsNeedAdditionalMRJob);
  if (!groupingSetsPresent || !groupingSetsNeedAdditionalMRJob) {
    return genGroupByPlanGroupByOperator1(parseInfo,dest,reduceSinkOperatorInfo,GroupByDesc.Mode.MERGEPARTIAL,genericUDAFEvaluators,false,groupingSets,groupingSetsPresent,groupingSetsNeedAdditionalMRJob);
  }
 else {
    Operator groupByOperatorInfo2=genGroupByPlanGroupByOperator1(parseInfo,dest,reduceSinkOperatorInfo,GroupByDesc.Mode.PARTIALS,genericUDAFEvaluators,false,groupingSets,groupingSetsPresent,groupingSetsNeedAdditionalMRJob);
    Operator reduceSinkOperatorInfo2=genGroupByPlanReduceSinkOperator2MR(parseInfo,dest,groupByOperatorInfo2,grpByExprs.size() + 1,numReducers,groupingSetsPresent);
    return genGroupByPlanGroupByOperator2MR(parseInfo,dest,reduceSinkOperatorInfo2,GroupByDesc.Mode.FINAL,genericUDAFEvaluators,groupingSetsPresent);
  }
}
