{
  StructObjectInspector oi=null;
  try {
    Deserializer deserializer=table_desc.getDeserializerClass().newInstance();
    deserializer.initialize(null,table_desc.getProperties());
    oi=(StructObjectInspector)deserializer.getObjectInspector();
  }
 catch (  Exception e) {
    throw new SemanticException(e);
  }
  List<? extends StructField> tableFields=oi.getAllStructFieldRefs();
  Vector<ColumnInfo> rowFields=opParseCtx.get(input).getRR().getColumnInfos();
  if (tableFields.size() != rowFields.size()) {
    String reason="Table " + dest + " has "+ tableFields.size()+ " columns but query has "+ rowFields.size()+ " columns.";
    throw new SemanticException(ErrorMsg.TARGET_TABLE_COLUMN_MISMATCH.getMsg(qb.getParseInfo().getDestForClause(dest),reason));
  }
  boolean converted=false;
  int columnNumber=tableFields.size();
  ArrayList<exprNodeDesc> expressions=new ArrayList<exprNodeDesc>(columnNumber);
  if (!table_desc.getDeserializerClass().equals(MetadataTypedColumnsetSerDe.class)) {
    for (int i=0; i < columnNumber; i++) {
      ObjectInspector tableFieldOI=tableFields.get(i).getFieldObjectInspector();
      TypeInfo tableFieldTypeInfo=TypeInfoUtils.getTypeInfoFromObjectInspector(tableFieldOI);
      TypeInfo rowFieldTypeInfo=rowFields.get(i).getType();
      exprNodeDesc column=new exprNodeColumnDesc(rowFieldTypeInfo,Integer.valueOf(i).toString());
      if (!tableFieldTypeInfo.equals(rowFieldTypeInfo)) {
        converted=true;
        if (tableFieldTypeInfo.getCategory() != Category.PRIMITIVE) {
          column=null;
        }
 else {
          column=getFuncExprNodeDesc(tableFieldTypeInfo.getPrimitiveClass().getName(),column);
        }
        if (column == null) {
          String reason="Cannot convert column " + i + " from "+ rowFieldTypeInfo+ " to "+ tableFieldTypeInfo+ ".";
          throw new SemanticException(ErrorMsg.TARGET_TABLE_COLUMN_MISMATCH.getMsg(qb.getParseInfo().getDestForClause(dest),reason));
        }
      }
 else {
        expressions.add(column);
      }
    }
  }
  if (converted) {
    RowResolver rowResolver=new RowResolver();
    for (int i=0; i < expressions.size(); i++) {
      String name=Integer.valueOf(i).toString();
      rowResolver.put("",name,new ColumnInfo(name,expressions.get(i).getTypeInfo()));
    }
    Operator output=putOpInsertMap(OperatorFactory.getAndMakeChild(new selectDesc(expressions),new RowSchema(rowResolver.getColumnInfos()),input),rowResolver);
    return output;
  }
 else {
    return input;
  }
}
