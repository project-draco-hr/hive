{
  RowResolver reduceSinkInputRowResolver=opParseCtx.get(inputOperatorInfo).getRR();
  QBParseInfo parseInfo=qb.getParseInfo();
  RowResolver reduceSinkOutputRowResolver=new RowResolver();
  reduceSinkOutputRowResolver.setIsExprResolver(true);
  Map<String,exprNodeDesc> colExprMap=new HashMap<String,exprNodeDesc>();
  ArrayList<exprNodeDesc> reduceKeys=new ArrayList<exprNodeDesc>();
  List<ASTNode> grpByExprs=getGroupByForClause(parseInfo,dest);
  for (int i=0; i < grpByExprs.size(); ++i) {
    ASTNode grpbyExpr=grpByExprs.get(i);
    exprNodeDesc inputExpr=genExprNodeDesc(grpbyExpr,reduceSinkInputRowResolver);
    reduceKeys.add(inputExpr);
    String text=grpbyExpr.toStringTree();
    if (reduceSinkOutputRowResolver.get("",text) == null) {
      ColumnInfo colInfo=new ColumnInfo(Utilities.ReduceField.KEY.toString() + "." + Integer.valueOf(reduceKeys.size() - 1).toString(),reduceKeys.get(reduceKeys.size() - 1).getTypeInfo());
      reduceSinkOutputRowResolver.put("",text,colInfo);
      colExprMap.put(colInfo.getInternalName(),inputExpr);
    }
 else {
      throw new SemanticException(ErrorMsg.DUPLICATE_GROUPBY_KEY.getMsg(grpbyExpr));
    }
  }
  if (parseInfo.getDistinctFuncExprForClause(dest) != null) {
    ASTNode value=parseInfo.getDistinctFuncExprForClause(dest);
    for (int i=1; i < value.getChildCount(); i++) {
      ASTNode parameter=(ASTNode)value.getChild(i);
      String text=parameter.toStringTree();
      if (reduceSinkOutputRowResolver.get("",text) == null) {
        reduceKeys.add(genExprNodeDesc(parameter,reduceSinkInputRowResolver));
        ColumnInfo colInfo=new ColumnInfo(Utilities.ReduceField.KEY.toString() + "." + Integer.valueOf(reduceKeys.size() - 1).toString(),reduceKeys.get(reduceKeys.size() - 1).getTypeInfo());
        reduceSinkOutputRowResolver.put("",text,colInfo);
        colExprMap.put(colInfo.getInternalName(),reduceKeys.get(reduceKeys.size() - 1));
      }
    }
  }
  ArrayList<exprNodeDesc> reduceValues=new ArrayList<exprNodeDesc>();
  HashMap<String,ASTNode> aggregationTrees=parseInfo.getAggregationExprsForClause(dest);
  if (!mapAggrDone) {
    for (    Map.Entry<String,ASTNode> entry : aggregationTrees.entrySet()) {
      ASTNode value=entry.getValue();
      for (int i=1; i < value.getChildCount(); i++) {
        ASTNode parameter=(ASTNode)value.getChild(i);
        String text=parameter.toStringTree();
        if (reduceSinkOutputRowResolver.get("",text) == null) {
          reduceValues.add(genExprNodeDesc(parameter,reduceSinkInputRowResolver));
          reduceSinkOutputRowResolver.put("",text,new ColumnInfo(Utilities.ReduceField.VALUE.toString() + "." + Integer.valueOf(reduceValues.size() - 1).toString(),reduceValues.get(reduceValues.size() - 1).getTypeInfo()));
        }
      }
    }
  }
 else {
    int inputField=reduceKeys.size();
    for (    Map.Entry<String,ASTNode> entry : aggregationTrees.entrySet()) {
      TypeInfo type=reduceSinkInputRowResolver.getColumnInfos().get(inputField).getType();
      reduceValues.add(new exprNodeColumnDesc(type,(Integer.valueOf(inputField)).toString()));
      inputField++;
      reduceSinkOutputRowResolver.put("",((ASTNode)entry.getValue()).toStringTree(),new ColumnInfo(Utilities.ReduceField.VALUE.toString() + "." + (Integer.valueOf(reduceValues.size() - 1)).toString(),type));
    }
  }
  ReduceSinkOperator rsOp=(ReduceSinkOperator)putOpInsertMap(OperatorFactory.getAndMakeChild(PlanUtils.getReduceSinkDesc(reduceKeys,reduceValues,-1,numPartitionFields,numReducers),new RowSchema(reduceSinkOutputRowResolver.getColumnInfos()),inputOperatorInfo),reduceSinkOutputRowResolver);
  rsOp.setColumnExprMap(colExprMap);
  return rsOp;
}
