{
  if ((op.getClass() == FileSinkOperator.class) && (mvTask != null)) {
    currTask.addDependentTask(mvTask);
  }
  List<Operator<? extends Serializable>> childOps=op.getChildOperators();
  if (childOps == null) {
    return;
  }
  mapredWork plan=(mapredWork)currTask.getWork();
  for (int i=0; i < childOps.size(); ++i) {
    Operator<? extends Serializable> child=childOps.get(i);
    if (child.getClass() == ReduceSinkOperator.class) {
      assert(child.getChildOperators().size() == 1);
      Operator<? extends Serializable> reducer=child.getChildOperators().get(0);
      assert(plan.getReducer() != null);
      if (plan.getReducer() == reducer) {
        if (child.getChildOperators().get(0).getClass() == JoinOperator.class)         plan.setNeedsTagging(true);
        genTaskPlan(reducer,currTask,redTaskMap,mvTask);
      }
 else       if (plan.getReducer() != reducer) {
        Task<? extends Serializable> ctask=null;
        mapredWork cplan=null;
        ctask=redTaskMap.get(reducer);
        if (ctask == null) {
          cplan=getMapRedWork();
          ctask=TaskFactory.get(cplan,this.conf);
          cplan.setReducer(reducer);
          if (((reduceSinkDesc)child.getConf()).getNumReducers() != -1)           cplan.setNumReduceTasks(new Integer(((reduceSinkDesc)child.getConf()).getNumReducers()));
 else           cplan.setInferNumReducers(((reduceSinkDesc)child.getConf()).getInferNumReducers());
          redTaskMap.put(reducer,ctask);
          genTaskPlan(reducer,ctask,redTaskMap,mvTask);
          String taskTmpDir=this.scratchDir + File.separator + this.randomid+ '.'+ this.pathid;
          this.pathid++;
          StringBuilder sb=new StringBuilder();
          boolean isfirst=true;
          for (          ColumnInfo colInfo : op.getSchema().getSignature()) {
            if (!isfirst) {
              sb.append(",");
            }
            sb.append(colInfo.getInternalName());
            isfirst=false;
          }
          tableDesc tt_desc=PlanUtils.getBinaryTableDesc(PlanUtils.getFieldSchemasFromRowSchema(op.getSchema(),"temporarycol"));
          Operator<? extends Serializable> fs_op=putOpInsertMap(OperatorFactory.get(new fileSinkDesc(taskTmpDir,tt_desc),op.getSchema()),null);
          childOps.set(i,fs_op);
          List<Operator<? extends Serializable>> parent=new ArrayList<Operator<? extends Serializable>>();
          parent.add(op);
          fs_op.setParentOperators(parent);
          if (cplan.getPathToAliases().get(taskTmpDir) == null) {
            cplan.getPathToAliases().put(taskTmpDir,new ArrayList<String>());
          }
          String streamDesc;
          if (child.getChildOperators().get(0).getClass() == JoinOperator.class)           streamDesc="$INTNAME";
 else           streamDesc=taskTmpDir;
          cplan.getPathToAliases().get(taskTmpDir).add(streamDesc);
          cplan.getPathToPartitionInfo().put(taskTmpDir,new partitionDesc(tt_desc,null));
          cplan.getAliasToWork().put(streamDesc,child);
          setKeyAndValueDesc(cplan,child);
          currTask.addDependentTask(ctask);
          if (child.getChildOperators().get(0).getClass() == JoinOperator.class)           cplan.setNeedsTagging(true);
        }
      }
      child.setChildOperators(null);
    }
 else {
      genTaskPlan(child,currTask,redTaskMap,mvTask);
    }
  }
}
