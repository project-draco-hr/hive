{
  ArrayList<exprNodeDesc> newParameters=new ArrayList<exprNodeDesc>();
  List<TypeInfo> parametersAccepted=TypeInfoUtils.getParameterTypeInfos(m);
  for (int i=0; i < parametersPassed.size(); i++) {
    exprNodeDesc descPassed=parametersPassed.get(i);
    TypeInfo typeInfoPassed=descPassed.getTypeInfo();
    TypeInfo typeInfoAccepted=parametersAccepted.get(i);
    if (descPassed instanceof exprNodeNullDesc) {
      exprNodeConstantDesc newCh=new exprNodeConstantDesc(typeInfoAccepted,null);
      newParameters.add(newCh);
    }
 else     if (typeInfoAccepted.equals(typeInfoPassed) || typeInfoAccepted.equals(TypeInfoFactory.unknownTypeInfo) || (typeInfoAccepted.equals(TypeInfoFactory.unknownMapTypeInfo) && typeInfoPassed.getCategory().equals(Category.MAP))|| (typeInfoAccepted.equals(TypeInfoFactory.unknownListTypeInfo) && typeInfoPassed.getCategory().equals(Category.LIST))) {
      newParameters.add(descPassed);
    }
 else {
      TypeInfo to=typeInfoAccepted;
      if (!FunctionRegistry.implicitConvertable(typeInfoPassed,to)) {
        throw new RuntimeException("Internal exception: cannot convert from " + typeInfoPassed + " to "+ to);
      }
      Method conv=FunctionRegistry.getUDFMethod(to.getTypeName(),typeInfoPassed);
      assert(conv != null);
      Class<? extends UDF> c=FunctionRegistry.getUDFClass(to.getTypeName());
      assert(c != null);
      ArrayList<exprNodeDesc> conversionArg=new ArrayList<exprNodeDesc>(1);
      conversionArg.add(descPassed);
      newParameters.add(new exprNodeFuncDesc(typeInfoAccepted,c,conv,conversionArg));
    }
  }
  return newParameters;
}
