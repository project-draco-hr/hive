{
  Map<String,ArrayList<ASTNode>> aliasToLateralViews=qb.getParseInfo().getAliasToLateralViews();
  for (  Entry<String,Operator> e : aliasToOpInfo.entrySet()) {
    String alias=e.getKey();
    ArrayList<ASTNode> lateralViews=aliasToLateralViews.get(alias);
    if (lateralViews != null) {
      Operator op=e.getValue();
      for (      ASTNode lateralViewTree : aliasToLateralViews.get(alias)) {
        RowResolver lvForwardRR=opParseCtx.get(op).getRR();
        Operator lvForward=putOpInsertMap(OperatorFactory.getAndMakeChild(new LateralViewForwardDesc(),new RowSchema(lvForwardRR.getColumnInfos()),op),lvForwardRR);
        RowResolver allPathRR=opParseCtx.get(lvForward).getRR();
        Operator allPath=putOpInsertMap(OperatorFactory.getAndMakeChild(new SelectDesc(true),new RowSchema(allPathRR.getColumnInfos()),lvForward),allPathRR);
        QB blankQb=new QB(null,null,false);
        Operator udtfPath=genSelectPlan((ASTNode)lateralViewTree.getChild(0),blankQb,lvForward);
        RowResolver udtfPathRR=opParseCtx.get(udtfPath).getRR();
        RowResolver lateralViewRR=new RowResolver();
        ArrayList<String> outputInternalColNames=new ArrayList<String>();
        LVmergeRowResolvers(allPathRR,lateralViewRR,outputInternalColNames);
        LVmergeRowResolvers(udtfPathRR,lateralViewRR,outputInternalColNames);
        Map<String,ExprNodeDesc> colExprMap=new HashMap<String,ExprNodeDesc>();
        int i=0;
        for (        ColumnInfo c : allPathRR.getColumnInfos()) {
          String internalName=getColumnInternalName(i);
          i++;
          colExprMap.put(internalName,new ExprNodeColumnDesc(c.getType(),c.getInternalName(),c.getTabAlias(),c.getIsPartitionCol()));
        }
        Operator lateralViewJoin=putOpInsertMap(OperatorFactory.getAndMakeChild(new LateralViewJoinDesc(outputInternalColNames),new RowSchema(lateralViewRR.getColumnInfos()),allPath,udtfPath),lateralViewRR);
        lateralViewJoin.setColumnExprMap(colExprMap);
        op=lateralViewJoin;
      }
      e.setValue(op);
    }
  }
}
