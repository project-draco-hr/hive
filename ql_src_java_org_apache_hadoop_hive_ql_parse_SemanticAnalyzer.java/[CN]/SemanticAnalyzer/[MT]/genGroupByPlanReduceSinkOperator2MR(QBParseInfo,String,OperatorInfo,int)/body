{
  RowResolver reduceSinkOutputRowResolver2=new RowResolver();
  reduceSinkOutputRowResolver2.setIsExprResolver(true);
  ArrayList<exprNodeDesc> reduceKeys=new ArrayList<exprNodeDesc>();
  List<CommonTree> grpByExprs=getGroupByForClause(parseInfo,dest);
  for (int i=0; i < grpByExprs.size(); ++i) {
    CommonTree grpbyExpr=grpByExprs.get(i);
    String field=(Integer.valueOf(i)).toString();
    reduceKeys.add(new exprNodeColumnDesc(TypeInfoFactory.getPrimitiveTypeInfo(String.class),field));
    reduceSinkOutputRowResolver2.put("",grpbyExpr.toStringTree(),new ColumnInfo(Utilities.ReduceField.KEY.toString() + "." + field,String.class));
  }
  ArrayList<exprNodeDesc> reduceValues=new ArrayList<exprNodeDesc>();
  int inputField=reduceKeys.size();
  HashMap<String,CommonTree> aggregationTrees=parseInfo.getAggregationExprsForClause(dest);
  for (  Map.Entry<String,CommonTree> entry : aggregationTrees.entrySet()) {
    reduceValues.add(new exprNodeColumnDesc(TypeInfoFactory.getPrimitiveTypeInfo(String.class),(Integer.valueOf(inputField)).toString()));
    inputField++;
    reduceSinkOutputRowResolver2.put("",((CommonTree)entry.getValue()).toStringTree(),new ColumnInfo(Utilities.ReduceField.VALUE.toString() + "." + (Integer.valueOf(reduceValues.size() - 1)).toString(),String.class));
  }
  return new OperatorInfo(OperatorFactory.getAndMakeChild(PlanUtils.getReduceSinkDesc(reduceKeys,reduceValues,-1,numPartitionFields,-1,true),new RowSchema(reduceSinkOutputRowResolver2.getColumnInfos()),groupByOperatorInfo.getOp()),reduceSinkOutputRowResolver2);
}
