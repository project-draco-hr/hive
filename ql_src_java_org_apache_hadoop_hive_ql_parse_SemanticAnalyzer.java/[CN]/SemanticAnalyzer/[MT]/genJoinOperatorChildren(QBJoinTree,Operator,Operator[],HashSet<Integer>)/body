{
  RowResolver outputRS=new RowResolver();
  ArrayList<String> outputColumnNames=new ArrayList<String>();
  Operator<?>[] rightOps=new Operator[right.length];
  int outputPos=0;
  Map<String,Byte> reversedExprs=new HashMap<String,Byte>();
  HashMap<Byte,List<ExprNodeDesc>> exprMap=new HashMap<Byte,List<ExprNodeDesc>>();
  Map<String,ExprNodeDesc> colExprMap=new HashMap<String,ExprNodeDesc>();
  HashMap<Integer,Set<String>> posToAliasMap=new HashMap<Integer,Set<String>>();
  HashMap<Byte,List<ExprNodeDesc>> filterMap=new HashMap<Byte,List<ExprNodeDesc>>();
  for (int pos=0; pos < right.length; ++pos) {
    Operator input=right[pos];
    if (input == null) {
      input=left;
    }
    ArrayList<ExprNodeDesc> keyDesc=new ArrayList<ExprNodeDesc>();
    ArrayList<ExprNodeDesc> filterDesc=new ArrayList<ExprNodeDesc>();
    Byte tag=Byte.valueOf((byte)(((ReduceSinkDesc)(input.getConf())).getTag()));
    if (omitOpts == null || !omitOpts.contains(pos)) {
      RowResolver inputRS=opParseCtx.get(input).getRowResolver();
      Iterator<String> keysIter=inputRS.getTableNames().iterator();
      Set<String> aliases=posToAliasMap.get(pos);
      if (aliases == null) {
        aliases=new HashSet<String>();
        posToAliasMap.put(pos,aliases);
      }
      while (keysIter.hasNext()) {
        String key=keysIter.next();
        aliases.add(key);
        HashMap<String,ColumnInfo> map=inputRS.getFieldMap(key);
        Iterator<String> fNamesIter=map.keySet().iterator();
        while (fNamesIter.hasNext()) {
          String field=fNamesIter.next();
          ColumnInfo valueInfo=inputRS.get(key,field);
          keyDesc.add(new ExprNodeColumnDesc(valueInfo.getType(),valueInfo.getInternalName(),valueInfo.getTabAlias(),valueInfo.getIsVirtualCol()));
          if (outputRS.get(key,field) == null) {
            String colName=getColumnInternalName(outputPos);
            outputPos++;
            outputColumnNames.add(colName);
            colExprMap.put(colName,keyDesc.get(keyDesc.size() - 1));
            outputRS.put(key,field,new ColumnInfo(colName,valueInfo.getType(),key,valueInfo.getIsVirtualCol(),valueInfo.isHiddenVirtualCol()));
            reversedExprs.put(colName,tag);
          }
        }
      }
      for (      ASTNode cond : join.getFilters().get(tag)) {
        filterDesc.add(genExprNodeDesc(cond,inputRS));
      }
    }
    exprMap.put(tag,keyDesc);
    filterMap.put(tag,filterDesc);
    rightOps[pos]=input;
  }
  JoinCondDesc[] joinCondns=new JoinCondDesc[join.getJoinCond().length];
  for (int i=0; i < join.getJoinCond().length; i++) {
    JoinCond condn=join.getJoinCond()[i];
    joinCondns[i]=new JoinCondDesc(condn);
  }
  JoinDesc desc=new JoinDesc(exprMap,outputColumnNames,join.getNoOuterJoin(),joinCondns,filterMap);
  desc.setReversedExprs(reversedExprs);
  desc.setFilterMap(join.getFilterMap());
  JoinOperator joinOp=(JoinOperator)OperatorFactory.getAndMakeChild(desc,new RowSchema(outputRS.getColumnInfos()),rightOps);
  joinOp.setColumnExprMap(colExprMap);
  joinOp.setPosToAliasMap(posToAliasMap);
  if (join.getNullSafes() != null) {
    boolean[] nullsafes=new boolean[join.getNullSafes().size()];
    for (int i=0; i < nullsafes.length; i++) {
      nullsafes[i]=join.getNullSafes().get(i);
    }
    desc.setNullSafes(nullsafes);
  }
  return putOpInsertMap(joinOp,outputRS);
}
