{
  RowResolver outputRR=new RowResolver();
  ArrayList<String> outputColumnNames=new ArrayList<String>();
  Operator<?>[] rightOps=new Operator[right.length];
  int outputPos=0;
  Map<String,Byte> reversedExprs=new HashMap<String,Byte>();
  HashMap<Byte,List<ExprNodeDesc>> exprMap=new HashMap<Byte,List<ExprNodeDesc>>();
  Map<String,ExprNodeDesc> colExprMap=new HashMap<String,ExprNodeDesc>();
  HashMap<Integer,Set<String>> posToAliasMap=new HashMap<Integer,Set<String>>();
  HashMap<Byte,List<ExprNodeDesc>> filterMap=new HashMap<Byte,List<ExprNodeDesc>>();
  for (int pos=0; pos < right.length; ++pos) {
    Operator<?> input=right[pos] == null ? left : right[pos];
    if (input == null) {
      input=left;
    }
    ReduceSinkOperator rs=(ReduceSinkOperator)input;
    if (rs.getNumParent() != 1) {
      throw new SemanticException("RS should have single parent");
    }
    Operator<?> parent=rs.getParentOperators().get(0);
    ReduceSinkDesc rsDesc=(ReduceSinkDesc)(input.getConf());
    int[] index=rs.getValueIndex();
    ArrayList<ExprNodeDesc> valueDesc=new ArrayList<ExprNodeDesc>();
    ArrayList<ExprNodeDesc> filterDesc=new ArrayList<ExprNodeDesc>();
    Byte tag=(byte)rsDesc.getTag();
    if (omitOpts != null && omitOpts.contains(pos)) {
      exprMap.put(tag,valueDesc);
      filterMap.put(tag,filterDesc);
      rightOps[pos]=input;
      continue;
    }
    List<String> keyColNames=rsDesc.getOutputKeyColumnNames();
    List<String> valColNames=rsDesc.getOutputValueColumnNames();
    RowResolver inputRR=opParseCtx.get(input).getRowResolver();
    RowResolver parentRR=opParseCtx.get(parent).getRowResolver();
    posToAliasMap.put(pos,new HashSet<String>(inputRR.getTableNames()));
    List<ColumnInfo> columns=parentRR.getColumnInfos();
    for (int i=0; i < index.length; i++) {
      ColumnInfo prev=columns.get(i);
      String[] nm=parentRR.reverseLookup(prev.getInternalName());
      String[] nm2=parentRR.getAlternateMappings(prev.getInternalName());
      if (outputRR.get(nm[0],nm[1]) != null) {
        continue;
      }
      ColumnInfo info=new ColumnInfo(prev);
      String field;
      if (index[i] >= 0) {
        field=Utilities.ReduceField.KEY + "." + keyColNames.get(index[i]);
      }
 else {
        field=Utilities.ReduceField.VALUE + "." + valColNames.get(-index[i] - 1);
      }
      String internalName=getColumnInternalName(outputColumnNames.size());
      ExprNodeColumnDesc desc=new ExprNodeColumnDesc(info.getType(),field,info.getTabAlias(),info.getIsVirtualCol());
      info.setInternalName(internalName);
      colExprMap.put(internalName,desc);
      outputRR.put(nm[0],nm[1],info);
      if (nm2 != null) {
        outputRR.addMappingOnly(nm2[0],nm2[1],info);
      }
      valueDesc.add(desc);
      outputColumnNames.add(internalName);
      reversedExprs.put(internalName,tag);
    }
    for (    ASTNode cond : join.getFilters().get(tag)) {
      filterDesc.add(genExprNodeDesc(cond,inputRR));
    }
    exprMap.put(tag,valueDesc);
    filterMap.put(tag,filterDesc);
    rightOps[pos]=input;
  }
  JoinCondDesc[] joinCondns=new JoinCondDesc[join.getJoinCond().length];
  for (int i=0; i < join.getJoinCond().length; i++) {
    JoinCond condn=join.getJoinCond()[i];
    joinCondns[i]=new JoinCondDesc(condn);
  }
  JoinDesc desc=new JoinDesc(exprMap,outputColumnNames,join.getNoOuterJoin(),joinCondns,filterMap);
  desc.setReversedExprs(reversedExprs);
  desc.setFilterMap(join.getFilterMap());
  JoinOperator joinOp=(JoinOperator)OperatorFactory.getAndMakeChild(desc,new RowSchema(outputRR.getColumnInfos()),rightOps);
  joinOp.setColumnExprMap(colExprMap);
  joinOp.setPosToAliasMap(posToAliasMap);
  if (join.getNullSafes() != null) {
    boolean[] nullsafes=new boolean[join.getNullSafes().size()];
    for (int i=0; i < nullsafes.length; i++) {
      nullsafes[i]=join.getNullSafes().get(i);
    }
    desc.setNullSafes(nullsafes);
  }
  return putOpInsertMap(joinOp,outputRR);
}
