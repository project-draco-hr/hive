{
  List<ExprNodeDesc> columns=new ArrayList<ExprNodeDesc>();
  boolean needsCast=false;
  for (  Map.Entry<String,ColumnInfo> unionEntry : unionoutRR.getFieldMap(unionalias).entrySet()) {
    String field=unionEntry.getKey();
    ColumnInfo lInfo=origInputFieldMap.get(field);
    ExprNodeDesc column=new ExprNodeColumnDesc(lInfo.getType(),lInfo.getInternalName(),lInfo.getTabAlias(),lInfo.getIsVirtualCol(),lInfo.isSkewedCol());
    if (!lInfo.getType().equals(unionEntry.getValue().getType())) {
      needsCast=true;
      column=ParseUtils.createConversionCast(column,(PrimitiveTypeInfo)unionEntry.getValue().getType());
    }
    columns.add(column);
  }
  if (!needsCast) {
    return origInputOp;
  }
  RowResolver rowResolver=new RowResolver();
  Map<String,ExprNodeDesc> columnExprMap=new HashMap<String,ExprNodeDesc>();
  List<String> colName=new ArrayList<String>();
  for (int i=0; i < columns.size(); i++) {
    String name=getColumnInternalName(i);
    ColumnInfo col=new ColumnInfo(name,columns.get(i).getTypeInfo(),"",false);
    rowResolver.put(origInputAlias,name,col);
    colName.add(name);
    columnExprMap.put(name,columns.get(i));
  }
  Operator<SelectDesc> newInputOp=OperatorFactory.getAndMakeChild(new SelectDesc(columns,colName),new RowSchema(rowResolver.getColumnInfos()),columnExprMap,origInputOp);
  return putOpInsertMap(newInputOp,rowResolver);
}
