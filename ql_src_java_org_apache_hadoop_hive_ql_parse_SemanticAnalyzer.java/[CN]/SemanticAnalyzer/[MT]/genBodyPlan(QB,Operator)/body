{
  QBParseInfo qbp=qb.getParseInfo();
  TreeSet<String> ks=new TreeSet<String>(qbp.getClauseNames());
  boolean optimizeMultiGroupBy=(getCommonDistinctExprs(qb,input) != null);
  Operator curr=input;
  if (optimizeMultiGroupBy) {
    curr=createCommonReduceSink(qb,input);
    RowResolver currRR=opParseCtx.get(curr).getRR();
    input=putOpInsertMap(OperatorFactory.getAndMakeChild(new ForwardDesc(),new RowSchema(currRR.getColumnInfos()),curr),currRR);
    for (    String dest : ks) {
      curr=input;
      curr=genGroupByPlan2MRMultiGroupBy(dest,qb,curr);
      curr=genSelectPlan(dest,qb,curr);
      Integer limit=qbp.getDestLimit(dest);
      if (limit != null) {
        curr=genLimitMapRedPlan(dest,qb,curr,limit.intValue(),true);
        qb.getParseInfo().setOuterQueryLimit(limit.intValue());
      }
      curr=genFileSinkPlan(dest,qb,curr);
    }
  }
 else {
    for (    String dest : ks) {
      curr=input;
      if (qbp.getWhrForClause(dest) != null) {
        curr=genFilterPlan(dest,qb,curr);
      }
      if (qbp.getAggregationExprsForClause(dest).size() != 0 || getGroupByForClause(qbp,dest).size() > 0) {
        if (conf.getVar(HiveConf.ConfVars.HIVEGROUPBYSKEW).equalsIgnoreCase("true") && qbp.getDistinctFuncExprsForClause(dest).size() > 1) {
          throw new SemanticException(ErrorMsg.UNSUPPORTED_MULTIPLE_DISTINCTS.getMsg());
        }
        curr=insertSelectAllPlanForGroupBy(dest,curr);
        if (conf.getVar(HiveConf.ConfVars.HIVEMAPSIDEAGGREGATE).equalsIgnoreCase("true")) {
          if (conf.getVar(HiveConf.ConfVars.HIVEGROUPBYSKEW).equalsIgnoreCase("false")) {
            curr=genGroupByPlanMapAggr1MR(dest,qb,curr);
          }
 else {
            curr=genGroupByPlanMapAggr2MR(dest,qb,curr);
          }
        }
 else         if (conf.getVar(HiveConf.ConfVars.HIVEGROUPBYSKEW).equalsIgnoreCase("true")) {
          curr=genGroupByPlan2MR(dest,qb,curr);
        }
 else {
          curr=genGroupByPlan1MR(dest,qb,curr);
        }
      }
      curr=genSelectPlan(dest,qb,curr);
      Integer limit=qbp.getDestLimit(dest);
      if (qbp.getClusterByForClause(dest) != null || qbp.getDistributeByForClause(dest) != null || qbp.getOrderByForClause(dest) != null || qbp.getSortByForClause(dest) != null) {
        int numReducers=-1;
        if (qbp.getOrderByForClause(dest) != null) {
          numReducers=1;
        }
        curr=genReduceSinkPlan(dest,qb,curr,numReducers);
      }
      if (qbp.getIsSubQ()) {
        if (limit != null) {
          curr=genLimitMapRedPlan(dest,qb,curr,limit.intValue(),qbp.getOrderByForClause(dest) != null ? false : true);
        }
      }
 else {
        curr=genConversionOps(dest,qb,curr);
        if (limit != null) {
          boolean extraMRStep=true;
          if (qb.getIsQuery() && qbp.getClusterByForClause(dest) == null && qbp.getSortByForClause(dest) == null) {
            extraMRStep=false;
          }
          curr=genLimitMapRedPlan(dest,qb,curr,limit.intValue(),extraMRStep);
          qb.getParseInfo().setOuterQueryLimit(limit.intValue());
        }
        curr=genFileSinkPlan(dest,qb,curr);
      }
      if (qb.getParseInfo().getAlias() != null) {
        RowResolver rr=opParseCtx.get(curr).getRR();
        RowResolver newRR=new RowResolver();
        String alias=qb.getParseInfo().getAlias();
        for (        ColumnInfo colInfo : rr.getColumnInfos()) {
          String name=colInfo.getInternalName();
          String[] tmp=rr.reverseLookup(name);
          newRR.put(alias,tmp[1],colInfo);
        }
        opParseCtx.get(curr).setRR(newRR);
      }
    }
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("Created Body Plan for Query Block " + qb.getId());
  }
  return curr;
}
