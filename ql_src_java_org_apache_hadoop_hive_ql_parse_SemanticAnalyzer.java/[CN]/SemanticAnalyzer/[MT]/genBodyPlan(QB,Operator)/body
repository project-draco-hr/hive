{
  QBParseInfo qbp=qb.getParseInfo();
  TreeSet<String> ks=new TreeSet<String>(qbp.getClauseNames());
  List<ASTNode> commonDistinctExprs=getCommonDistinctExprs(qb,input);
  List<ASTNode> commonGbyKeys=getCommonGroupbyKeys(qb,input);
  LOG.warn("Common Gby keys:" + commonGbyKeys);
  boolean optimizeMultiGroupBy=commonDistinctExprs != null;
  boolean singlemrMultiGroupBy=conf.getBoolVar(HiveConf.ConfVars.HIVEMULTIGROUPBYSINGLEMR) && commonGbyKeys != null && !commonGbyKeys.isEmpty() && (!distinctExprsExists(qb) || commonDistinctExprs != null);
  Operator curr=input;
  if (singlemrMultiGroupBy) {
    curr=createCommonReduceSink1(qb,input);
    RowResolver currRR=opParseCtx.get(curr).getRowResolver();
    input=putOpInsertMap(OperatorFactory.getAndMakeChild(new ForwardDesc(),new RowSchema(currRR.getColumnInfos()),curr),currRR);
    for (    String dest : ks) {
      curr=input;
      curr=genGroupByPlan1MRMultiGroupBy(dest,qb,curr);
      curr=genSelectPlan(dest,qb,curr);
      Integer limit=qbp.getDestLimit(dest);
      if (limit != null) {
        curr=genLimitMapRedPlan(dest,qb,curr,limit.intValue(),true);
        qb.getParseInfo().setOuterQueryLimit(limit.intValue());
      }
      curr=genFileSinkPlan(dest,qb,curr);
    }
  }
 else   if (optimizeMultiGroupBy) {
    curr=createCommonReduceSink(qb,input);
    RowResolver currRR=opParseCtx.get(curr).getRowResolver();
    input=putOpInsertMap(OperatorFactory.getAndMakeChild(new ForwardDesc(),new RowSchema(currRR.getColumnInfos()),curr),currRR);
    for (    String dest : ks) {
      curr=input;
      curr=genGroupByPlan2MRMultiGroupBy(dest,qb,curr);
      curr=genSelectPlan(dest,qb,curr);
      Integer limit=qbp.getDestLimit(dest);
      if (limit != null) {
        curr=genLimitMapRedPlan(dest,qb,curr,limit.intValue(),true);
        qb.getParseInfo().setOuterQueryLimit(limit.intValue());
      }
      curr=genFileSinkPlan(dest,qb,curr);
    }
  }
 else {
    for (    String dest : ks) {
      curr=input;
      if (qbp.getWhrForClause(dest) != null) {
        curr=genFilterPlan(dest,qb,curr);
      }
      if (qbp.getAggregationExprsForClause(dest).size() != 0 || getGroupByForClause(qbp,dest).size() > 0) {
        if (conf.getBoolVar(HiveConf.ConfVars.HIVEGROUPBYSKEW) && qbp.getDistinctFuncExprsForClause(dest).size() > 1) {
          throw new SemanticException(ErrorMsg.UNSUPPORTED_MULTIPLE_DISTINCTS.getMsg());
        }
        curr=insertSelectAllPlanForGroupBy(dest,curr);
        if (conf.getBoolVar(HiveConf.ConfVars.HIVEMAPSIDEAGGREGATE)) {
          if (!conf.getBoolVar(HiveConf.ConfVars.HIVEGROUPBYSKEW)) {
            curr=genGroupByPlanMapAggr1MR(dest,qb,curr);
          }
 else {
            curr=genGroupByPlanMapAggr2MR(dest,qb,curr);
          }
        }
 else         if (conf.getBoolVar(HiveConf.ConfVars.HIVEGROUPBYSKEW)) {
          curr=genGroupByPlan2MR(dest,qb,curr);
        }
 else {
          curr=genGroupByPlan1MR(dest,qb,curr);
        }
      }
      if (qbp.getHavingForClause(dest) != null) {
        if (getGroupByForClause(qbp,dest).size() == 0) {
          throw new SemanticException("HAVING specified without GROUP BY");
        }
        curr=genHavingPlan(dest,qb,curr);
      }
      curr=genSelectPlan(dest,qb,curr);
      Integer limit=qbp.getDestLimit(dest);
      if (qbp.getClusterByForClause(dest) != null || qbp.getDistributeByForClause(dest) != null || qbp.getOrderByForClause(dest) != null || qbp.getSortByForClause(dest) != null) {
        int numReducers=-1;
        if (qbp.getOrderByForClause(dest) != null) {
          numReducers=1;
        }
        curr=genReduceSinkPlan(dest,qb,curr,numReducers);
      }
      if (qbp.getIsSubQ()) {
        if (limit != null) {
          curr=genLimitMapRedPlan(dest,qb,curr,limit.intValue(),qbp.getOrderByForClause(dest) != null ? false : true);
        }
      }
 else {
        curr=genConversionOps(dest,qb,curr);
        if (limit != null) {
          boolean extraMRStep=true;
          if (qb.getIsQuery() && qbp.getClusterByForClause(dest) == null && qbp.getSortByForClause(dest) == null) {
            extraMRStep=false;
          }
          curr=genLimitMapRedPlan(dest,qb,curr,limit.intValue(),extraMRStep);
          qb.getParseInfo().setOuterQueryLimit(limit.intValue());
        }
        curr=genFileSinkPlan(dest,qb,curr);
      }
      if (qb.getParseInfo().getAlias() != null) {
        RowResolver rr=opParseCtx.get(curr).getRowResolver();
        RowResolver newRR=new RowResolver();
        String alias=qb.getParseInfo().getAlias();
        for (        ColumnInfo colInfo : rr.getColumnInfos()) {
          String name=colInfo.getInternalName();
          String[] tmp=rr.reverseLookup(name);
          newRR.put(alias,tmp[1],colInfo);
        }
        opParseCtx.get(curr).setRowResolver(newRR);
      }
    }
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("Created Body Plan for Query Block " + qb.getId());
  }
  return curr;
}
