{
  QBParseInfo qbp=qb.getParseInfo();
  TreeSet<String> ks=new TreeSet<String>();
  ks.addAll(qbp.getClauseNames());
  Operator curr=null;
  for (  String dest : ks) {
    curr=input;
    if (qbp.getWhrForClause(dest) != null) {
      curr=genFilterPlan(dest,qb,curr);
    }
    if (qbp.getAggregationExprsForClause(dest).size() != 0 || getGroupByForClause(qbp,dest).size() > 0) {
      if (conf.getVar(HiveConf.ConfVars.HIVEMAPSIDEAGGREGATE).equalsIgnoreCase("true"))       curr=genGroupByPlan4MR(dest,qb,curr);
 else       curr=genGroupByPlan2MR(dest,qb,curr);
    }
    curr=genSelectPlan(dest,qb,curr);
    Integer limit=qbp.getDestLimit(dest);
    if (qbp.getClusterByForClause(dest) != null || qbp.getDistributeByForClause(dest) != null || qbp.getSortByForClause(dest) != null) {
      curr=genReduceSinkPlan(dest,qb,curr,-1);
    }
    if (qbp.getIsSubQ()) {
      if (limit != null) {
        curr=genLimitMapRedPlan(dest,qb,curr,limit.intValue(),false);
      }
    }
 else {
      curr=genConversionOps(dest,qb,curr);
      if (limit != null) {
        curr=genLimitMapRedPlan(dest,qb,curr,limit.intValue(),qb.getIsQuery());
        qb.getParseInfo().setOuterQueryLimit(limit.intValue());
      }
      curr=genFileSinkPlan(dest,qb,curr);
    }
    if (qb.getParseInfo().getAlias() != null) {
      RowResolver rr=opParseCtx.get(curr).getRR();
      RowResolver newRR=new RowResolver();
      String alias=qb.getParseInfo().getAlias();
      for (      ColumnInfo colInfo : rr.getColumnInfos()) {
        String name=colInfo.getInternalName();
        String[] tmp=rr.reverseLookup(name);
        newRR.put(alias,tmp[1],colInfo);
      }
      opParseCtx.get(curr).setRR(newRR);
    }
  }
  LOG.debug("Created Body Plan for Query Block " + qb.getId());
  return curr;
}
