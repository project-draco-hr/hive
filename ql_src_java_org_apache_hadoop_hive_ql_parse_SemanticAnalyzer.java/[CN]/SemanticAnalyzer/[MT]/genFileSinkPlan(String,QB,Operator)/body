{
  RowResolver inputRR=opParseCtx.get(input).getRR();
  QBMetaData qbm=qb.getMetaData();
  Integer dest_type=qbm.getDestTypeForAlias(dest);
  Table dest_tab;
  String queryTmpdir;
  Path dest_path;
  tableDesc table_desc=null;
  int currentTableId=0;
  boolean isLocal=false;
switch (dest_type.intValue()) {
case QBMetaData.DEST_TABLE:
{
      dest_tab=qbm.getDestTableForAlias(dest);
      dest_path=dest_tab.getPath();
      queryTmpdir=ctx.getExternalTmpFileURI(dest_path.toUri());
      table_desc=Utilities.getTableDesc(dest_tab);
      this.idToTableNameMap.put(String.valueOf(this.destTableId),dest_tab.getName());
      currentTableId=this.destTableId;
      this.destTableId++;
      this.loadTableWork.add(new loadTableDesc(queryTmpdir,ctx.getExternalTmpFileURI(dest_path.toUri()),table_desc,new HashMap<String,String>()));
      outputs.add(new WriteEntity(dest_tab));
      break;
    }
case QBMetaData.DEST_PARTITION:
{
    Partition dest_part=qbm.getDestPartitionForAlias(dest);
    dest_tab=dest_part.getTable();
    dest_path=dest_part.getPath()[0];
    queryTmpdir=ctx.getExternalTmpFileURI(dest_path.toUri());
    table_desc=Utilities.getTableDesc(dest_tab);
    this.idToTableNameMap.put(String.valueOf(this.destTableId),dest_tab.getName());
    currentTableId=this.destTableId;
    this.destTableId++;
    this.loadTableWork.add(new loadTableDesc(queryTmpdir,ctx.getExternalTmpFileURI(dest_path.toUri()),table_desc,dest_part.getSpec()));
    outputs.add(new WriteEntity(dest_part));
    break;
  }
case QBMetaData.DEST_LOCAL_FILE:
isLocal=true;
case QBMetaData.DEST_DFS_FILE:
{
dest_path=new Path(qbm.getDestFileForAlias(dest));
String destStr=dest_path.toString();
if (isLocal) {
  queryTmpdir=ctx.getMRTmpFileURI();
}
 else {
  try {
    Path qPath=FileUtils.makeQualified(dest_path,conf);
    queryTmpdir=ctx.getExternalTmpFileURI(qPath.toUri());
  }
 catch (  Exception e) {
    throw new SemanticException("Error creating temporary folder on: " + dest_path,e);
  }
}
String cols=new String();
Vector<ColumnInfo> colInfos=inputRR.getColumnInfos();
boolean first=true;
for (ColumnInfo colInfo : colInfos) {
  String[] nm=inputRR.reverseLookup(colInfo.getInternalName());
  if (!first)   cols=cols.concat(",");
  first=false;
  if (nm[0] == null)   cols=cols.concat(nm[1]);
 else   cols=cols.concat(nm[0] + "." + nm[1]);
}
if (!ctx.isMRTmpFileURI(destStr)) {
  this.idToTableNameMap.put(String.valueOf(this.destTableId),destStr);
  currentTableId=this.destTableId;
  this.destTableId++;
}
boolean isDfsDir=(dest_type.intValue() == QBMetaData.DEST_DFS_FILE);
this.loadFileWork.add(new loadFileDesc(queryTmpdir,destStr,isDfsDir,cols));
table_desc=PlanUtils.getDefaultTableDesc(Integer.toString(Utilities.ctrlaCode),cols);
outputs.add(new WriteEntity(destStr,!isDfsDir));
break;
}
default :
throw new SemanticException("Unknown destination type: " + dest_type);
}
input=genConversionSelectOperator(dest,qb,input,table_desc);
inputRR=opParseCtx.get(input).getRR();
Vector<ColumnInfo> vecCol=new Vector<ColumnInfo>();
try {
StructObjectInspector rowObjectInspector=(StructObjectInspector)table_desc.getDeserializer().getObjectInspector();
List<? extends StructField> fields=rowObjectInspector.getAllStructFieldRefs();
for (int i=0; i < fields.size(); i++) vecCol.add(new ColumnInfo(fields.get(i).getFieldName(),TypeInfoUtils.getTypeInfoFromObjectInspector(fields.get(i).getFieldObjectInspector())));
}
 catch (Exception e) {
throw new SemanticException(e.getMessage());
}
RowSchema fsRS=new RowSchema(vecCol);
Operator output=putOpInsertMap(OperatorFactory.getAndMakeChild(new fileSinkDesc(queryTmpdir,table_desc,conf.getBoolVar(HiveConf.ConfVars.COMPRESSRESULT),currentTableId),fsRS,input),inputRR);
LOG.debug("Created FileSink Plan for clause: " + dest + "dest_path: "+ dest_path+ " row schema: "+ inputRR.toString());
return output;
}
