{
  ArrayList<Class<?>> argumentClasses=new ArrayList<Class<?>>(children.size());
  for (int i=0; i < children.size(); i++) {
    exprNodeDesc child=children.get(i);
    assert(child != null);
    TypeInfo childTypeInfo=child.getTypeInfo();
    assert(childTypeInfo != null);
    argumentClasses.add(childTypeInfo.getPrimitiveClass());
  }
  Method udfMethod=FunctionRegistry.getUDFMethod(udfName,false,argumentClasses);
  if (udfMethod == null)   return null;
  ArrayList<exprNodeDesc> ch=new ArrayList<exprNodeDesc>();
  Class<?>[] pTypes=udfMethod.getParameterTypes();
  for (int i=0; i < children.size(); i++) {
    exprNodeDesc desc=children.get(i);
    Class<?> pType=TypeInfo.generalizePrimitive(pTypes[i]);
    if (desc instanceof exprNodeNullDesc) {
      exprNodeConstantDesc newCh=new exprNodeConstantDesc(TypeInfo.getPrimitiveTypeInfo(pType),null);
      ch.add(newCh);
    }
 else     if (pType.isAssignableFrom(desc.getTypeInfo().getPrimitiveClass())) {
      ch.add(desc);
    }
 else {
      Class<?> from=argumentClasses.get(i);
      Class<?> to=pType;
      assert(FunctionRegistry.implicitConvertable(from,to));
      Method m=FunctionRegistry.getUDFMethod(to.getName(),true,from);
      assert(m != null);
      Class<? extends UDF> c=FunctionRegistry.getUDFClass(to.getName());
      assert(c != null);
      ArrayList<exprNodeDesc> conversionArg=new ArrayList<exprNodeDesc>(1);
      conversionArg.add(desc);
      ch.add(new exprNodeFuncDesc(TypeInfo.getPrimitiveTypeInfo(pType),c,m,conversionArg));
    }
  }
  exprNodeFuncDesc desc=new exprNodeFuncDesc(TypeInfo.getPrimitiveTypeInfo(TypeInfo.generalizePrimitive(udfMethod.getReturnType())),FunctionRegistry.getUDFClass(udfName),udfMethod,ch);
  return desc;
}
