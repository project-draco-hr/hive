{
  StructObjectInspector oi=null;
  try {
    Deserializer deserializer=table_desc.getDeserializerClass().newInstance();
    SerDeUtils.initializeSerDe(deserializer,conf,table_desc.getProperties(),null);
    oi=(StructObjectInspector)deserializer.getObjectInspector();
  }
 catch (  Exception e) {
    throw new SemanticException(e);
  }
  List<? extends StructField> tableFields=oi.getAllStructFieldRefs();
  boolean dynPart=HiveConf.getBoolVar(conf,HiveConf.ConfVars.DYNAMICPARTITIONING);
  ArrayList<ColumnInfo> rowFields=opParseCtx.get(input).getRowResolver().getColumnInfos();
  int inColumnCnt=rowFields.size();
  int outColumnCnt=tableFields.size();
  if (dynPart && dpCtx != null) {
    outColumnCnt+=dpCtx.getNumDPCols();
  }
  if (!updating() && !deleting() && inColumnCnt != outColumnCnt) {
    String reason="Table " + dest + " has "+ outColumnCnt+ " columns, but query has "+ inColumnCnt+ " columns.";
    throw new SemanticException(ErrorMsg.TARGET_TABLE_COLUMN_MISMATCH.getMsg(qb.getParseInfo().getDestForClause(dest),reason));
  }
  boolean converted=false;
  int columnNumber=tableFields.size();
  ArrayList<ExprNodeDesc> expressions=new ArrayList<ExprNodeDesc>(columnNumber);
  boolean isMetaDataSerDe=table_desc.getDeserializerClass().equals(MetadataTypedColumnsetSerDe.class);
  boolean isLazySimpleSerDe=table_desc.getDeserializerClass().equals(LazySimpleSerDe.class);
  if (!isMetaDataSerDe && !deleting()) {
    if (updating()) {
      expressions.add(new ExprNodeColumnDesc(rowFields.get(0).getType(),rowFields.get(0).getInternalName(),"",true));
    }
    for (int i=0; i < columnNumber; i++) {
      int rowFieldsOffset=updating() ? i + 1 : i;
      ObjectInspector tableFieldOI=tableFields.get(i).getFieldObjectInspector();
      TypeInfo tableFieldTypeInfo=TypeInfoUtils.getTypeInfoFromObjectInspector(tableFieldOI);
      TypeInfo rowFieldTypeInfo=rowFields.get(rowFieldsOffset).getType();
      ExprNodeDesc column=new ExprNodeColumnDesc(rowFieldTypeInfo,rowFields.get(rowFieldsOffset).getInternalName(),"",false,rowFields.get(rowFieldsOffset).isSkewedCol());
      if (!tableFieldTypeInfo.equals(rowFieldTypeInfo) && !(isLazySimpleSerDe && tableFieldTypeInfo.getCategory().equals(Category.PRIMITIVE) && tableFieldTypeInfo.equals(TypeInfoFactory.stringTypeInfo))) {
        converted=true;
        if (tableFieldTypeInfo.getCategory() != Category.PRIMITIVE) {
          column=null;
        }
 else {
          column=ParseUtils.createConversionCast(column,(PrimitiveTypeInfo)tableFieldTypeInfo);
        }
        if (column == null) {
          String reason="Cannot convert column " + i + " from "+ rowFieldTypeInfo+ " to "+ tableFieldTypeInfo+ ".";
          throw new SemanticException(ErrorMsg.TARGET_TABLE_COLUMN_MISMATCH.getMsg(qb.getParseInfo().getDestForClause(dest),reason));
        }
      }
      expressions.add(column);
    }
  }
  if (dynPart && dpCtx != null && dpCtx.getNumDPCols() > 0) {
    for (int i=tableFields.size() + (updating() ? 1 : 0); i < rowFields.size(); ++i) {
      TypeInfo rowFieldTypeInfo=rowFields.get(i).getType();
      ExprNodeDesc column=new ExprNodeColumnDesc(rowFieldTypeInfo,rowFields.get(i).getInternalName(),"",true);
      expressions.add(column);
    }
  }
  if (converted) {
    RowResolver rowResolver=new RowResolver();
    ArrayList<String> colNames=new ArrayList<String>();
    Map<String,ExprNodeDesc> colExprMap=new HashMap<String,ExprNodeDesc>();
    for (int i=0; i < expressions.size(); i++) {
      String name=getColumnInternalName(i);
      rowResolver.put("",name,new ColumnInfo(name,expressions.get(i).getTypeInfo(),"",false));
      colNames.add(name);
      colExprMap.put(name,expressions.get(i));
    }
    input=putOpInsertMap(OperatorFactory.getAndMakeChild(new SelectDesc(expressions,colNames),new RowSchema(rowResolver.getColumnInfos()),input),rowResolver);
    input.setColumnExprMap(colExprMap);
  }
  rowFields=opParseCtx.get(input).getRowResolver().getColumnInfos();
  if (deleting()) {
    if (rowFields.size() > 1) {
      dpCtx.mapInputToDP(rowFields.subList(1,rowFields.size()));
    }
  }
 else   if (updating()) {
    if (dynPart && dpCtx != null) {
      dpCtx.mapInputToDP(rowFields.subList(tableFields.size() + 1,rowFields.size()));
    }
  }
 else {
    if (dynPart && dpCtx != null) {
      dpCtx.mapInputToDP(rowFields.subList(tableFields.size(),rowFields.size()));
    }
  }
  return input;
}
