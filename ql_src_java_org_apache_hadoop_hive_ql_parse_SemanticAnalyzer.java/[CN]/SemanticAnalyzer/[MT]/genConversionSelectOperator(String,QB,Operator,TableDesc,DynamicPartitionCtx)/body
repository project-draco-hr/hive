{
  StructObjectInspector oi=null;
  try {
    Deserializer deserializer=table_desc.getDeserializerClass().newInstance();
    deserializer.initialize(conf,table_desc.getProperties());
    oi=(StructObjectInspector)deserializer.getObjectInspector();
  }
 catch (  Exception e) {
    throw new SemanticException(e);
  }
  List<? extends StructField> tableFields=oi.getAllStructFieldRefs();
  boolean dynPart=HiveConf.getBoolVar(conf,HiveConf.ConfVars.DYNAMICPARTITIONING);
  ArrayList<ColumnInfo> rowFields=opParseCtx.get(input).getRR().getColumnInfos();
  if (tableFields.size() != rowFields.size()) {
    if (!dynPart || dpCtx == null || tableFields.size() + dpCtx.getNumDPCols() != rowFields.size()) {
      String reason="Table " + dest + " has "+ tableFields.size()+ " columns but query has "+ rowFields.size()+ " columns.";
      throw new SemanticException(ErrorMsg.TARGET_TABLE_COLUMN_MISMATCH.getMsg(qb.getParseInfo().getDestForClause(dest),reason));
    }
 else {
      dpCtx.mapInputToDP(rowFields.subList(tableFields.size(),rowFields.size()));
    }
  }
  boolean converted=false;
  int columnNumber=tableFields.size();
  ArrayList<ExprNodeDesc> expressions=new ArrayList<ExprNodeDesc>(columnNumber);
  boolean isMetaDataSerDe=table_desc.getDeserializerClass().equals(MetadataTypedColumnsetSerDe.class);
  boolean isLazySimpleSerDe=table_desc.getDeserializerClass().equals(LazySimpleSerDe.class);
  if (!isMetaDataSerDe) {
    for (int i=0; i < columnNumber; i++) {
      ObjectInspector tableFieldOI=tableFields.get(i).getFieldObjectInspector();
      TypeInfo tableFieldTypeInfo=TypeInfoUtils.getTypeInfoFromObjectInspector(tableFieldOI);
      TypeInfo rowFieldTypeInfo=rowFields.get(i).getType();
      ExprNodeDesc column=new ExprNodeColumnDesc(rowFieldTypeInfo,rowFields.get(i).getInternalName(),"",false);
      if (!tableFieldTypeInfo.equals(rowFieldTypeInfo) && !(isLazySimpleSerDe && tableFieldTypeInfo.getCategory().equals(Category.PRIMITIVE) && tableFieldTypeInfo.equals(TypeInfoFactory.stringTypeInfo))) {
        converted=true;
        if (tableFieldTypeInfo.getCategory() != Category.PRIMITIVE) {
          column=null;
        }
 else {
          column=TypeCheckProcFactory.DefaultExprProcessor.getFuncExprNodeDesc(tableFieldTypeInfo.getTypeName(),column);
        }
        if (column == null) {
          String reason="Cannot convert column " + i + " from "+ rowFieldTypeInfo+ " to "+ tableFieldTypeInfo+ ".";
          throw new SemanticException(ErrorMsg.TARGET_TABLE_COLUMN_MISMATCH.getMsg(qb.getParseInfo().getDestForClause(dest),reason));
        }
      }
      expressions.add(column);
    }
  }
  if (dynPart && dpCtx != null && dpCtx.getNumDPCols() > 0) {
    for (int i=tableFields.size(); i < rowFields.size(); ++i) {
      TypeInfo rowFieldTypeInfo=rowFields.get(i).getType();
      ExprNodeDesc column=new ExprNodeColumnDesc(rowFieldTypeInfo,rowFields.get(i).getInternalName(),"",false);
      expressions.add(column);
    }
  }
  if (converted) {
    RowResolver rowResolver=new RowResolver();
    ArrayList<String> colName=new ArrayList<String>();
    for (int i=0; i < expressions.size(); i++) {
      String name=getColumnInternalName(i);
      rowResolver.put("",name,new ColumnInfo(name,expressions.get(i).getTypeInfo(),"",false));
      colName.add(name);
    }
    Operator output=putOpInsertMap(OperatorFactory.getAndMakeChild(new SelectDesc(expressions,colName),new RowSchema(rowResolver.getColumnInfos()),input),rowResolver);
    return output;
  }
 else {
    return input;
  }
}
