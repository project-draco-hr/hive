{
  ArrayList<String> outputColumnNames=new ArrayList<String>();
  RowResolver groupByInputRowResolver=opParseCtx.get(reduceSinkOperatorInfo).getRowResolver();
  RowResolver groupByOutputRowResolver=new RowResolver();
  groupByOutputRowResolver.setIsExprResolver(true);
  ArrayList<ExprNodeDesc> groupByKeys=new ArrayList<ExprNodeDesc>();
  ArrayList<AggregationDesc> aggregations=new ArrayList<AggregationDesc>();
  List<ASTNode> grpByExprs=getGroupByForClause(parseInfo,dest);
  Map<String,ExprNodeDesc> colExprMap=new HashMap<String,ExprNodeDesc>();
  for (int i=0; i < grpByExprs.size(); ++i) {
    ASTNode grpbyExpr=grpByExprs.get(i);
    ColumnInfo exprInfo=groupByInputRowResolver.getExpression(grpbyExpr);
    if (exprInfo == null) {
      throw new SemanticException(ErrorMsg.INVALID_COLUMN.getMsg(grpbyExpr));
    }
    groupByKeys.add(new ExprNodeColumnDesc(exprInfo));
    String field=getColumnInternalName(i);
    outputColumnNames.add(field);
    ColumnInfo oColInfo=new ColumnInfo(field,exprInfo.getType(),"",false);
    groupByOutputRowResolver.putExpression(grpbyExpr,oColInfo);
    addAlternateGByKeyMappings(grpbyExpr,oColInfo,reduceSinkOperatorInfo,groupByOutputRowResolver);
    colExprMap.put(field,groupByKeys.get(groupByKeys.size() - 1));
  }
  int groupingSetsPosition=-1;
  if (groupingSetsPresent) {
    groupingSetsPosition=groupByKeys.size();
    if (!groupingSetsNeedAdditionalMRJob) {
      addGroupingSetKey(groupByKeys,groupByInputRowResolver,groupByOutputRowResolver,outputColumnNames,colExprMap);
    }
 else {
      createNewGroupingKey(groupByKeys,outputColumnNames,groupByOutputRowResolver,colExprMap);
    }
  }
  HashMap<String,ASTNode> aggregationTrees=parseInfo.getAggregationExprsForClause(dest);
  String lastKeyColName=null;
  List<ExprNodeDesc> reduceValues=null;
  if (reduceSinkOperatorInfo.getConf() instanceof ReduceSinkDesc) {
    List<String> inputKeyCols=((ReduceSinkDesc)reduceSinkOperatorInfo.getConf()).getOutputKeyColumnNames();
    if (inputKeyCols.size() > 0) {
      lastKeyColName=inputKeyCols.get(inputKeyCols.size() - 1);
    }
    reduceValues=((ReduceSinkDesc)reduceSinkOperatorInfo.getConf()).getValueCols();
  }
  int numDistinctUDFs=0;
  boolean containsDistinctAggr=false;
  for (  Map.Entry<String,ASTNode> entry : aggregationTrees.entrySet()) {
    ASTNode value=entry.getValue();
    String aggName=unescapeIdentifier(value.getChild(0).getText());
    ArrayList<ExprNodeDesc> aggParameters=new ArrayList<ExprNodeDesc>();
    boolean isDistinct=(value.getType() == HiveParser.TOK_FUNCTIONDI);
    containsDistinctAggr=containsDistinctAggr || isDistinct;
    if (isDistinct) {
      for (int i=1; i < value.getChildCount(); i++) {
        ASTNode paraExpr=(ASTNode)value.getChild(i);
        ColumnInfo paraExprInfo=groupByInputRowResolver.getExpression(paraExpr);
        if (paraExprInfo == null) {
          throw new SemanticException(ErrorMsg.INVALID_COLUMN.getMsg(paraExpr));
        }
        String paraExpression=paraExprInfo.getInternalName();
        assert(paraExpression != null);
        if (isDistinct && lastKeyColName != null) {
          paraExpression=Utilities.ReduceField.KEY.name() + "." + lastKeyColName+ ":"+ numDistinctUDFs+ "."+ getColumnInternalName(i - 1);
        }
        ExprNodeDesc expr=new ExprNodeColumnDesc(paraExprInfo.getType(),paraExpression,paraExprInfo.getTabAlias(),paraExprInfo.getIsVirtualCol());
        ExprNodeDesc reduceValue=isConstantParameterInAggregationParameters(paraExprInfo.getInternalName(),reduceValues);
        if (reduceValue != null) {
          expr=reduceValue;
        }
        aggParameters.add(expr);
      }
    }
 else {
      ColumnInfo paraExprInfo=groupByInputRowResolver.getExpression(value);
      if (paraExprInfo == null) {
        throw new SemanticException(ErrorMsg.INVALID_COLUMN.getMsg(value));
      }
      String paraExpression=paraExprInfo.getInternalName();
      assert(paraExpression != null);
      aggParameters.add(new ExprNodeColumnDesc(paraExprInfo.getType(),paraExpression,paraExprInfo.getTabAlias(),paraExprInfo.getIsVirtualCol()));
    }
    if (isDistinct) {
      numDistinctUDFs++;
    }
    Mode amode=groupByDescModeToUDAFMode(mode,isDistinct);
    GenericUDAFEvaluator genericUDAFEvaluator=null;
    genericUDAFEvaluator=genericUDAFEvaluators.get(entry.getKey());
    assert(genericUDAFEvaluator != null);
    GenericUDAFInfo udaf=getGenericUDAFInfo(genericUDAFEvaluator,amode,aggParameters);
    aggregations.add(new AggregationDesc(aggName.toLowerCase(),udaf.genericUDAFEvaluator,udaf.convertedParameters,(mode != GroupByDesc.Mode.FINAL && isDistinct),amode));
    String field=getColumnInternalName(groupByKeys.size() + aggregations.size() - 1);
    outputColumnNames.add(field);
    groupByOutputRowResolver.putExpression(value,new ColumnInfo(field,udaf.returnType,"",false));
  }
  float groupByMemoryUsage=HiveConf.getFloatVar(conf,HiveConf.ConfVars.HIVEMAPAGGRHASHMEMORY);
  float memoryThreshold=HiveConf.getFloatVar(conf,HiveConf.ConfVars.HIVEMAPAGGRMEMORYTHRESHOLD);
  Operator op=putOpInsertMap(OperatorFactory.getAndMakeChild(new GroupByDesc(mode,outputColumnNames,groupByKeys,aggregations,groupByMemoryUsage,memoryThreshold,groupingSets,groupingSetsPresent && groupingSetsNeedAdditionalMRJob,groupingSetsPosition,containsDistinctAggr),new RowSchema(groupByOutputRowResolver.getColumnInfos()),reduceSinkOperatorInfo),groupByOutputRowResolver);
  op.setColumnExprMap(colExprMap);
  return op;
}
