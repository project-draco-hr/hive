{
  RowResolver groupByInputRowResolver2=opParseCtx.get(reduceSinkOperatorInfo2).getRR();
  RowResolver groupByOutputRowResolver2=new RowResolver();
  groupByOutputRowResolver2.setIsExprResolver(true);
  ArrayList<exprNodeDesc> groupByKeys=new ArrayList<exprNodeDesc>();
  ArrayList<aggregationDesc> aggregations=new ArrayList<aggregationDesc>();
  ArrayList<String> evalMethods=new ArrayList<String>();
  ArrayList<String> aggMethods=new ArrayList<String>();
  Map<String,exprNodeDesc> colExprMap=new HashMap<String,exprNodeDesc>();
  List<ASTNode> grpByExprs=getGroupByForClause(parseInfo,dest);
  ArrayList<String> outputColumnNames=new ArrayList<String>();
  for (int i=0; i < grpByExprs.size(); ++i) {
    ASTNode grpbyExpr=grpByExprs.get(i);
    String text=grpbyExpr.toStringTree();
    ColumnInfo exprInfo=groupByInputRowResolver2.get("",text);
    if (exprInfo == null) {
      throw new SemanticException(ErrorMsg.INVALID_COLUMN.getMsg(grpbyExpr));
    }
    String expression=exprInfo.getInternalName();
    groupByKeys.add(new exprNodeColumnDesc(exprInfo.getType(),expression));
    String field=getColumnInternalName(i);
    outputColumnNames.add(field);
    groupByOutputRowResolver2.put("",grpbyExpr.toStringTree(),new ColumnInfo(field,exprInfo.getType()));
    colExprMap.put(field,groupByKeys.get(groupByKeys.size() - 1));
  }
  HashMap<String,ASTNode> aggregationTrees=parseInfo.getAggregationExprsForClause(dest);
  for (  Map.Entry<String,ASTNode> entry : aggregationTrees.entrySet()) {
    ArrayList<exprNodeDesc> aggParameters=new ArrayList<exprNodeDesc>();
    ASTNode value=entry.getValue();
    String text=entry.getKey();
    ColumnInfo paraExprInfo=groupByInputRowResolver2.get("",text);
    if (paraExprInfo == null) {
      throw new SemanticException(ErrorMsg.INVALID_COLUMN.getMsg(value));
    }
    String paraExpression=paraExprInfo.getInternalName();
    assert(paraExpression != null);
    aggParameters.add(new exprNodeColumnDesc(paraExprInfo.getType(),paraExpression));
    String aggName=value.getChild(0).getText();
    Class<? extends UDAF> aggClass=FunctionRegistry.getUDAF(aggName);
    assert(aggClass != null);
    UDAFInfo udaf=getUDAFInfo(aggName,mode,aggParameters,value);
    aggregations.add(new aggregationDesc(udaf.evalClass,udaf.convertedParameters,((mode == groupByDesc.Mode.FINAL) ? false : (value.getToken().getType() == HiveParser.TOK_FUNCTIONDI))));
    evalMethods.add(udaf.evalMethod.getName());
    aggMethods.add(udaf.aggMethod.getName());
    String field=getColumnInternalName(groupByKeys.size() + aggregations.size() - 1);
    outputColumnNames.add(field);
    groupByOutputRowResolver2.put("",value.toStringTree(),new ColumnInfo(field,udaf.retType));
  }
  Operator op=putOpInsertMap(OperatorFactory.getAndMakeChild(new groupByDesc(mode,outputColumnNames,groupByKeys,aggregations,evalMethods,aggMethods),new RowSchema(groupByOutputRowResolver2.getColumnInfos()),reduceSinkOperatorInfo2),groupByOutputRowResolver2);
  op.setColumnExprMap(colExprMap);
  return op;
}
