{
  QBJoinTree joinTree=new QBJoinTree();
  joinTree.setNoOuterJoin(false);
  joinTree.setExpressions(new Vector<Vector<ASTNode>>());
  joinTree.setFilters(new Vector<Vector<ASTNode>>());
  Vector<String> rightAliases=new Vector<String>();
  Vector<String> leftAliases=new Vector<String>();
  Vector<String> baseSrc=new Vector<String>();
  Vector<Boolean> preserved=new Vector<Boolean>();
  boolean lastPreserved=false;
  int cols=-1;
  for (int i=0; i < joinParseTree.getChildCount(); i++) {
    ASTNode child=(ASTNode)joinParseTree.getChild(i);
switch (child.getToken().getType()) {
case HiveParser.TOK_TABREF:
      String table_name=unescapeIdentifier(child.getChild(0).getText());
    String alias=child.getChildCount() == 1 ? table_name : unescapeIdentifier(child.getChild(child.getChildCount() - 1).getText().toLowerCase());
  if (i == 0) {
    leftAliases.add(alias);
    joinTree.setLeftAlias(alias);
  }
 else {
    rightAliases.add(alias);
  }
baseSrc.add(alias);
preserved.add(lastPreserved);
lastPreserved=false;
break;
case HiveParser.TOK_EXPLIST:
if (cols == -1 && child.getChildCount() != 0) {
cols=child.getChildCount();
}
 else if (child.getChildCount() != cols) {
throw new SemanticException("Tables with different or invalid " + "number of keys in UNIQUEJOIN");
}
Vector<ASTNode> expressions=new Vector<ASTNode>();
Vector<ASTNode> filt=new Vector<ASTNode>();
for (Node exp : child.getChildren()) {
expressions.add((ASTNode)exp);
}
joinTree.getExpressions().add(expressions);
joinTree.getFilters().add(filt);
break;
case HiveParser.KW_PRESERVE:
lastPreserved=true;
break;
case HiveParser.TOK_SUBQUERY:
throw new SemanticException("Subqueries are not supported in UNIQUEJOIN");
default :
throw new SemanticException("Unexpected UNIQUEJOIN structure");
}
}
joinTree.setBaseSrc(baseSrc.toArray(new String[0]));
joinTree.setLeftAliases(leftAliases.toArray(new String[0]));
joinTree.setRightAliases(rightAliases.toArray(new String[0]));
joinCond[] condn=new joinCond[preserved.size()];
for (int i=0; i < condn.length; i++) {
condn[i]=new joinCond(preserved.get(i));
}
joinTree.setJoinCond(condn);
return joinTree;
}
