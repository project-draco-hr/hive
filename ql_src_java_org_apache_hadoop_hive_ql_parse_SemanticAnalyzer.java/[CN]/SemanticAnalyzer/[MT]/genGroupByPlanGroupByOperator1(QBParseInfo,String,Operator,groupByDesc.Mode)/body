{
  RowResolver groupByInputRowResolver=opParseCtx.get(reduceSinkOperatorInfo).getRR();
  RowResolver groupByOutputRowResolver=new RowResolver();
  groupByOutputRowResolver.setIsExprResolver(true);
  ArrayList<exprNodeDesc> groupByKeys=new ArrayList<exprNodeDesc>();
  ArrayList<aggregationDesc> aggregations=new ArrayList<aggregationDesc>();
  List<CommonTree> grpByExprs=getGroupByForClause(parseInfo,dest);
  for (int i=0; i < grpByExprs.size(); ++i) {
    CommonTree grpbyExpr=grpByExprs.get(i);
    String text=grpbyExpr.toStringTree();
    ColumnInfo exprInfo=groupByInputRowResolver.get("",text);
    if (exprInfo == null) {
      throw new SemanticException(ErrorMsg.INVALID_COLUMN.getMsg(grpbyExpr));
    }
    groupByKeys.add(new exprNodeColumnDesc(exprInfo.getType(),exprInfo.getInternalName()));
    String field=(Integer.valueOf(i)).toString();
    groupByOutputRowResolver.put("",grpbyExpr.toStringTree(),new ColumnInfo(field,exprInfo.getType()));
  }
  if (parseInfo.getDistinctFuncExprForClause(dest) != null) {
    CommonTree value=parseInfo.getDistinctFuncExprForClause(dest);
    String aggName=value.getChild(0).getText();
    Class<? extends UDAF> aggClass=FunctionRegistry.getUDAF(aggName);
    assert(aggClass != null);
    ArrayList<exprNodeDesc> aggParameters=new ArrayList<exprNodeDesc>();
    ArrayList<Class<?>> aggClasses=new ArrayList<Class<?>>();
    for (int i=1; i < value.getChildCount(); i++) {
      String text=value.getChild(i).toStringTree();
      CommonTree paraExpr=(CommonTree)value.getChild(i);
      ColumnInfo paraExprInfo=groupByInputRowResolver.get("",text);
      if (paraExprInfo == null) {
        throw new SemanticException(ErrorMsg.INVALID_COLUMN.getMsg(paraExpr));
      }
      String paraExpression=paraExprInfo.getInternalName();
      assert(paraExpression != null);
      aggParameters.add(new exprNodeColumnDesc(paraExprInfo.getType(),paraExprInfo.getInternalName()));
      aggClasses.add(paraExprInfo.getType().getPrimitiveClass());
    }
    UDAFInfo udaf=getUDAFInfo(aggName,mode,aggClasses,aggParameters,value);
    aggregations.add(new aggregationDesc(aggClass,udaf.convertedParameters,true));
    groupByOutputRowResolver.put("",value.toStringTree(),new ColumnInfo(Integer.valueOf(groupByKeys.size() + aggregations.size() - 1).toString(),udaf.evaluateMethod.getReturnType()));
  }
  HashMap<String,CommonTree> aggregationTrees=parseInfo.getAggregationExprsForClause(dest);
  for (  Map.Entry<String,CommonTree> entry : aggregationTrees.entrySet()) {
    CommonTree value=entry.getValue();
    if (value.getToken().getType() == HiveParser.TOK_FUNCTIONDI)     continue;
    String aggName=value.getChild(0).getText();
    Class<? extends UDAF> aggClass=FunctionRegistry.getUDAF(aggName);
    Method aggEvaluateMethod=FunctionRegistry.getUDAFEvaluateMethod(aggName,mode);
    assert(aggClass != null);
    ArrayList<exprNodeDesc> aggParameters=new ArrayList<exprNodeDesc>();
    String text=entry.getKey();
    ColumnInfo paraExprInfo=groupByInputRowResolver.get("",text);
    if (paraExprInfo == null) {
      throw new SemanticException(ErrorMsg.INVALID_COLUMN.getMsg(value));
    }
    String paraExpression=paraExprInfo.getInternalName();
    assert(paraExpression != null);
    aggParameters.add(new exprNodeColumnDesc(paraExprInfo.getType(),paraExpression));
    aggregations.add(new aggregationDesc(aggClass,aggParameters,((mode == groupByDesc.Mode.FINAL) ? false : (value.getToken().getType() == HiveParser.TOK_FUNCTIONDI))));
    groupByOutputRowResolver.put("",value.toStringTree(),new ColumnInfo(Integer.valueOf(groupByKeys.size() + aggregations.size() - 1).toString(),aggEvaluateMethod.getReturnType()));
  }
  return putOpInsertMap(OperatorFactory.getAndMakeChild(new groupByDesc(mode,groupByKeys,aggregations),new RowSchema(groupByOutputRowResolver.getColumnInfos()),reduceSinkOperatorInfo),groupByOutputRowResolver);
}
