{
  QBParseInfo qbp=qb.getParseInfo();
  if (qbp.getHavingForClause(dest) != null) {
    if (getGroupByForClause(qbp,dest).size() == 0) {
      throw new SemanticException("HAVING specified without GROUP BY");
    }
    curr=genHavingPlan(dest,qb,curr);
  }
  curr=genSelectPlan(dest,qb,curr);
  Integer limit=qbp.getDestLimit(dest);
  if (qbp.getClusterByForClause(dest) != null || qbp.getDistributeByForClause(dest) != null || qbp.getOrderByForClause(dest) != null || qbp.getSortByForClause(dest) != null) {
    int numReducers=-1;
    if (qbp.getOrderByForClause(dest) != null) {
      numReducers=1;
    }
    curr=genReduceSinkPlan(dest,qb,curr,numReducers);
  }
  if (qbp.getIsSubQ()) {
    if (limit != null) {
      curr=genLimitMapRedPlan(dest,qb,curr,limit.intValue(),qbp.getOrderByForClause(dest) != null ? false : true);
    }
  }
 else {
    curr=genConversionOps(dest,qb,curr);
    if (limit != null) {
      boolean extraMRStep=true;
      if (qb.getIsQuery() && qbp.getClusterByForClause(dest) == null && qbp.getSortByForClause(dest) == null) {
        extraMRStep=false;
      }
      curr=genLimitMapRedPlan(dest,qb,curr,limit.intValue(),extraMRStep);
      qb.getParseInfo().setOuterQueryLimit(limit.intValue());
    }
    curr=genFileSinkPlan(dest,qb,curr);
  }
  if (qb.getParseInfo().getAlias() != null) {
    RowResolver rr=opParseCtx.get(curr).getRowResolver();
    RowResolver newRR=new RowResolver();
    String alias=qb.getParseInfo().getAlias();
    for (    ColumnInfo colInfo : rr.getColumnInfos()) {
      String name=colInfo.getInternalName();
      String[] tmp=rr.reverseLookup(name);
      newRR.put(alias,tmp[1],colInfo);
    }
    opParseCtx.get(curr).setRowResolver(newRR);
  }
  return curr;
}
