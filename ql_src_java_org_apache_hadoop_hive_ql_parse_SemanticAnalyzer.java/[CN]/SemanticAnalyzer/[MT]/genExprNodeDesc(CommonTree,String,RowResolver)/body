{
  exprNodeDesc desc=null;
  ColumnInfo colInfo=input.get("",expr.toStringTree());
  if (colInfo != null) {
    desc=new exprNodeColumnDesc(colInfo.getType(),colInfo.getInternalName());
    return desc;
  }
  desc=genSimpleExprNodeDesc(expr);
  if (desc != null) {
    return desc;
  }
  int tokType=expr.getType();
switch (tokType) {
case HiveParser.TOK_COLREF:
{
      assert(expr.getChildCount() == 2);
      String tabAlias=SemanticAnalyzer.getTableName(expr);
      String colName=SemanticAnalyzer.getSerDeFieldExpression(expr);
      if (tabAlias == null || colName == null) {
        throw new SemanticException(ErrorMsg.INVALID_XPATH.getMsg(expr));
      }
      colInfo=input.get(tabAlias,colName);
      if (colInfo == null) {
        LOG.info("input: " + input.toString() + " expr: "+ expr.toStringTree()+ " e: "+ input.getIsExprResolver());
      }
      if (colInfo == null && input.getIsExprResolver()) {
        throw new SemanticException(ErrorMsg.NON_KEY_EXPR_IN_GROUPBY.getMsg(expr));
      }
 else       if (!input.hasTableAlias(expr.getChild(0).getText())) {
        throw new SemanticException(ErrorMsg.INVALID_TABLE_ALIAS.getMsg((CommonTree)expr.getChild(0)));
      }
 else       if (colInfo == null) {
        throw new SemanticException(ErrorMsg.INVALID_COLUMN.getMsg((CommonTree)expr.getChild(1)));
      }
      desc=new exprNodeColumnDesc(colInfo.getType(),colInfo.getInternalName());
      break;
    }
default :
{
    boolean isFunction=(expr.getType() == HiveParser.TOK_FUNCTION);
    int childrenBegin=(isFunction ? 1 : 0);
    ArrayList<exprNodeDesc> children=new ArrayList<exprNodeDesc>(expr.getChildCount() - childrenBegin);
    for (int ci=childrenBegin; ci < expr.getChildCount(); ci++) {
      children.add(genExprNodeDesc((CommonTree)expr.getChild(ci),alias,input));
    }
    desc=getXpathOrFuncExprNodeDesc(expr,isFunction,children);
    break;
  }
}
assert(desc != null);
return desc;
}
