{
  RowResolver reduceSinkInputRowResolver2=opParseCtx.get(groupByOperatorInfo).getRR();
  RowResolver reduceSinkOutputRowResolver2=new RowResolver();
  reduceSinkOutputRowResolver2.setIsExprResolver(true);
  Map<String,exprNodeDesc> colExprMap=new HashMap<String,exprNodeDesc>();
  ArrayList<exprNodeDesc> reduceKeys=new ArrayList<exprNodeDesc>();
  List<ASTNode> grpByExprs=getGroupByForClause(parseInfo,dest);
  for (int i=0; i < grpByExprs.size(); ++i) {
    ASTNode grpbyExpr=grpByExprs.get(i);
    String field=(Integer.valueOf(i)).toString();
    TypeInfo typeInfo=reduceSinkInputRowResolver2.get("",grpbyExpr.toStringTree()).getType();
    exprNodeColumnDesc inputExpr=new exprNodeColumnDesc(typeInfo,field);
    reduceKeys.add(inputExpr);
    ColumnInfo colInfo=new ColumnInfo(Utilities.ReduceField.KEY.toString() + "." + field,typeInfo);
    reduceSinkOutputRowResolver2.put("",grpbyExpr.toStringTree(),colInfo);
    colExprMap.put(colInfo.getInternalName(),inputExpr);
  }
  ArrayList<exprNodeDesc> reduceValues=new ArrayList<exprNodeDesc>();
  int inputField=reduceKeys.size();
  HashMap<String,ASTNode> aggregationTrees=parseInfo.getAggregationExprsForClause(dest);
  for (  Map.Entry<String,ASTNode> entry : aggregationTrees.entrySet()) {
    String field=(Integer.valueOf(inputField)).toString();
    ASTNode t=entry.getValue();
    TypeInfo typeInfo=reduceSinkInputRowResolver2.get("",t.toStringTree()).getType();
    reduceValues.add(new exprNodeColumnDesc(typeInfo,field));
    inputField++;
    reduceSinkOutputRowResolver2.put("",t.toStringTree(),new ColumnInfo(Utilities.ReduceField.VALUE.toString() + "." + (Integer.valueOf(reduceValues.size() - 1)).toString(),typeInfo));
  }
  ReduceSinkOperator rsOp=(ReduceSinkOperator)putOpInsertMap(OperatorFactory.getAndMakeChild(PlanUtils.getReduceSinkDesc(reduceKeys,reduceValues,-1,numPartitionFields,numReducers),new RowSchema(reduceSinkOutputRowResolver2.getColumnInfos()),groupByOperatorInfo),reduceSinkOutputRowResolver2);
  rsOp.setColumnExprMap(colExprMap);
  return rsOp;
}
