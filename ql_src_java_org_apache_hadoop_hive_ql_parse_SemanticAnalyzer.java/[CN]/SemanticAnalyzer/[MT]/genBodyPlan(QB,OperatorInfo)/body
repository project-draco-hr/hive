{
  QBParseInfo qbp=qb.getParseInfo();
  TreeSet<String> ks=new TreeSet<String>();
  ks.addAll(qbp.getClauseNames());
  String distinctText=null;
  CommonTree distn=null;
  OperatorInfo op=null;
  boolean grpBy=false;
  int numGrpBy=0;
  for (  String dest : ks) {
    if ((qbp.getAggregationExprsForClause(dest).size() != 0) || (getGroupByForClause(qbp,dest).size() > 0)) {
      grpBy=true;
      numGrpBy++;
      if (qbp.getDistinctFuncExprForClause(dest) != null) {
        CommonTree value=qbp.getDistinctFuncExprForClause(dest);
        if (value.getChildCount() != 2)         throw new SemanticException(ErrorMsg.UNSUPPORTED_MULTIPLE_DISTINCTS.getMsg(value));
        distn=(CommonTree)value.getChild(1);
        String dist=distn.toStringTree();
        ;
        if (distinctText == null)         distinctText=dist;
        if (!distinctText.equals(dist))         throw new SemanticException(ErrorMsg.UNSUPPORTED_MULTIPLE_DISTINCTS.getMsg(value));
      }
    }
  }
  if (grpBy && (numGrpBy > 1)) {
    OperatorInfo reduceSinkOperatorInfo=genGroupByPlanReduceSinkOperator(qbp,input,distn,ks);
    OperatorInfo forwardOperatorInfo=genGroupByPlanForwardOperator(qbp,reduceSinkOperatorInfo);
    op=forwardOperatorInfo;
  }
  OperatorInfo curr=null;
  for (  String dest : ks) {
    boolean groupByExpr=false;
    if (qbp.getAggregationExprsForClause(dest).size() != 0 || getGroupByForClause(qbp,dest).size() > 0)     groupByExpr=true;
    curr=input;
    if (groupByExpr && (numGrpBy > 1))     curr=op;
    if (qbp.getWhrForClause(dest) != null) {
      curr=genFilterPlan(dest,qb,curr);
    }
    if (qbp.getAggregationExprsForClause(dest).size() != 0 || getGroupByForClause(qbp,dest).size() > 0) {
      if (numGrpBy > 1)       curr=genGroupByPlan3MR(dest,qb,curr);
 else       curr=genGroupByPlan2MR(dest,qb,curr);
    }
    curr=genSelectPlan(dest,qb,curr);
    Integer limit=qbp.getDestLimit(dest);
    if (qbp.getIsSubQ()) {
      if (qbp.getClusterByForClause(dest) != null)       curr=genReduceSinkPlan(dest,qb,curr,-1);
      if (limit != null)       curr=genLimitMapRedPlan(dest,qb,curr,limit.intValue(),false);
    }
 else {
      curr=genConversionOps(dest,qb,curr);
      if (limit != null) {
        curr=genLimitMapRedPlan(dest,qb,curr,limit.intValue(),true);
        qb.getParseInfo().setOuterQueryLimit(limit.intValue());
      }
      curr=genFileSinkPlan(dest,qb,curr);
    }
  }
  LOG.debug("Created Body Plan for Query Block " + qb.getId());
  return curr;
}
