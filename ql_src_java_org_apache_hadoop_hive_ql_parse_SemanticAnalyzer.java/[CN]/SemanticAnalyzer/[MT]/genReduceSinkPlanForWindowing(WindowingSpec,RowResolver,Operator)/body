{
  ArrayList<ExprNodeDesc> partCols=new ArrayList<ExprNodeDesc>();
  ArrayList<ExprNodeDesc> valueCols=new ArrayList<ExprNodeDesc>();
  ArrayList<ExprNodeDesc> orderCols=new ArrayList<ExprNodeDesc>();
  Map<String,ExprNodeDesc> colExprMap=new HashMap<String,ExprNodeDesc>();
  List<String> outputColumnNames=new ArrayList<String>();
  StringBuilder orderString=new StringBuilder();
  ArrayList<PartitionExpression> partColList=spec.getQueryPartitionSpec().getExpressions();
  for (  PartitionExpression partCol : partColList) {
    ExprNodeDesc partExpr=genExprNodeDesc(partCol.getExpression(),inputRR);
    partCols.add(partExpr);
    orderCols.add(partExpr);
    orderString.append('+');
  }
  ArrayList<OrderExpression> orderColList=spec.getQueryOrderSpec() == null ? new ArrayList<PTFInvocationSpec.OrderExpression>() : spec.getQueryOrderSpec().getExpressions();
  for (int i=0; i < orderColList.size(); i++) {
    OrderExpression orderCol=orderColList.get(i);
    org.apache.hadoop.hive.ql.parse.PTFInvocationSpec.Order order=orderCol.getOrder();
    if (order.name().equals("ASC")) {
      orderString.append('+');
    }
 else {
      orderString.append('-');
    }
    ExprNodeDesc orderExpr=genExprNodeDesc(orderCol.getExpression(),inputRR);
    orderCols.add(orderExpr);
  }
  ArrayList<ColumnInfo> colInfoList=inputRR.getColumnInfos();
  RowResolver rsNewRR=new RowResolver();
  int pos=0;
  for (  ColumnInfo colInfo : colInfoList) {
    ExprNodeDesc valueColExpr=new ExprNodeColumnDesc(colInfo.getType(),colInfo.getInternalName(),colInfo.getTabAlias(),colInfo.getIsVirtualCol());
    valueCols.add(valueColExpr);
    String internalName=SemanticAnalyzer.getColumnInternalName(pos++);
    outputColumnNames.add(internalName);
    colExprMap.put(internalName,valueColExpr);
    String[] alias=inputRR.reverseLookup(colInfo.getInternalName());
    ColumnInfo newColInfo=new ColumnInfo(internalName,colInfo.getType(),alias[0],colInfo.getIsVirtualCol(),colInfo.isHiddenVirtualCol());
    rsNewRR.put(alias[0],alias[1],newColInfo);
    String[] altMapping=inputRR.getAlternateMappings(colInfo.getInternalName());
    if (altMapping != null) {
      rsNewRR.put(altMapping[0],altMapping[1],newColInfo);
    }
  }
  input=putOpInsertMap(OperatorFactory.getAndMakeChild(PlanUtils.getReduceSinkDesc(orderCols,valueCols,outputColumnNames,false,-1,partCols,orderString.toString(),-1,AcidUtils.Operation.NOT_ACID),new RowSchema(rsNewRR.getColumnInfos()),input),rsNewRR);
  input.setColumnExprMap(colExprMap);
  RowResolver extractRR=new RowResolver();
  LinkedHashMap<String[],ColumnInfo> colsAddedByHaving=new LinkedHashMap<String[],ColumnInfo>();
  pos=0;
  for (  ColumnInfo colInfo : colInfoList) {
    String[] alias=inputRR.reverseLookup(colInfo.getInternalName());
    if (colsAddedByHaving.containsKey(alias)) {
      continue;
    }
    ASTNode astNode=PTFTranslator.getASTNode(colInfo,inputRR);
    ColumnInfo eColInfo=new ColumnInfo(SemanticAnalyzer.getColumnInternalName(pos++),colInfo.getType(),alias[0],colInfo.getIsVirtualCol(),colInfo.isHiddenVirtualCol());
    if (astNode == null) {
      extractRR.put(alias[0],alias[1],eColInfo);
    }
 else {
      extractRR.putExpression(astNode,eColInfo);
      if (!astNode.toStringTree().toLowerCase().equals(alias[1])) {
        colsAddedByHaving.put(alias,eColInfo);
      }
    }
    String[] altMapping=inputRR.getAlternateMappings(colInfo.getInternalName());
    if (altMapping != null) {
      extractRR.put(altMapping[0],altMapping[1],eColInfo);
    }
  }
  for (  Map.Entry<String[],ColumnInfo> columnAddedByHaving : colsAddedByHaving.entrySet()) {
    String[] alias=columnAddedByHaving.getKey();
    ColumnInfo eColInfo=columnAddedByHaving.getValue();
    extractRR.put(alias[0],alias[1],eColInfo);
  }
  input=putOpInsertMap(OperatorFactory.getAndMakeChild(new ExtractDesc(new ExprNodeColumnDesc(TypeInfoFactory.stringTypeInfo,Utilities.ReduceField.VALUE.toString(),"",false)),new RowSchema(inputRR.getColumnInfos()),input),extractRR);
  return input;
}
