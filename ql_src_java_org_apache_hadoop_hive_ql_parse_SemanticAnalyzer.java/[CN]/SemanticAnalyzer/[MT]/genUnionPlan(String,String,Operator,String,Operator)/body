{
  RowResolver leftRR=opParseCtx.get(leftOp).getRowResolver();
  RowResolver rightRR=opParseCtx.get(rightOp).getRowResolver();
  HashMap<String,ColumnInfo> leftmap=leftRR.getFieldMap(leftalias);
  HashMap<String,ColumnInfo> rightmap=rightRR.getFieldMap(rightalias);
  ASTNode tabref=qb.getAliases().isEmpty() ? null : qb.getParseInfo().getSrcForAlias(qb.getAliases().get(0));
  if (leftmap.size() != rightmap.size()) {
    throw new SemanticException("Schema of both sides of union should match.");
  }
  for (  Map.Entry<String,ColumnInfo> lEntry : leftmap.entrySet()) {
    String field=lEntry.getKey();
    ColumnInfo lInfo=lEntry.getValue();
    ColumnInfo rInfo=rightmap.get(field);
    if (rInfo == null) {
      throw new SemanticException(generateErrorMessage(tabref,"Schema of both sides of union should match. " + rightalias + " does not have the field "+ field));
    }
    if (lInfo == null) {
      throw new SemanticException(generateErrorMessage(tabref,"Schema of both sides of union should match. " + leftalias + " does not have the field "+ field));
    }
    if (!lInfo.getInternalName().equals(rInfo.getInternalName())) {
      throw new SemanticException(generateErrorMessage(tabref,"Schema of both sides of union should match: field " + field + ":"+ " appears on the left side of the UNION at column position: "+ getPositionFromInternalName(lInfo.getInternalName())+ ", and on the right side of the UNION at column position: "+ getPositionFromInternalName(rInfo.getInternalName())+ ". Column positions should match for a UNION"));
    }
    TypeInfo commonTypeInfo=FunctionRegistry.getCommonClassForUnionAll(lInfo.getType(),rInfo.getType());
    if (commonTypeInfo == null) {
      throw new SemanticException(generateErrorMessage(tabref,"Schema of both sides of union should match: Column " + field + " is of type "+ lInfo.getType().getTypeName()+ " on first table and type "+ rInfo.getType().getTypeName()+ " on second table"));
    }
  }
  RowResolver unionoutRR=new RowResolver();
  for (  Map.Entry<String,ColumnInfo> lEntry : leftmap.entrySet()) {
    String field=lEntry.getKey();
    ColumnInfo lInfo=lEntry.getValue();
    ColumnInfo rInfo=rightmap.get(field);
    ColumnInfo unionColInfo=new ColumnInfo(lInfo);
    unionColInfo.setType(FunctionRegistry.getCommonClassForUnionAll(lInfo.getType(),rInfo.getType()));
    unionoutRR.put(unionalias,field,unionColInfo);
  }
  boolean isSpark=HiveConf.getVar(conf,HiveConf.ConfVars.HIVE_EXECUTION_ENGINE).equals("spark");
  if (isSpark || !(leftOp instanceof UnionOperator)) {
    leftOp=genInputSelectForUnion(leftOp,leftmap,leftalias,unionoutRR,unionalias);
  }
  if (isSpark || !(rightOp instanceof UnionOperator)) {
    rightOp=genInputSelectForUnion(rightOp,rightmap,rightalias,unionoutRR,unionalias);
  }
  if (leftOp instanceof UnionOperator || (leftOp instanceof SelectOperator && leftOp.getParentOperators() != null && !leftOp.getParentOperators().isEmpty() && leftOp.getParentOperators().get(0) instanceof UnionOperator && ((SelectOperator)leftOp).isIdentitySelect())) {
    if (!(leftOp instanceof UnionOperator)) {
      Operator oldChild=leftOp;
      leftOp=(Operator)leftOp.getParentOperators().get(0);
      leftOp.removeChildAndAdoptItsChildren(oldChild);
    }
    List<Operator<? extends OperatorDesc>> child=new ArrayList<Operator<? extends OperatorDesc>>();
    child.add(leftOp);
    rightOp.setChildOperators(child);
    List<Operator<? extends OperatorDesc>> parent=leftOp.getParentOperators();
    parent.add(rightOp);
    UnionDesc uDesc=((UnionOperator)leftOp).getConf();
    uDesc.setNumInputs(uDesc.getNumInputs() + 1);
    return putOpInsertMap(leftOp,unionoutRR);
  }
  if (rightOp instanceof UnionOperator || (rightOp instanceof SelectOperator && rightOp.getParentOperators() != null && !rightOp.getParentOperators().isEmpty() && rightOp.getParentOperators().get(0) instanceof UnionOperator && ((SelectOperator)rightOp).isIdentitySelect())) {
    if (!(rightOp instanceof UnionOperator)) {
      Operator oldChild=rightOp;
      rightOp=(Operator)rightOp.getParentOperators().get(0);
      rightOp.removeChildAndAdoptItsChildren(oldChild);
    }
    List<Operator<? extends OperatorDesc>> child=new ArrayList<Operator<? extends OperatorDesc>>();
    child.add(rightOp);
    leftOp.setChildOperators(child);
    List<Operator<? extends OperatorDesc>> parent=rightOp.getParentOperators();
    parent.add(leftOp);
    UnionDesc uDesc=((UnionOperator)rightOp).getConf();
    uDesc.setNumInputs(uDesc.getNumInputs() + 1);
    return putOpInsertMap(rightOp,unionoutRR);
  }
  Operator<? extends OperatorDesc> unionforward=OperatorFactory.getAndMakeChild(new UnionDesc(),new RowSchema(unionoutRR.getColumnInfos()));
  List<Operator<? extends OperatorDesc>> child=new ArrayList<Operator<? extends OperatorDesc>>();
  child.add(unionforward);
  rightOp.setChildOperators(child);
  child=new ArrayList<Operator<? extends OperatorDesc>>();
  child.add(unionforward);
  leftOp.setChildOperators(child);
  List<Operator<? extends OperatorDesc>> parent=new ArrayList<Operator<? extends OperatorDesc>>();
  parent.add(leftOp);
  parent.add(rightOp);
  unionforward.setParentOperators(parent);
  return putOpInsertMap(unionforward,unionoutRR);
}
