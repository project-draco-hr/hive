{
  RowResolver leftRR=opParseCtx.get(leftOp).getRowResolver();
  RowResolver rightRR=opParseCtx.get(rightOp).getRowResolver();
  HashMap<String,ColumnInfo> leftmap=leftRR.getFieldMap(leftalias);
  HashMap<String,ColumnInfo> rightmap=rightRR.getFieldMap(rightalias);
  ASTNode tabref=qb.getAliases().isEmpty() ? null : qb.getParseInfo().getSrcForAlias(qb.getAliases().get(0));
  if (leftmap.size() != rightmap.size()) {
    throw new SemanticException("Schema of both sides of union should match.");
  }
  for (  Map.Entry<String,ColumnInfo> lEntry : leftmap.entrySet()) {
    String field=lEntry.getKey();
    ColumnInfo lInfo=lEntry.getValue();
    ColumnInfo rInfo=rightmap.get(field);
    if (rInfo == null) {
      throw new SemanticException(generateErrorMessage(tabref,"Schema of both sides of union should match. " + rightalias + " does not have the field "+ field));
    }
    if (lInfo == null) {
      throw new SemanticException(generateErrorMessage(tabref,"Schema of both sides of union should match. " + leftalias + " does not have the field "+ field));
    }
    if (!lInfo.getInternalName().equals(rInfo.getInternalName())) {
      throw new SemanticException(generateErrorMessage(tabref,"Schema of both sides of union should match: field " + field + ":"+ " appears on the left side of the UNION at column position: "+ getPositionFromInternalName(lInfo.getInternalName())+ ", and on the right side of the UNION at column position: "+ getPositionFromInternalName(rInfo.getInternalName())+ ". Column positions should match for a UNION"));
    }
    TypeInfo commonTypeInfo=FunctionRegistry.getCommonClassForUnionAll(lInfo.getType(),rInfo.getType());
    if (commonTypeInfo == null) {
      throw new SemanticException(generateErrorMessage(tabref,"Schema of both sides of union should match: Column " + field + " is of type "+ lInfo.getType().getTypeName()+ " on first table and type "+ rInfo.getType().getTypeName()+ " on second table"));
    }
  }
  RowResolver unionoutRR=new RowResolver();
  for (  Map.Entry<String,ColumnInfo> lEntry : leftmap.entrySet()) {
    String field=lEntry.getKey();
    ColumnInfo lInfo=lEntry.getValue();
    ColumnInfo rInfo=rightmap.get(field);
    lInfo.setType(FunctionRegistry.getCommonClassForUnionAll(lInfo.getType(),rInfo.getType()));
    unionoutRR.put(unionalias,field,lInfo);
  }
  if ((leftOp instanceof UnionOperator) || (rightOp instanceof UnionOperator)) {
    if (leftOp instanceof UnionOperator) {
      List<Operator<? extends OperatorDesc>> child=new ArrayList<Operator<? extends OperatorDesc>>();
      child.add(leftOp);
      rightOp.setChildOperators(child);
      List<Operator<? extends OperatorDesc>> parent=leftOp.getParentOperators();
      parent.add(rightOp);
      UnionDesc uDesc=((UnionOperator)leftOp).getConf();
      uDesc.setNumInputs(uDesc.getNumInputs() + 1);
      return putOpInsertMap(leftOp,unionoutRR);
    }
 else {
      List<Operator<? extends OperatorDesc>> child=new ArrayList<Operator<? extends OperatorDesc>>();
      child.add(rightOp);
      leftOp.setChildOperators(child);
      List<Operator<? extends OperatorDesc>> parent=rightOp.getParentOperators();
      parent.add(leftOp);
      UnionDesc uDesc=((UnionOperator)rightOp).getConf();
      uDesc.setNumInputs(uDesc.getNumInputs() + 1);
      return putOpInsertMap(rightOp,unionoutRR);
    }
  }
  Operator<? extends OperatorDesc> unionforward=OperatorFactory.getAndMakeChild(new UnionDesc(),new RowSchema(unionoutRR.getColumnInfos()));
  List<Operator<? extends OperatorDesc>> child=new ArrayList<Operator<? extends OperatorDesc>>();
  child.add(unionforward);
  rightOp.setChildOperators(child);
  child=new ArrayList<Operator<? extends OperatorDesc>>();
  child.add(unionforward);
  leftOp.setChildOperators(child);
  List<Operator<? extends OperatorDesc>> parent=new ArrayList<Operator<? extends OperatorDesc>>();
  parent.add(leftOp);
  parent.add(rightOp);
  unionforward.setParentOperators(parent);
  return putOpInsertMap(unionforward,unionoutRR);
}
