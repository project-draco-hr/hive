{
  ASTNode selExprList=qb.getParseInfo().getSelForClause(dest);
  ArrayList<exprNodeDesc> col_list=new ArrayList<exprNodeDesc>();
  RowResolver out_rwsch=new RowResolver();
  ASTNode trfm=null;
  String alias=qb.getParseInfo().getAlias();
  Integer pos=Integer.valueOf(0);
  RowResolver inputRR=opParseCtx.get(input).getRR();
  boolean selectStar=false;
  int posn=0;
  boolean hintPresent=(selExprList.getChild(0).getType() == HiveParser.TOK_HINTLIST);
  if (hintPresent) {
    posn++;
  }
  boolean isInTransform=(selExprList.getChild(posn).getChild(0).getType() == HiveParser.TOK_TRANSFORM);
  if (isInTransform) {
    trfm=(ASTNode)selExprList.getChild(posn).getChild(0);
  }
  ASTNode exprList=(isInTransform ? (ASTNode)trfm.getChild(0) : selExprList);
  LOG.debug("genSelectPlan: input = " + inputRR.toString());
  for (int i=posn; i < exprList.getChildCount(); ++i) {
    ASTNode child=(ASTNode)exprList.getChild(i);
    boolean hasAsClause=(!isInTransform) && (child.getChildCount() == 2);
    ASTNode expr;
    String tabAlias;
    String colAlias;
    if (isInTransform) {
      tabAlias=null;
      colAlias="_C" + i;
      expr=child;
    }
 else {
      String[] colRef=getColAlias(child,"_C" + i,inputRR);
      tabAlias=colRef[0];
      colAlias=colRef[1];
      expr=(ASTNode)child.getChild(0);
    }
    if (expr.getType() == HiveParser.TOK_ALLCOLREF) {
      pos=genColListRegex(".*",expr.getChildCount() == 0 ? null : unescapeIdentifier(expr.getChild(0).getText().toLowerCase()),alias,expr,col_list,inputRR,pos,out_rwsch);
      selectStar=true;
    }
 else     if (expr.getType() == HiveParser.TOK_TABLE_OR_COL && !hasAsClause && !inputRR.getIsExprResolver() && isRegex(unescapeIdentifier(expr.getChild(0).getText()))) {
      pos=genColListRegex(unescapeIdentifier(expr.getChild(0).getText()),null,alias,expr,col_list,inputRR,pos,out_rwsch);
    }
 else     if (expr.getType() == HiveParser.DOT && expr.getChild(0).getType() == HiveParser.TOK_TABLE_OR_COL && inputRR.hasTableAlias(unescapeIdentifier(expr.getChild(0).getChild(0).getText().toLowerCase())) && !hasAsClause && !inputRR.getIsExprResolver() && isRegex(unescapeIdentifier(expr.getChild(1).getText()))) {
      pos=genColListRegex(unescapeIdentifier(expr.getChild(1).getText()),unescapeIdentifier(expr.getChild(0).getChild(0).getText().toLowerCase()),alias,expr,col_list,inputRR,pos,out_rwsch);
    }
 else {
      exprNodeDesc exp=genExprNodeDesc(expr,inputRR);
      col_list.add(exp);
      if (!StringUtils.isEmpty(alias) && (out_rwsch.get(null,colAlias) != null)) {
        throw new SemanticException(ErrorMsg.AMBIGUOUS_COLUMN.getMsg(expr.getChild(1)));
      }
      out_rwsch.put(tabAlias,colAlias,new ColumnInfo((Integer.valueOf(pos)).toString(),exp.getTypeInfo()));
      pos=Integer.valueOf(pos.intValue() + 1);
    }
  }
  selectStar=selectStar && exprList.getChildCount() == posn + 1;
  Map<String,exprNodeDesc> colExprMap=new HashMap<String,exprNodeDesc>();
  for (int i=0; i < col_list.size(); i++) {
    if (col_list.get(i) instanceof exprNodeNullDesc) {
      col_list.set(i,new exprNodeConstantDesc(TypeInfoFactory.stringTypeInfo,null));
    }
    colExprMap.put(Integer.toString(i),col_list.get(i));
  }
  Operator output=putOpInsertMap(OperatorFactory.getAndMakeChild(new selectDesc(col_list,selectStar),new RowSchema(out_rwsch.getColumnInfos()),input),out_rwsch);
  output.setColumnExprMap(colExprMap);
  if (isInTransform) {
    output=genScriptPlan(trfm,qb,output);
  }
  LOG.debug("Created Select Plan for clause: " + dest + " row schema: "+ out_rwsch.toString());
  return output;
}
