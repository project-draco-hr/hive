{
  ArrayList<PTFExpressionDef> partColList=tabDef.getPartition().getExpressions();
  for (  PTFExpressionDef colDef : partColList) {
    partCols.add(colDef.getExprNode());
    orderCols.add(colDef.getExprNode());
    orderString.append('+');
  }
  ArrayList<OrderExpressionDef> orderColList=tabDef.getOrder().getExpressions();
  for (int i=0; i < orderColList.size(); i++) {
    OrderExpressionDef colDef=orderColList.get(i);
    org.apache.hadoop.hive.ql.parse.PTFInvocationSpec.Order order=colDef.getOrder();
    if (order.name().equals("ASC")) {
      orderString.append('+');
    }
 else {
      orderString.append('-');
    }
    orderCols.add(colDef.getExprNode());
  }
  ArrayList<ColumnInfo> colInfoList=inputRR.getColumnInfos();
  int pos=0;
  for (  ColumnInfo colInfo : colInfoList) {
    ExprNodeDesc valueColExpr=new ExprNodeColumnDesc(colInfo.getType(),colInfo.getInternalName(),colInfo.getTabAlias(),colInfo.getIsVirtualCol());
    valueCols.add(valueColExpr);
    colExprMap.put(colInfo.getInternalName(),valueColExpr);
    String outColName=SemanticAnalyzer.getColumnInternalName(pos++);
    outputColumnNames.add(outColName);
    String[] alias=inputRR.reverseLookup(colInfo.getInternalName());
    ColumnInfo newColInfo=new ColumnInfo(outColName,colInfo.getType(),alias[0],colInfo.getIsVirtualCol(),colInfo.isHiddenVirtualCol());
    rsOpRR.put(alias[0],alias[1],newColInfo);
  }
  LinkedHashMap<String[],ColumnInfo> colsAddedByHaving=new LinkedHashMap<String[],ColumnInfo>();
  pos=0;
  for (  ColumnInfo colInfo : colInfoList) {
    if (!colInfo.isHiddenVirtualCol()) {
      String[] alias=inputRR.reverseLookup(colInfo.getInternalName());
      if (colsAddedByHaving.containsKey(alias)) {
        continue;
      }
      ASTNode astNode=PTFTranslator.getASTNode(colInfo,inputRR);
      ColumnInfo eColInfo=new ColumnInfo(SemanticAnalyzer.getColumnInternalName(pos++),colInfo.getType(),alias[0],colInfo.getIsVirtualCol(),colInfo.isHiddenVirtualCol());
      if (astNode == null) {
        extractRR.put(alias[0],alias[1],eColInfo);
      }
 else {
        extractRR.putExpression(astNode,eColInfo);
        if (!astNode.toStringTree().toLowerCase().equals(alias[1])) {
          colsAddedByHaving.put(alias,eColInfo);
        }
      }
    }
  }
  for (  Map.Entry<String[],ColumnInfo> columnAddedByHaving : colsAddedByHaving.entrySet()) {
    String[] alias=columnAddedByHaving.getKey();
    ColumnInfo eColInfo=columnAddedByHaving.getValue();
    extractRR.put(alias[0],alias[1],eColInfo);
  }
}
