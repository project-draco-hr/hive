{
  RowResolver reduceSinkInputRowResolver=opParseCtx.get(inputOperatorInfo).getRR();
  QBParseInfo parseInfo=qb.getParseInfo();
  RowResolver reduceSinkOutputRowResolver=new RowResolver();
  Map<String,exprNodeDesc> colExprMap=new HashMap<String,exprNodeDesc>();
  ArrayList<exprNodeDesc> reduceKeys=new ArrayList<exprNodeDesc>();
  List<String> outputColumnNames=new ArrayList<String>();
  reduceSinkOutputRowResolver.setIsExprResolver(true);
  for (int i=0; i < fields.size(); ++i) {
    ASTNode colName=fields.get(i);
    exprNodeDesc inputExpr=genExprNodeDesc(colName,reduceSinkInputRowResolver);
    reduceKeys.add(inputExpr);
    if (reduceSinkOutputRowResolver.get("",colName.toStringTree()) == null) {
      outputColumnNames.add(getColumnInternalName(reduceKeys.size() - 1));
      String field=Utilities.ReduceField.KEY.toString() + "." + getColumnInternalName(reduceKeys.size() - 1);
      ColumnInfo colInfo1=new ColumnInfo(field,reduceKeys.get(reduceKeys.size() - 1).getTypeInfo(),null,false);
      reduceSinkOutputRowResolver.put("",colName.toStringTree(),colInfo1);
      colExprMap.put(colInfo1.getInternalName(),inputExpr);
    }
 else {
      throw new SemanticException(ErrorMsg.DUPLICATE_GROUPBY_KEY.getMsg());
    }
  }
  ArrayList<exprNodeDesc> reduceValues=new ArrayList<exprNodeDesc>();
  int numPartitionFields=fields.size();
  ReduceSinkOperator rsOp=(ReduceSinkOperator)putOpInsertMap(OperatorFactory.getAndMakeChild(PlanUtils.getReduceSinkDesc(reduceKeys,reduceValues,outputColumnNames,true,-1,numPartitionFields,-1),new RowSchema(reduceSinkOutputRowResolver.getColumnInfos()),inputOperatorInfo),reduceSinkOutputRowResolver);
  rsOp.setColumnExprMap(colExprMap);
  return rsOp;
}
