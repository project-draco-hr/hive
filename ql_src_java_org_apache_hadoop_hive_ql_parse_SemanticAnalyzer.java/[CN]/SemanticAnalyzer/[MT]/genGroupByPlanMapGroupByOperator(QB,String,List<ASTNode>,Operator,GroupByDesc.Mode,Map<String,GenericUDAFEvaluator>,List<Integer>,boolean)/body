{
  RowResolver groupByInputRowResolver=opParseCtx.get(inputOperatorInfo).getRowResolver();
  QBParseInfo parseInfo=qb.getParseInfo();
  RowResolver groupByOutputRowResolver=new RowResolver();
  groupByOutputRowResolver.setIsExprResolver(true);
  ArrayList<ExprNodeDesc> groupByKeys=new ArrayList<ExprNodeDesc>();
  ArrayList<String> outputColumnNames=new ArrayList<String>();
  ArrayList<AggregationDesc> aggregations=new ArrayList<AggregationDesc>();
  Map<String,ExprNodeDesc> colExprMap=new HashMap<String,ExprNodeDesc>();
  for (int i=0; i < grpByExprs.size(); ++i) {
    ASTNode grpbyExpr=grpByExprs.get(i);
    ExprNodeDesc grpByExprNode=genExprNodeDesc(grpbyExpr,groupByInputRowResolver);
    groupByKeys.add(grpByExprNode);
    String field=getColumnInternalName(i);
    outputColumnNames.add(field);
    groupByOutputRowResolver.putExpression(grpbyExpr,new ColumnInfo(field,grpByExprNode.getTypeInfo(),"",false));
    colExprMap.put(field,groupByKeys.get(groupByKeys.size() - 1));
  }
  int groupingSetsPosition=-1;
  if (groupingSetsPresent) {
    groupingSetsPosition=groupByKeys.size();
    createNewGroupingKey(groupByKeys,outputColumnNames,groupByOutputRowResolver,colExprMap);
  }
  if (!parseInfo.getDistinctFuncExprsForClause(dest).isEmpty()) {
    List<ASTNode> list=parseInfo.getDistinctFuncExprsForClause(dest);
    for (    ASTNode value : list) {
      for (int i=1; i < value.getChildCount(); i++) {
        ASTNode parameter=(ASTNode)value.getChild(i);
        if (groupByOutputRowResolver.getExpression(parameter) == null) {
          ExprNodeDesc distExprNode=genExprNodeDesc(parameter,groupByInputRowResolver);
          groupByKeys.add(distExprNode);
          String field=getColumnInternalName(groupByKeys.size() - 1);
          outputColumnNames.add(field);
          groupByOutputRowResolver.putExpression(parameter,new ColumnInfo(field,distExprNode.getTypeInfo(),"",false));
          colExprMap.put(field,groupByKeys.get(groupByKeys.size() - 1));
        }
      }
    }
  }
  HashMap<String,ASTNode> aggregationTrees=parseInfo.getAggregationExprsForClause(dest);
  assert(aggregationTrees != null);
  boolean containsDistinctAggr=false;
  for (  Map.Entry<String,ASTNode> entry : aggregationTrees.entrySet()) {
    ASTNode value=entry.getValue();
    String aggName=unescapeIdentifier(value.getChild(0).getText());
    ArrayList<ExprNodeDesc> aggParameters=new ArrayList<ExprNodeDesc>();
    for (int i=1; i < value.getChildCount(); i++) {
      ASTNode paraExpr=(ASTNode)value.getChild(i);
      ExprNodeDesc paraExprNode=genExprNodeDesc(paraExpr,groupByInputRowResolver);
      aggParameters.add(paraExprNode);
    }
    boolean isDistinct=value.getType() == HiveParser.TOK_FUNCTIONDI;
    containsDistinctAggr=containsDistinctAggr || isDistinct;
    boolean isAllColumns=value.getType() == HiveParser.TOK_FUNCTIONSTAR;
    Mode amode=groupByDescModeToUDAFMode(mode,isDistinct);
    GenericUDAFEvaluator genericUDAFEvaluator=getGenericUDAFEvaluator(aggName,aggParameters,value,isDistinct,isAllColumns);
    assert(genericUDAFEvaluator != null);
    GenericUDAFInfo udaf=getGenericUDAFInfo(genericUDAFEvaluator,amode,aggParameters);
    aggregations.add(new AggregationDesc(aggName.toLowerCase(),udaf.genericUDAFEvaluator,udaf.convertedParameters,isDistinct,amode));
    String field=getColumnInternalName(groupByKeys.size() + aggregations.size() - 1);
    outputColumnNames.add(field);
    if (groupByOutputRowResolver.getExpression(value) == null) {
      groupByOutputRowResolver.putExpression(value,new ColumnInfo(field,udaf.returnType,"",false));
    }
    if (genericUDAFEvaluators != null) {
      genericUDAFEvaluators.put(entry.getKey(),genericUDAFEvaluator);
    }
  }
  float groupByMemoryUsage=HiveConf.getFloatVar(conf,HiveConf.ConfVars.HIVEMAPAGGRHASHMEMORY);
  float memoryThreshold=HiveConf.getFloatVar(conf,HiveConf.ConfVars.HIVEMAPAGGRMEMORYTHRESHOLD);
  Operator op=putOpInsertMap(OperatorFactory.getAndMakeChild(new GroupByDesc(mode,outputColumnNames,groupByKeys,aggregations,false,groupByMemoryUsage,memoryThreshold,groupingSetKeys,groupingSetsPresent,groupingSetsPosition,containsDistinctAggr),new RowSchema(groupByOutputRowResolver.getColumnInfos()),inputOperatorInfo),groupByOutputRowResolver);
  op.setColumnExprMap(colExprMap);
  return op;
}
