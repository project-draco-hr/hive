{
  RowResolver inputRR=opParseCtx.get(input).getRR();
  QBParseInfo qbp=qb.getParseInfo();
  TreeSet<String> ks=new TreeSet<String>();
  ks.addAll(qbp.getClauseNames());
  if (ks.size() <= 1)   return null;
  List<exprNodeDesc> oldList=null;
  List<ASTNode> oldASTList=null;
  for (  String dest : ks) {
    Operator curr=input;
    if (qbp.getWhrForClause(dest) != null)     return null;
    if (qbp.getAggregationExprsForClause(dest).size() == 0 && getGroupByForClause(qbp,dest).size() == 0)     return null;
    ASTNode value=qbp.getDistinctFuncExprForClause(dest);
    if (value == null)     return null;
    List<exprNodeDesc> currDestList=new ArrayList<exprNodeDesc>();
    List<ASTNode> currASTList=new ArrayList<ASTNode>();
    try {
      for (int i=1; i < value.getChildCount(); i++) {
        ASTNode parameter=(ASTNode)value.getChild(i);
        currDestList.add(genExprNodeDesc(parameter,inputRR));
        currASTList.add(parameter);
      }
    }
 catch (    SemanticException e) {
      return null;
    }
    if (oldList == null) {
      oldList=currDestList;
      oldASTList=currASTList;
    }
 else {
      if (oldList.size() != currDestList.size())       return null;
      for (int pos=0; pos < oldList.size(); pos++) {
        if (!oldList.get(pos).isSame(currDestList.get(pos)))         return null;
      }
    }
  }
  return oldASTList;
}
