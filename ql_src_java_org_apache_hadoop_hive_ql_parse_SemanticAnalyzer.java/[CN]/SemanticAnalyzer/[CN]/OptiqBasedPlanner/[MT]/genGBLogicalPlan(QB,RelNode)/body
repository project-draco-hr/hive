{
  RelNode gbRel=null;
  QBParseInfo qbp=getQBParseInfo(qb);
  String detsClauseName=qbp.getClauseNames().iterator().next();
  List<ASTNode> grpByAstExprs=getGroupByForClause(qbp,detsClauseName);
  HashMap<String,ASTNode> aggregationTrees=qbp.getAggregationExprsForClause(detsClauseName);
  boolean hasGrpByAstExprs=(grpByAstExprs != null && !grpByAstExprs.isEmpty()) ? true : false;
  boolean hasAggregationTrees=(aggregationTrees != null && !aggregationTrees.isEmpty()) ? true : false;
  if (hasGrpByAstExprs || hasAggregationTrees) {
    ArrayList<ExprNodeDesc> gbExprNDescLst=new ArrayList<ExprNodeDesc>();
    ArrayList<String> outputColumnNames=new ArrayList<String>();
    int numDistinctUDFs=0;
    RowResolver groupByInputRowResolver=this.m_relToHiveRR.get(srcRel);
    RowResolver groupByOutputRowResolver=new RowResolver();
    groupByOutputRowResolver.setIsExprResolver(true);
    if (hasGrpByAstExprs) {
      for (int i=0; i < grpByAstExprs.size(); ++i) {
        ASTNode grpbyExpr=grpByAstExprs.get(i);
        Map<ASTNode,ExprNodeDesc> astToExprNDescMap=TypeCheckProcFactory.genExprNode(grpbyExpr,new TypeCheckCtx(groupByInputRowResolver));
        ExprNodeDesc grpbyExprNDesc=astToExprNDescMap.get(grpbyExpr);
        if (grpbyExprNDesc == null)         throw new RuntimeException("Invalid Column Reference: " + grpbyExpr.dump());
        addToGBExpr(groupByOutputRowResolver,groupByInputRowResolver,grpbyExpr,grpbyExprNDesc,gbExprNDescLst,outputColumnNames);
      }
    }
    ArrayList<AggInfo> aggregations=new ArrayList<AggInfo>();
    if (hasAggregationTrees) {
      assert(aggregationTrees != null);
      for (      ASTNode value : aggregationTrees.values()) {
        String aggName=unescapeIdentifier(value.getChild(0).getText());
        boolean isDistinct=value.getType() == HiveParser.TOK_FUNCTIONDI;
        boolean isAllColumns=value.getType() == HiveParser.TOK_FUNCTIONSTAR;
        if (isDistinct) {
          numDistinctUDFs++;
        }
        ArrayList<ExprNodeDesc> aggParameters=new ArrayList<ExprNodeDesc>();
        for (int i=1; i < value.getChildCount(); i++) {
          ASTNode paraExpr=(ASTNode)value.getChild(i);
          ExprNodeDesc paraExprNode=genExprNodeDesc(paraExpr,groupByInputRowResolver);
          aggParameters.add(paraExprNode);
        }
        Mode amode=groupByDescModeToUDAFMode(GroupByDesc.Mode.COMPLETE,isDistinct);
        GenericUDAFEvaluator genericUDAFEvaluator=getGenericUDAFEvaluator(aggName,aggParameters,value,isDistinct,isAllColumns);
        assert(genericUDAFEvaluator != null);
        GenericUDAFInfo udaf=getGenericUDAFInfo(genericUDAFEvaluator,amode,aggParameters);
        AggInfo aInfo=new AggInfo(aggParameters,udaf.returnType,aggName,isDistinct);
        aggregations.add(aInfo);
        String field=getColumnInternalName(gbExprNDescLst.size() + aggregations.size() - 1);
        outputColumnNames.add(field);
        groupByOutputRowResolver.putExpression(value,new ColumnInfo(field,aInfo.m_returnType,"",false));
      }
    }
    gbRel=genGBRelNode(gbExprNDescLst,aggregations,srcRel);
    m_relToHiveColNameOptiqPosMap.put(gbRel,buildHiveToOptiqColumnMap(groupByOutputRowResolver,gbRel));
    this.m_relToHiveRR.put(gbRel,groupByOutputRowResolver);
  }
  return gbRel;
}
