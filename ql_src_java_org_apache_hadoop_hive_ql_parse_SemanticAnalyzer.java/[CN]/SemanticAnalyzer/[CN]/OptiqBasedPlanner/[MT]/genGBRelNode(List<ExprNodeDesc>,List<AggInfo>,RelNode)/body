{
  RowResolver gbInputRR=this.relToHiveRR.get(srcRel);
  ArrayList<ColumnInfo> signature=gbInputRR.getRowSchema().getSignature();
  ImmutableMap<String,Integer> posMap=this.relToHiveColNameOptiqPosMap.get(srcRel);
  RexNodeConverter converter=new RexNodeConverter(this.cluster,srcRel.getRowType(),posMap,0,false);
  final List<RexNode> gbChildProjLst=Lists.newArrayList();
  final HashMap<String,Integer> rexNodeToPosMap=new HashMap<String,Integer>();
  final BitSet groupSet=new BitSet();
  Integer gbIndx=0;
  RexNode rnd;
  for (  ExprNodeDesc key : gbExprs) {
    rnd=converter.convert(key);
    gbChildProjLst.add(rnd);
    groupSet.set(gbIndx);
    rexNodeToPosMap.put(rnd.toString(),gbIndx);
    gbIndx++;
  }
  List<AggregateCall> aggregateCalls=Lists.newArrayList();
  int i=aggInfoLst.size();
  for (  AggInfo agg : aggInfoLst) {
    aggregateCalls.add(convertGBAgg(agg,srcRel,gbChildProjLst,converter,rexNodeToPosMap,gbChildProjLst.size()));
  }
  if (gbChildProjLst.isEmpty()) {
    gbChildProjLst.add(this.cluster.getRexBuilder().makeInputRef(srcRel,0));
  }
  RelNode gbInputRel=HiveProjectRel.create(srcRel,gbChildProjLst,null);
  HiveRel aggregateRel=null;
  try {
    aggregateRel=new HiveAggregateRel(cluster,cluster.traitSetOf(HiveRel.CONVENTION),gbInputRel,groupSet,aggregateCalls);
  }
 catch (  InvalidRelException e) {
    throw new SemanticException(e);
  }
  return aggregateRel;
}
