{
  Utilities.SQLCommand<Void> execUpdate=new Utilities.SQLCommand<Void>(){
    @Override public Void run(    PreparedStatement stmt) throws SQLException {
      stmt.executeUpdate();
      return null;
    }
  }
;
  try {
    rowID=JDBCStatsUtils.truncateRowId(rowID);
    String keyPrefix=Utilities.escapeSqlLike(rowID) + "%";
    PreparedStatement delStmt=Utilities.prepareWithRetry(conn,JDBCStatsUtils.getDeleteAggr(rowID,comment),waitWindow,maxRetries);
    delStmt.setString(1,keyPrefix);
    delStmt.setString(2,Character.toString(Utilities.sqlEscapeChar));
    for (int failures=0; ; failures++) {
      try {
        Utilities.executeWithRetry(execUpdate,delStmt,waitWindow,maxRetries);
        return true;
      }
 catch (      SQLRecoverableException e) {
        if (failures >= maxRetries) {
          LOG.error("Error during clean-up after " + maxRetries + " retries. "+ e);
          return false;
        }
        closeConnection();
        long waitTime=Utilities.getRandomWaitTime(waitWindow,failures,r);
        try {
          Thread.sleep(waitTime);
        }
 catch (        InterruptedException iex) {
        }
        if (!connect(hiveconf,sourceTask)) {
          LOG.error("Error during clean-up. " + e);
          return false;
        }
      }
catch (      SQLException e) {
        LOG.error("Error during clean-up. " + e);
        return false;
      }
    }
  }
 catch (  SQLException e) {
    LOG.error("Error during publishing aggregation. " + e);
    return false;
  }
}
