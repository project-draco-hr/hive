{
  FileSystem fs=directory.getFileSystem(conf);
  final List<ParsedDelta> deltas=new ArrayList<ParsedDelta>();
  List<ParsedDelta> working=new ArrayList<ParsedDelta>();
  List<FileStatus> originalDirectories=new ArrayList<FileStatus>();
  final List<FileStatus> obsolete=new ArrayList<FileStatus>();
  List<HdfsFileStatusWithId> childrenWithId=null;
  if (useFileIds) {
    try {
      childrenWithId=SHIMS.listLocatedHdfsStatus(fs,directory,hiddenFileFilter);
    }
 catch (    Throwable t) {
      LOG.error("Failed to get files with ID; using regular API: " + t.getMessage());
      useFileIds=false;
    }
  }
  TxnBase bestBase=new TxnBase();
  final List<HdfsFileStatusWithId> original=new ArrayList<>();
  if (childrenWithId != null) {
    for (    HdfsFileStatusWithId child : childrenWithId) {
      getChildState(child.getFileStatus(),child,txnList,working,originalDirectories,original,obsolete,bestBase,ignoreEmptyFiles);
    }
  }
 else {
    List<FileStatus> children=HdfsUtils.listLocatedStatus(fs,directory,hiddenFileFilter);
    for (    FileStatus child : children) {
      getChildState(child,null,txnList,working,originalDirectories,original,obsolete,bestBase,ignoreEmptyFiles);
    }
  }
  if (bestBase.status != null) {
    for (    HdfsFileStatusWithId fswid : original) {
      obsolete.add(fswid.getFileStatus());
    }
    obsolete.addAll(originalDirectories);
    original.clear();
    originalDirectories.clear();
  }
 else {
    for (    FileStatus origDir : originalDirectories) {
      findOriginals(fs,origDir,original,useFileIds);
    }
  }
  Collections.sort(working);
  long current=bestBase.txn;
  int lastStmtId=-1;
  ParsedDelta prev=null;
  for (  ParsedDelta next : working) {
    if (next.maxTransaction > current) {
      if (txnList.isTxnRangeValid(current + 1,next.maxTransaction) != ValidTxnList.RangeResponse.NONE) {
        deltas.add(next);
        current=next.maxTransaction;
        lastStmtId=next.statementId;
        prev=next;
      }
    }
 else     if (next.maxTransaction == current && lastStmtId >= 0) {
      deltas.add(next);
      prev=next;
    }
 else     if (prev != null && next.maxTransaction == prev.maxTransaction && next.minTransaction == prev.minTransaction && next.statementId == prev.statementId) {
      deltas.add(next);
      prev=next;
    }
 else {
      obsolete.add(next.path);
    }
  }
  if (bestBase.oldestBase != null && bestBase.status == null) {
    long[] exceptions=txnList.getInvalidTransactions();
    String minOpenTxn=exceptions != null && exceptions.length > 0 ? Long.toString(exceptions[0]) : "x";
    throw new IOException(ErrorMsg.ACID_NOT_ENOUGH_HISTORY.format(Long.toString(txnList.getHighWatermark()),minOpenTxn,bestBase.oldestBase.toString()));
  }
  final Path base=bestBase.status == null ? null : bestBase.status.getPath();
  LOG.debug("in directory " + directory.toUri().toString() + " base = "+ base+ " deltas = "+ deltas.size());
  return new Directory(){
    @Override public Path getBaseDirectory(){
      return base;
    }
    @Override public List<HdfsFileStatusWithId> getOriginalFiles(){
      return original;
    }
    @Override public List<ParsedDelta> getCurrentDirectories(){
      return deltas;
    }
    @Override public List<FileStatus> getObsolete(){
      return obsolete;
    }
  }
;
}
