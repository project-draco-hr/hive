{
  String tblName="acidTable";
  String owner="acid";
  Map<String,String> fields=new HashMap<String,String>();
  fields.put("name",serdeConstants.STRING_TYPE_NAME);
  fields.put("income",serdeConstants.INT_TYPE_NAME);
  Type type=createType("Person",fields);
  Map<String,String> params=new HashMap<String,String>();
  params.put("transactional","");
  Map<String,String> serdParams=new HashMap<String,String>();
  serdParams.put(serdeConstants.SERIALIZATION_FORMAT,"1");
  StorageDescriptor sd=createStorageDescriptor(tblName,type.getFields(),params,serdParams);
  sd.setNumBuckets(0);
  sd.unsetBucketCols();
  try {
    Table t=createTable(MetaStoreUtils.DEFAULT_DATABASE_NAME,tblName,owner,params,null,sd,0);
    Assert.assertTrue("Expected exception",false);
  }
 catch (  MetaException e) {
    Assert.assertEquals("'transactional' property of TBLPROPERTIES may only have value 'true'",e.getMessage());
  }
  try {
    params.clear();
    params.put("transactional","foobar");
    Table t=createTable(MetaStoreUtils.DEFAULT_DATABASE_NAME,tblName,owner,params,null,sd,0);
    Assert.assertTrue("Expected exception",false);
  }
 catch (  MetaException e) {
    Assert.assertEquals("'transactional' property of TBLPROPERTIES may only have value 'true'",e.getMessage());
  }
  try {
    params.clear();
    params.put("transactional","true");
    Table t=createTable(MetaStoreUtils.DEFAULT_DATABASE_NAME,tblName,owner,params,null,sd,0);
    Assert.assertTrue("Expected exception",false);
  }
 catch (  MetaException e) {
    Assert.assertEquals("The table must be bucketed and stored using an ACID compliant format (such as ORC)",e.getMessage());
  }
  try {
    params.clear();
    params.put("transactional","true");
    List<String> bucketCols=new ArrayList<String>();
    bucketCols.add("income");
    sd.setBucketCols(bucketCols);
    Table t=createTable(MetaStoreUtils.DEFAULT_DATABASE_NAME,tblName,owner,params,null,sd,0);
    Assert.assertTrue("Expected exception",false);
  }
 catch (  MetaException e) {
    Assert.assertEquals("The table must be bucketed and stored using an ACID compliant format (such as ORC)",e.getMessage());
  }
  params.clear();
  params.put("transactional","true");
  List<String> bucketCols=new ArrayList<String>();
  bucketCols.add("income");
  sd.setBucketCols(bucketCols);
  sd.setInputFormat("org.apache.hadoop.hive.ql.io.orc.OrcInputFormat");
  sd.setOutputFormat("org.apache.hadoop.hive.ql.io.orc.OrcOutputFormat");
  Table t=createTable(MetaStoreUtils.DEFAULT_DATABASE_NAME,tblName,owner,params,null,sd,0);
  Assert.assertTrue("CREATE TABLE should succeed","true".equals(t.getParameters().get(hive_metastoreConstants.TABLE_IS_TRANSACTIONAL)));
  try {
    params.clear();
    params.put("transactional","false");
    t=new Table();
    t.setParameters(params);
    client.alter_table(MetaStoreUtils.DEFAULT_DATABASE_NAME,tblName,t);
    Assert.assertTrue("Expected exception",false);
  }
 catch (  MetaException e) {
    Assert.assertEquals("TBLPROPERTIES with 'transactional'='true' cannot be unset",e.getMessage());
  }
  try {
    tblName+="1";
    params.clear();
    sd.unsetBucketCols();
    t=createTable(MetaStoreUtils.DEFAULT_DATABASE_NAME,tblName,owner,params,null,sd,0);
    params.put("transactional","true");
    t.setParameters(params);
    client.alter_table(MetaStoreUtils.DEFAULT_DATABASE_NAME,tblName,t);
    Assert.assertTrue("Expected exception",false);
  }
 catch (  MetaException e) {
    Assert.assertEquals("The table must be bucketed and stored using an ACID compliant format (such as ORC)",e.getMessage());
  }
  tblName+="2";
  params.clear();
  sd.setNumBuckets(1);
  sd.setBucketCols(bucketCols);
  t=createTable(MetaStoreUtils.DEFAULT_DATABASE_NAME,tblName,owner,params,null,sd,0);
  params.put("transactional","true");
  t.setParameters(params);
  t.setPartitionKeys(Collections.EMPTY_LIST);
  client.alter_table(MetaStoreUtils.DEFAULT_DATABASE_NAME,tblName,t);
  Assert.assertTrue("ALTER TABLE should succeed","true".equals(t.getParameters().get(hive_metastoreConstants.TABLE_IS_TRANSACTIONAL)));
}
