{
  boolean new_abort=abort;
  if (!abort) {
    if (scriptError != null) {
      throw new HiveException(scriptError);
    }
    try {
      try {
        scriptOutWriter.close();
      }
 catch (      IOException e) {
        if (isBrokenPipeException(e) && allowPartialConsumption()) {
          LOG.warn("Got broken pipe: ignoring exception");
        }
 else {
          if (isBrokenPipeException(e)) {
            displayBrokenPipeInfo();
          }
          throw e;
        }
      }
      int exitVal=scriptPid.waitFor();
      if (exitVal != 0) {
        LOG.error("Script failed with code " + exitVal);
        new_abort=true;
      }
      ;
    }
 catch (    IOException e) {
      LOG.error("Got ioexception: " + e.getMessage());
      e.printStackTrace();
      new_abort=true;
    }
catch (    InterruptedException e) {
    }
  }
 else {
    try {
      final Thread mythread=Thread.currentThread();
      Timer timer=new Timer(true);
      timer.schedule(new TimerTask(){
        @Override public void run(){
          mythread.interrupt();
        }
      }
,1000);
      int exitVal=scriptPid.waitFor();
      timer.cancel();
      LOG.error("Script exited with code " + exitVal);
    }
 catch (    InterruptedException e) {
      LOG.error("Script has not exited yet. It will be killed.");
    }
  }
  try {
    outThread.join(0);
  }
 catch (  Exception e) {
    LOG.warn("Exception in closing outThread: " + StringUtils.stringifyException(e));
  }
  try {
    errThread.join(0);
  }
 catch (  Exception e) {
    LOG.warn("Exception in closing errThread: " + StringUtils.stringifyException(e));
  }
  try {
    scriptPid.destroy();
  }
 catch (  Exception e) {
    LOG.warn("Exception in destroying scriptPid: " + StringUtils.stringifyException(e));
  }
  super.close(new_abort);
  if (new_abort && !abort) {
    throw new HiveException("Hit error while closing ..");
  }
}
