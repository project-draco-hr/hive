{
  if (dynamicPartitioningUsed) {
    discoverPartitions(context);
  }
  OutputJobInfo jobInfo=HCatOutputFormat.getJobInfo(context.getConfiguration());
  Configuration conf=context.getConfiguration();
  Table table=new Table(jobInfo.getTableInfo().getTable());
  Path tblPath=new Path(table.getTTable().getSd().getLocation());
  FileSystem fs=tblPath.getFileSystem(conf);
  if (table.getPartitionKeys().size() == 0) {
    Path src=new Path(jobInfo.getLocation());
    moveTaskOutputs(fs,src,src,tblPath,false,table.isImmutable());
    if (!src.equals(tblPath)) {
      fs.delete(src,true);
    }
    return;
  }
  HiveMetaStoreClient client=null;
  HCatTableInfo tableInfo=jobInfo.getTableInfo();
  List<Partition> partitionsAdded=new ArrayList<Partition>();
  try {
    HiveConf hiveConf=HCatUtil.getHiveConf(conf);
    client=HCatUtil.getHiveClient(hiveConf);
    StorerInfo storer=InternalUtil.extractStorerInfo(table.getTTable().getSd(),table.getParameters());
    FileStatus tblStat=fs.getFileStatus(tblPath);
    String grpName=tblStat.getGroup();
    FsPermission perms=tblStat.getPermission();
    List<Partition> partitionsToAdd=new ArrayList<Partition>();
    if (!dynamicPartitioningUsed) {
      partitionsToAdd.add(constructPartition(context,jobInfo,tblPath.toString(),null,jobInfo.getPartitionValues(),jobInfo.getOutputSchema(),getStorerParameterMap(storer),table,fs,grpName,perms));
    }
 else {
      for (      Entry<String,Map<String,String>> entry : partitionsDiscoveredByPath.entrySet()) {
        partitionsToAdd.add(constructPartition(context,jobInfo,getPartitionRootLocation(entry.getKey(),entry.getValue().size()),entry.getKey(),entry.getValue(),jobInfo.getOutputSchema(),getStorerParameterMap(storer),table,fs,grpName,perms));
      }
    }
    ArrayList<Map<String,String>> ptnInfos=new ArrayList<Map<String,String>>();
    for (    Partition ptn : partitionsToAdd) {
      ptnInfos.add(InternalUtil.createPtnKeyValueMap(new Table(tableInfo.getTable()),ptn));
    }
    if (dynamicPartitioningUsed && harProcessor.isEnabled() && (!partitionsToAdd.isEmpty())) {
      if (!customDynamicLocationUsed) {
        Path src=new Path(ptnRootLocation);
        moveTaskOutputs(fs,src,src,tblPath,true,true);
        moveTaskOutputs(fs,src,src,tblPath,false,true);
        if (!src.equals(tblPath)) {
          fs.delete(src,true);
        }
      }
 else {
        moveCustomLocationTaskOutputs(fs,table,hiveConf);
      }
      try {
        updateTableSchema(client,table,jobInfo.getOutputSchema());
        LOG.info("HAR is being used. The table {} has new partitions {}.",table.getTableName(),ptnInfos);
        client.add_partitions(partitionsToAdd);
        partitionsAdded=partitionsToAdd;
      }
 catch (      Exception e) {
        for (        Partition p : partitionsToAdd) {
          Path ptnPath=new Path(harProcessor.getParentFSPath(new Path(p.getSd().getLocation())));
          if (fs.exists(ptnPath)) {
            fs.delete(ptnPath,true);
          }
        }
        throw e;
      }
    }
 else {
      updateTableSchema(client,table,jobInfo.getOutputSchema());
      LOG.info("HAR not is not being used. The table {} has new partitions {}.",table.getTableName(),ptnInfos);
      if (partitionsToAdd.size() > 0) {
        if (!dynamicPartitioningUsed) {
          if (partitionsToAdd.size() > 1) {
            throw new HCatException(ErrorType.ERROR_PUBLISHING_PARTITION,"More than one partition to publish in non-dynamic partitioning job");
          }
          Partition p=partitionsToAdd.get(0);
          Path src=new Path(jobInfo.getLocation());
          Path dest=new Path(p.getSd().getLocation());
          moveTaskOutputs(fs,src,src,dest,true,table.isImmutable());
          moveTaskOutputs(fs,src,src,dest,false,table.isImmutable());
          if (!src.equals(dest)) {
            fs.delete(src,true);
          }
          boolean publishRequired=false;
          try {
            Partition existingP=client.getPartition(p.getDbName(),p.getTableName(),p.getValues());
            if (existingP != null) {
              if (table.isImmutable()) {
                throw new HCatException(ErrorType.ERROR_DUPLICATE_PARTITION,"Attempted duplicate partition publish on to immutable table");
              }
 else {
                if (!existingP.getSd().getInputFormat().equals(table.getInputFormatClass().getName())) {
                  throw new HCatException(ErrorType.ERROR_PUBLISHING_PARTITION,"Attempted partition append, where old partition format was " + existingP.getSd().getInputFormat() + " and table format was "+ table.getInputFormatClass().getName());
                }
              }
            }
 else {
              publishRequired=true;
            }
          }
 catch (          NoSuchObjectException e) {
            publishRequired=true;
          }
          if (publishRequired) {
            client.add_partitions(partitionsToAdd);
            partitionsAdded=partitionsToAdd;
          }
        }
 else {
          if (!customDynamicLocationUsed) {
            Path src=new Path(ptnRootLocation);
            moveTaskOutputs(fs,src,src,tblPath,true,true);
            moveTaskOutputs(fs,src,src,tblPath,false,true);
            if (!src.equals(tblPath)) {
              fs.delete(src,true);
            }
          }
 else {
            moveCustomLocationTaskOutputs(fs,table,hiveConf);
          }
          client.add_partitions(partitionsToAdd);
          partitionsAdded=partitionsToAdd;
        }
      }
      for (      Partition p : partitionsAdded) {
        applyGroupAndPerms(fs,new Path(p.getSd().getLocation()),tblStat.getPermission(),tblStat.getGroup(),true);
      }
    }
  }
 catch (  Exception e) {
    if (partitionsAdded.size() > 0) {
      try {
        for (        Partition p : partitionsAdded) {
          client.dropPartition(tableInfo.getDatabaseName(),tableInfo.getTableName(),p.getValues());
        }
      }
 catch (      Exception te) {
        throw new HCatException(ErrorType.ERROR_PUBLISHING_PARTITION,e);
      }
    }
    if (e instanceof HCatException) {
      throw (HCatException)e;
    }
 else {
      throw new HCatException(ErrorType.ERROR_PUBLISHING_PARTITION,e);
    }
  }
 finally {
    HCatUtil.closeHiveClientQuietly(client);
  }
}
