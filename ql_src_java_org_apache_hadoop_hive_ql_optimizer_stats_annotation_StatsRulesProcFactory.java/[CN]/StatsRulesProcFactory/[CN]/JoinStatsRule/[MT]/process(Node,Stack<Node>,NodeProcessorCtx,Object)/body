{
  CommonJoinOperator<? extends JoinDesc> jop=(CommonJoinOperator<? extends JoinDesc>)nd;
  List<Operator<? extends OperatorDesc>> parents=jop.getParentOperators();
  AnnotateStatsProcCtx aspCtx=(AnnotateStatsProcCtx)procCtx;
  HiveConf conf=aspCtx.getConf();
  boolean allStatsAvail=true;
  boolean allSatisfyPreCondition=true;
  for (  Operator<? extends OperatorDesc> op : parents) {
    if (op.getStatistics() == null) {
      allStatsAvail=false;
    }
  }
  if (allStatsAvail) {
    for (    Operator<? extends OperatorDesc> op : parents) {
      if (!satisfyPrecondition(op.getStatistics())) {
        allSatisfyPreCondition=false;
      }
    }
    try {
      if (allSatisfyPreCondition) {
        Statistics stats=new Statistics();
        long prodRows=1;
        List<Long> distinctVals=Lists.newArrayList();
        boolean multiAttr=false;
        Map<String,ColStatistics> joinedColStats=Maps.newHashMap();
        Map<Integer,List<String>> joinKeys=Maps.newHashMap();
        for (int pos=0; pos < parents.size(); pos++) {
          ReduceSinkOperator parent=(ReduceSinkOperator)jop.getParentOperators().get(pos);
          Statistics parentStats=parent.getStatistics();
          prodRows*=parentStats.getNumRows();
          List<ExprNodeDesc> keyExprs=parent.getConf().getKeyCols();
          if (keyExprs.size() > 1) {
            multiAttr=true;
          }
          List<String> fqCols=StatsUtils.getFullQualifedColNameFromExprs(keyExprs,parent.getColumnExprMap());
          joinKeys.put(pos,fqCols);
          Map<String,ExprNodeDesc> colExprMap=parent.getColumnExprMap();
          RowSchema rs=parent.getSchema();
          List<ColStatistics> cs=StatsUtils.getColStatisticsFromExprMap(conf,parentStats,colExprMap,rs);
          for (          ColStatistics c : cs) {
            if (c != null) {
              joinedColStats.put(c.getFullyQualifiedColName(),c);
            }
          }
          stats.updateColumnStatsState(parentStats.getColumnStatsState());
        }
        long denom=1;
        if (multiAttr) {
          List<Long> perAttrDVs=Lists.newArrayList();
          int numAttr=joinKeys.get(0).size();
          for (int idx=0; idx < numAttr; idx++) {
            for (            Integer i : joinKeys.keySet()) {
              String col=joinKeys.get(i).get(idx);
              ColStatistics cs=joinedColStats.get(col);
              if (cs != null) {
                perAttrDVs.add(cs.getCountDistint());
              }
            }
            distinctVals.add(getDenominator(perAttrDVs));
            perAttrDVs.clear();
          }
          for (          Long l : distinctVals) {
            denom*=l;
          }
        }
 else {
          for (          List<String> jkeys : joinKeys.values()) {
            for (            String jk : jkeys) {
              ColStatistics cs=joinedColStats.get(jk);
              if (cs != null) {
                distinctVals.add(cs.getCountDistint());
              }
            }
          }
          denom=getDenominator(distinctVals);
        }
        Map<String,ExprNodeDesc> colExprMap=jop.getColumnExprMap();
        RowSchema rs=jop.getSchema();
        List<ColStatistics> outColStats=Lists.newArrayList();
        for (        ColumnInfo ci : rs.getSignature()) {
          String key=ci.getInternalName();
          ExprNodeDesc end=colExprMap.get(key);
          if (end instanceof ExprNodeColumnDesc) {
            String colName=((ExprNodeColumnDesc)end).getColumn();
            colName=StatsUtils.stripPrefixFromColumnName(colName);
            String tabAlias=((ExprNodeColumnDesc)end).getTabAlias();
            String fqColName=StatsUtils.getFullyQualifiedColumnName(tabAlias,colName);
            ColStatistics cs=joinedColStats.get(fqColName);
            String outColName=key;
            String outTabAlias=ci.getTabAlias();
            outColName=StatsUtils.stripPrefixFromColumnName(outColName);
            if (cs != null) {
              cs.setColumnName(outColName);
              cs.setTableAlias(outTabAlias);
            }
            outColStats.add(cs);
          }
        }
        stats.setColumnStats(outColStats);
        long newRowCount=prodRows / denom;
        stats.setNumRows(newRowCount);
        stats.setDataSize(StatsUtils.getDataSizeFromColumnStats(newRowCount,outColStats));
        jop.setStatistics(stats);
      }
 else {
        if (parents.size() > 1) {
          Statistics wcStats=new Statistics();
          Statistics stp1=parents.get(0).getStatistics();
          long numRows=stp1.getNumRows();
          long avgRowSize=stp1.getAvgRowSize();
          for (int i=1; i < parents.size(); i++) {
            stp1=parents.get(i).getStatistics();
            numRows=(numRows * stp1.getNumRows()) / 2;
            avgRowSize+=stp1.getAvgRowSize();
          }
          wcStats.setNumRows(numRows);
          wcStats.setDataSize(numRows * avgRowSize);
          jop.setStatistics(wcStats);
        }
 else {
          jop.setStatistics(parents.get(0).getStatistics().clone());
        }
      }
    }
 catch (    CloneNotSupportedException e) {
      throw new SemanticException(ErrorMsg.STATISTICS_CLONING_FAILED.getMsg());
    }
  }
  return null;
}
