{
  List<Table> tbls=new ArrayList<Table>();
  Map<String,String> part=showTblStatus.getPartSpec();
  Partition par=null;
  if (part != null) {
    Table tbl=db.getTable(showTblStatus.getDbName(),showTblStatus.getPattern());
    par=db.getPartition(tbl,part,false);
    if (par == null) {
      throw new HiveException("Partition " + part + " for table "+ showTblStatus.getPattern()+ " does not exist.");
    }
    tbls.add(tbl);
  }
 else {
    LOG.info("pattern: " + showTblStatus.getPattern());
    List<String> tblStr=db.getTablesForDb(showTblStatus.getDbName(),showTblStatus.getPattern());
    SortedSet<String> sortedTbls=new TreeSet<String>(tblStr);
    Iterator<String> iterTbls=sortedTbls.iterator();
    while (iterTbls.hasNext()) {
      String tblName=iterTbls.next();
      Table tbl=db.getTable(showTblStatus.getDbName(),tblName);
      tbls.add(tbl);
    }
    LOG.info("results : " + tblStr.size());
  }
  DataOutput outStream=null;
  try {
    Path resFile=new Path(showTblStatus.getResFile());
    FileSystem fs=resFile.getFileSystem(conf);
    outStream=fs.create(resFile);
    Iterator<Table> iterTables=tbls.iterator();
    while (iterTables.hasNext()) {
      Table tbl=iterTables.next();
      String tableName=tbl.getTableName();
      String tblLoc=null;
      String inputFormattCls=null;
      String outputFormattCls=null;
      if (part != null) {
        if (par != null) {
          if (par.getLocation() != null) {
            tblLoc=par.getDataLocation().toString();
          }
          inputFormattCls=par.getInputFormatClass().getName();
          outputFormattCls=par.getOutputFormatClass().getName();
        }
      }
 else {
        if (tbl.getPath() != null) {
          tblLoc=tbl.getDataLocation().toString();
        }
        inputFormattCls=tbl.getInputFormatClass().getName();
        outputFormattCls=tbl.getOutputFormatClass().getName();
      }
      String owner=tbl.getOwner();
      List<FieldSchema> cols=tbl.getCols();
      String ddlCols=MetaStoreUtils.getDDLFromFieldSchema("columns",cols);
      boolean isPartitioned=tbl.isPartitioned();
      String partitionCols="";
      if (isPartitioned) {
        partitionCols=MetaStoreUtils.getDDLFromFieldSchema("partition_columns",tbl.getPartCols());
      }
      outStream.writeBytes("tableName:" + tableName);
      outStream.write(terminator);
      outStream.writeBytes("owner:" + owner);
      outStream.write(terminator);
      outStream.writeBytes("location:" + tblLoc);
      outStream.write(terminator);
      outStream.writeBytes("inputformat:" + inputFormattCls);
      outStream.write(terminator);
      outStream.writeBytes("outputformat:" + outputFormattCls);
      outStream.write(terminator);
      outStream.writeBytes("columns:" + ddlCols);
      outStream.write(terminator);
      outStream.writeBytes("partitioned:" + isPartitioned);
      outStream.write(terminator);
      outStream.writeBytes("partitionColumns:" + partitionCols);
      outStream.write(terminator);
      Path tablLoc=tbl.getPath();
      List<Path> locations=new ArrayList<Path>();
      if (isPartitioned) {
        if (par == null) {
          for (          Partition curPart : db.getPartitions(tbl)) {
            if (curPart.getLocation() != null) {
              locations.add(new Path(curPart.getLocation()));
            }
          }
        }
 else {
          if (par.getLocation() != null) {
            locations.add(new Path(par.getLocation()));
          }
        }
      }
 else {
        if (tablLoc != null) {
          locations.add(tablLoc);
        }
      }
      if (!locations.isEmpty()) {
        writeFileSystemStats(outStream,locations,tablLoc,false,0);
      }
      outStream.write(terminator);
    }
    ((FSDataOutputStream)outStream).close();
    outStream=null;
  }
 catch (  FileNotFoundException e) {
    LOG.info("show table status: " + stringifyException(e));
    return 1;
  }
catch (  IOException e) {
    LOG.info("show table status: " + stringifyException(e));
    return 1;
  }
catch (  Exception e) {
    throw new HiveException(e);
  }
 finally {
    IOUtils.closeStream((FSDataOutputStream)outStream);
  }
  return 0;
}
