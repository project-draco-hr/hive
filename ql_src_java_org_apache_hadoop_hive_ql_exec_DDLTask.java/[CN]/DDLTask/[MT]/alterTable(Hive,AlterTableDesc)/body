{
  Table tbl=db.getTable(alterTbl.getOldName());
  Partition part=null;
  List<Partition> allPartitions=null;
  if (alterTbl.getPartSpec() != null) {
    if (alterTbl.getOp() != AlterTableDesc.AlterTableTypes.ALTERPROTECTMODE) {
      part=db.getPartition(tbl,alterTbl.getPartSpec(),false);
      if (part == null) {
        formatter.consoleError(console,"Partition : " + alterTbl.getPartSpec().toString() + " does not exist.",formatter.MISSING);
        return 1;
      }
    }
 else {
      allPartitions=db.getPartitions(tbl,alterTbl.getPartSpec());
    }
  }
  Table oldTbl=tbl.copy();
  if (alterTbl.getOp() == AlterTableDesc.AlterTableTypes.RENAME) {
    tbl.setTableName(alterTbl.getNewName());
  }
 else   if (alterTbl.getOp() == AlterTableDesc.AlterTableTypes.ADDCOLS) {
    List<FieldSchema> newCols=alterTbl.getNewCols();
    List<FieldSchema> oldCols=tbl.getCols();
    if (tbl.getSerializationLib().equals("org.apache.hadoop.hive.serde.thrift.columnsetSerDe")) {
      console.printInfo("Replacing columns for columnsetSerDe and changing to LazySimpleSerDe");
      tbl.setSerializationLib(LazySimpleSerDe.class.getName());
      tbl.getTTable().getSd().setCols(newCols);
    }
 else {
      Iterator<FieldSchema> iterNewCols=newCols.iterator();
      while (iterNewCols.hasNext()) {
        FieldSchema newCol=iterNewCols.next();
        String newColName=newCol.getName();
        Iterator<FieldSchema> iterOldCols=oldCols.iterator();
        while (iterOldCols.hasNext()) {
          String oldColName=iterOldCols.next().getName();
          if (oldColName.equalsIgnoreCase(newColName)) {
            formatter.consoleError(console,"Column '" + newColName + "' exists",formatter.CONFLICT);
            return 1;
          }
        }
        oldCols.add(newCol);
      }
      tbl.getTTable().getSd().setCols(oldCols);
    }
  }
 else   if (alterTbl.getOp() == AlterTableDesc.AlterTableTypes.RENAMECOLUMN) {
    List<FieldSchema> oldCols=tbl.getCols();
    List<FieldSchema> newCols=new ArrayList<FieldSchema>();
    Iterator<FieldSchema> iterOldCols=oldCols.iterator();
    String oldName=alterTbl.getOldColName();
    String newName=alterTbl.getNewColName();
    String type=alterTbl.getNewColType();
    String comment=alterTbl.getNewColComment();
    boolean first=alterTbl.getFirst();
    String afterCol=alterTbl.getAfterCol();
    FieldSchema column=null;
    boolean found=false;
    int position=-1;
    if (first) {
      position=0;
    }
    int i=1;
    while (iterOldCols.hasNext()) {
      FieldSchema col=iterOldCols.next();
      String oldColName=col.getName();
      if (oldColName.equalsIgnoreCase(newName) && !oldColName.equalsIgnoreCase(oldName)) {
        formatter.consoleError(console,"Column '" + newName + "' exists",formatter.CONFLICT);
        return 1;
      }
 else       if (oldColName.equalsIgnoreCase(oldName)) {
        col.setName(newName);
        if (type != null && !type.trim().equals("")) {
          col.setType(type);
        }
        if (comment != null) {
          col.setComment(comment);
        }
        found=true;
        if (first || (afterCol != null && !afterCol.trim().equals(""))) {
          column=col;
          continue;
        }
      }
      if (afterCol != null && !afterCol.trim().equals("") && oldColName.equalsIgnoreCase(afterCol)) {
        position=i;
      }
      i++;
      newCols.add(col);
    }
    if (!found) {
      formatter.consoleError(console,"Column '" + oldName + "' does not exists",formatter.MISSING);
      return 1;
    }
    if ((afterCol != null && !afterCol.trim().equals("")) && position < 0) {
      formatter.consoleError(console,"Column '" + afterCol + "' does not exists",formatter.MISSING);
      return 1;
    }
    if (position >= 0) {
      newCols.add(position,column);
    }
    tbl.getTTable().getSd().setCols(newCols);
  }
 else   if (alterTbl.getOp() == AlterTableDesc.AlterTableTypes.REPLACECOLS) {
    if (tbl.getSerializationLib().equals("org.apache.hadoop.hive.serde.thrift.columnsetSerDe")) {
      console.printInfo("Replacing columns for columnsetSerDe and changing to LazySimpleSerDe");
      tbl.setSerializationLib(LazySimpleSerDe.class.getName());
    }
 else     if (!tbl.getSerializationLib().equals(MetadataTypedColumnsetSerDe.class.getName()) && !tbl.getSerializationLib().equals(LazySimpleSerDe.class.getName()) && !tbl.getSerializationLib().equals(ColumnarSerDe.class.getName())&& !tbl.getSerializationLib().equals(DynamicSerDe.class.getName())) {
      formatter.consoleError(console,"Replace columns is not supported for this table. " + "SerDe may be incompatible.",formatter.ERROR);
      return 1;
    }
    tbl.getTTable().getSd().setCols(alterTbl.getNewCols());
  }
 else   if (alterTbl.getOp() == AlterTableDesc.AlterTableTypes.ADDPROPS) {
    tbl.getTTable().getParameters().putAll(alterTbl.getProps());
  }
 else   if (alterTbl.getOp() == AlterTableDesc.AlterTableTypes.DROPPROPS) {
    Iterator<String> keyItr=alterTbl.getProps().keySet().iterator();
    while (keyItr.hasNext()) {
      tbl.getTTable().getParameters().remove(keyItr.next());
    }
  }
 else   if (alterTbl.getOp() == AlterTableDesc.AlterTableTypes.ADDSERDEPROPS) {
    if (part != null) {
      part.getTPartition().getSd().getSerdeInfo().getParameters().putAll(alterTbl.getProps());
    }
 else {
      tbl.getTTable().getSd().getSerdeInfo().getParameters().putAll(alterTbl.getProps());
    }
  }
 else   if (alterTbl.getOp() == AlterTableDesc.AlterTableTypes.ADDSERDE) {
    String serdeName=alterTbl.getSerdeName();
    if (part != null) {
      part.getTPartition().getSd().getSerdeInfo().setSerializationLib(serdeName);
      if ((alterTbl.getProps() != null) && (alterTbl.getProps().size() > 0)) {
        part.getTPartition().getSd().getSerdeInfo().getParameters().putAll(alterTbl.getProps());
      }
      part.getTPartition().getSd().setCols(part.getTPartition().getSd().getCols());
    }
 else {
      tbl.setSerializationLib(alterTbl.getSerdeName());
      if ((alterTbl.getProps() != null) && (alterTbl.getProps().size() > 0)) {
        tbl.getTTable().getSd().getSerdeInfo().getParameters().putAll(alterTbl.getProps());
      }
      tbl.setFields(Hive.getFieldsFromDeserializer(tbl.getTableName(),tbl.getDeserializer()));
    }
  }
 else   if (alterTbl.getOp() == AlterTableDesc.AlterTableTypes.ADDFILEFORMAT) {
    if (part != null) {
      part.getTPartition().getSd().setInputFormat(alterTbl.getInputFormat());
      part.getTPartition().getSd().setOutputFormat(alterTbl.getOutputFormat());
      if (alterTbl.getSerdeName() != null) {
        part.getTPartition().getSd().getSerdeInfo().setSerializationLib(alterTbl.getSerdeName());
      }
    }
 else {
      tbl.getTTable().getSd().setInputFormat(alterTbl.getInputFormat());
      tbl.getTTable().getSd().setOutputFormat(alterTbl.getOutputFormat());
      if (alterTbl.getSerdeName() != null) {
        tbl.setSerializationLib(alterTbl.getSerdeName());
      }
    }
  }
 else   if (alterTbl.getOp() == AlterTableDesc.AlterTableTypes.ALTERPROTECTMODE) {
    boolean protectModeEnable=alterTbl.isProtectModeEnable();
    AlterTableDesc.ProtectModeType protectMode=alterTbl.getProtectModeType();
    ProtectMode mode=null;
    if (allPartitions != null) {
      for (      Partition tmpPart : allPartitions) {
        mode=tmpPart.getProtectMode();
        setAlterProtectMode(protectModeEnable,protectMode,mode);
        tmpPart.setProtectMode(mode);
      }
    }
 else {
      mode=tbl.getProtectMode();
      setAlterProtectMode(protectModeEnable,protectMode,mode);
      tbl.setProtectMode(mode);
    }
  }
 else   if (alterTbl.getOp() == AlterTableDesc.AlterTableTypes.ADDCLUSTERSORTCOLUMN) {
    List<String> columns=Utilities.getColumnNamesFromFieldSchema(tbl.getCols());
    if (!alterTbl.isTurnOffSorting()) {
      Utilities.validateColumnNames(columns,alterTbl.getBucketColumns());
    }
    if (alterTbl.getSortColumns() != null) {
      Utilities.validateColumnNames(columns,Utilities.getColumnNamesFromSortCols(alterTbl.getSortColumns()));
    }
    StorageDescriptor sd=part == null ? tbl.getTTable().getSd() : part.getTPartition().getSd();
    if (alterTbl.isTurnOffSorting()) {
      sd.setSortCols(new ArrayList<Order>());
    }
 else     if (alterTbl.getNumberBuckets() == -1) {
      sd.setBucketCols(new ArrayList<String>());
      sd.setNumBuckets(-1);
      sd.setSortCols(new ArrayList<Order>());
    }
 else {
      sd.setBucketCols(alterTbl.getBucketColumns());
      sd.setNumBuckets(alterTbl.getNumberBuckets());
      sd.setSortCols(alterTbl.getSortColumns());
    }
  }
 else   if (alterTbl.getOp() == AlterTableDesc.AlterTableTypes.ALTERLOCATION) {
    String newLocation=alterTbl.getNewLocation();
    try {
      URI locUri=new URI(newLocation);
      if (!locUri.isAbsolute() || locUri.getScheme() == null || locUri.getScheme().trim().equals("")) {
        throw new HiveException(newLocation + " is not absolute or has no scheme information. " + "Please specify a complete absolute uri with scheme information.");
      }
      if (part != null) {
        part.setLocation(newLocation);
      }
 else {
        tbl.setDataLocation(locUri);
      }
    }
 catch (    URISyntaxException e) {
      throw new HiveException(e);
    }
  }
 else   if (alterTbl.getOp() == AlterTableDesc.AlterTableTypes.ADDSKEWEDBY) {
    List<String> skewedColNames=null;
    List<List<String>> skewedValues=null;
    if (alterTbl.isTurnOffSkewed()) {
      skewedColNames=new ArrayList<String>();
      skewedValues=new ArrayList<List<String>>();
    }
 else {
      skewedColNames=alterTbl.getSkewedColNames();
      skewedValues=alterTbl.getSkewedColValues();
    }
    if (null == tbl.getSkewedInfo()) {
      SkewedInfo skewedInfo=new SkewedInfo();
      skewedInfo.setSkewedColNames(skewedColNames);
      skewedInfo.setSkewedColValues(skewedValues);
      tbl.setSkewedInfo(skewedInfo);
    }
 else {
      tbl.setSkewedColNames(skewedColNames);
      tbl.setSkewedColValues(skewedValues);
    }
    tbl.setStoredAsSubDirectories(alterTbl.isStoredAsSubDirectories());
  }
 else   if (alterTbl.getOp() == AlterTableDesc.AlterTableTypes.ALTERSKEWEDLOCATION) {
    Map<List<String>,String> locMaps=alterTbl.getSkewedLocations();
    Set<List<String>> keys=locMaps.keySet();
    for (    List<String> key : keys) {
      String newLocation=locMaps.get(key);
      try {
        URI locUri=new URI(newLocation);
        if (part != null) {
          List<String> slk=new ArrayList<String>(key);
          part.setSkewedValueLocationMap(slk,locUri.toString());
        }
 else {
          List<String> slk=new ArrayList<String>(key);
          tbl.setSkewedValueLocationMap(slk,locUri.toString());
        }
      }
 catch (      URISyntaxException e) {
        throw new HiveException(e);
      }
    }
  }
 else   if (alterTbl.getOp() == AlterTableTypes.ALTERBUCKETNUM) {
    if (part != null) {
      if (part.getBucketCount() == alterTbl.getNumberBuckets()) {
        return 0;
      }
      part.setBucketCount(alterTbl.getNumberBuckets());
    }
 else {
      if (tbl.getNumBuckets() == alterTbl.getNumberBuckets()) {
        return 0;
      }
      tbl.setNumBuckets(alterTbl.getNumberBuckets());
    }
  }
 else {
    formatter.consoleError(console,"Unsupported Alter commnad",formatter.ERROR);
    return 1;
  }
  if (part == null && allPartitions == null) {
    if (!updateModifiedParameters(tbl.getTTable().getParameters(),conf)) {
      return 1;
    }
    try {
      tbl.checkValidity();
    }
 catch (    HiveException e) {
      formatter.consoleError(console,"Invalid table columns : " + e.getMessage(),formatter.ERROR);
      return 1;
    }
  }
 else   if (part != null) {
    if (!updateModifiedParameters(part.getParameters(),conf)) {
      return 1;
    }
  }
 else {
    for (    Partition tmpPart : allPartitions) {
      if (!updateModifiedParameters(tmpPart.getParameters(),conf)) {
        return 1;
      }
    }
  }
  try {
    if (part == null && allPartitions == null) {
      db.alterTable(alterTbl.getOldName(),tbl);
    }
 else     if (part != null) {
      db.alterPartition(tbl.getTableName(),part);
    }
 else {
      db.alterPartitions(tbl.getTableName(),allPartitions);
    }
  }
 catch (  InvalidOperationException e) {
    console.printError("Invalid alter operation: " + e.getMessage());
    LOG.info("alter table: " + stringifyException(e));
    return 1;
  }
catch (  HiveException e) {
    return 1;
  }
  if (part != null) {
    work.getInputs().add(new ReadEntity(part));
    work.getOutputs().add(new WriteEntity(part));
  }
 else   if (allPartitions != null) {
    for (    Partition tmpPart : allPartitions) {
      work.getInputs().add(new ReadEntity(tmpPart));
      work.getOutputs().add(new WriteEntity(tmpPart));
    }
  }
 else {
    work.getInputs().add(new ReadEntity(oldTbl));
    work.getOutputs().add(new WriteEntity(tbl));
  }
  return 0;
}
