{
  super.initialize(hconf);
  totalMemory=Runtime.getRuntime().totalMemory();
  keyFields=new ExprNodeEvaluator[conf.getKeys().size()];
  for (int i=0; i < keyFields.length; i++) {
    keyFields[i]=ExprNodeEvaluatorFactory.get(conf.getKeys().get(i));
  }
  aggregationParameterFields=new ExprNodeEvaluator[conf.getAggregators().size()][];
  for (int i=0; i < aggregationParameterFields.length; i++) {
    ArrayList<exprNodeDesc> parameters=conf.getAggregators().get(i).getParameters();
    aggregationParameterFields[i]=new ExprNodeEvaluator[parameters.size()];
    for (int j=0; j < parameters.size(); j++) {
      aggregationParameterFields[i][j]=ExprNodeEvaluatorFactory.get(parameters.get(j));
    }
  }
  aggregationIsDistinct=new boolean[conf.getAggregators().size()];
  for (int i=0; i < aggregationIsDistinct.length; i++) {
    aggregationIsDistinct[i]=conf.getAggregators().get(i).getDistinct();
  }
  aggregationClasses=(Class<? extends UDAF>[])new Class[conf.getAggregators().size()];
  for (int i=0; i < conf.getAggregators().size(); i++) {
    aggregationDesc agg=conf.getAggregators().get(i);
    aggregationClasses[i]=agg.getAggregationClass();
  }
  aggregationsAggregateMethods=new Method[aggregationClasses.length];
  aggregationsEvaluateMethods=new Method[aggregationClasses.length];
  String evaluateMethodName=((conf.getMode() == groupByDesc.Mode.PARTIAL1 || conf.getMode() == groupByDesc.Mode.HASH || conf.getMode() == groupByDesc.Mode.PARTIAL2) ? "evaluatePartial" : "evaluate");
  for (int i=0; i < aggregationClasses.length; i++) {
    String aggregateMethodName=(((conf.getMode() == groupByDesc.Mode.PARTIAL1) || (conf.getMode() == groupByDesc.Mode.HASH)) ? "aggregate" : "aggregatePartial");
    if (aggregationIsDistinct[i] && (conf.getMode() != groupByDesc.Mode.FINAL))     aggregateMethodName="aggregate";
    for (    Method m : aggregationClasses[i].getMethods()) {
      if (m.getName().equals(aggregateMethodName) && m.getParameterTypes().length == aggregationParameterFields[i].length) {
        aggregationsAggregateMethods[i]=m;
        break;
      }
    }
    if (null == aggregationsAggregateMethods[i]) {
      throw new HiveException("Cannot find " + aggregateMethodName + " method of UDAF class "+ aggregationClasses[i].getName()+ " that accepts "+ aggregationParameterFields[i].length+ " parameters!");
    }
    try {
      aggregationsEvaluateMethods[i]=aggregationClasses[i].getMethod(evaluateMethodName);
    }
 catch (    Exception e) {
      throw new HiveException("Unable to get the method named " + evaluateMethodName + " from "+ aggregationClasses[i]+ ": "+ e.getMessage());
    }
    if (null == aggregationsEvaluateMethods[i]) {
      throw new HiveException("Cannot find " + evaluateMethodName + " method of UDAF class "+ aggregationClasses[i].getName()+ "!");
    }
    assert(aggregationsEvaluateMethods[i] != null);
  }
  aggregationsParametersLastInvoke=new Object[conf.getAggregators().size()][];
  if (conf.getMode() != groupByDesc.Mode.HASH) {
    aggregations=newAggregations();
    hashAggr=false;
  }
 else {
    hashAggregations=new HashMap<ArrayList<Object>,UDAF[]>();
    hashAggr=true;
    keyPositionsSize=new ArrayList<Integer>();
  }
  int totalFields=keyFields.length + aggregationClasses.length;
  objectInspectors=new ArrayList<ObjectInspector>(totalFields);
  for (int i=0; i < keyFields.length; i++) {
    objectInspectors.add(null);
  }
  for (int i=0; i < aggregationClasses.length; i++) {
    objectInspectors.add(ObjectInspectorFactory.getStandardPrimitiveObjectInspector(aggregationsEvaluateMethods[i].getReturnType()));
  }
  firstRow=true;
  if (conf.getMode() == groupByDesc.Mode.HASH)   computeMaxEntriesHashAggr(hconf);
}
