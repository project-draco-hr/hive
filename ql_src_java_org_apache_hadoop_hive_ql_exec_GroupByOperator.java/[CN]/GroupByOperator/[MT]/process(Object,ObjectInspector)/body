{
  if (hashAggr) {
    numRowsInput++;
    if (numRowsInput == numRowsCompareHashAggr) {
      numRowsCompareHashAggr+=groupbyMapAggrInterval;
      if ((numRowsHashTbl * 2) > numRowsInput) {
        LOG.warn("Disable Hash Aggr: #hash table = " + numRowsHashTbl + " #total = "+ numRowsInput);
        flush(true);
        hashAggr=false;
      }
 else       LOG.trace("Hash Aggr Enabled: #hash table = " + numRowsHashTbl + " #total = "+ numRowsInput);
    }
  }
  try {
    newKeys.clear();
    for (int i=0; i < keyFields.length; i++) {
      keyFields[i].evaluate(row,rowInspector,keyInspectableObject[i]);
      newKeys.add(keyInspectableObject[i].o);
      if (firstRow) {
        objectInspectors.set(i,keyInspectableObject[i].oi);
      }
    }
    if (firstRow) {
      firstRow=false;
      outputObjectInspector=ObjectInspectorFactory.getStandardStructObjectInspector(fieldNames,objectInspectors);
    }
    if (hashAggr)     processHashAggr(row,rowInspector,newKeys);
 else     processAggr(row,rowInspector,newKeys);
  }
 catch (  HiveException e) {
    throw e;
  }
catch (  Exception e) {
    throw new HiveException(e);
  }
}
