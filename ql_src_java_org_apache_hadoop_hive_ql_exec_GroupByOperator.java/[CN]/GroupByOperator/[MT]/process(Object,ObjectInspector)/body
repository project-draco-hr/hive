{
  try {
    ArrayList<Object> newKeys=new ArrayList<Object>(keyFields.length);
    for (int i=0; i < keyFields.length; i++) {
      keyFields[i].evaluate(row,rowInspector,tempInspectableObject);
      newKeys.add(tempInspectableObject.o);
      if (firstRow) {
        objectInspectors.set(i,tempInspectableObject.oi);
      }
    }
    if (firstRow) {
      firstRow=false;
      ArrayList<String> fieldNames=new ArrayList<String>(objectInspectors.size());
      for (int i=0; i < objectInspectors.size(); i++) {
        fieldNames.add(Integer.valueOf(i).toString());
      }
      outputObjectInspector=ObjectInspectorFactory.getStandardStructObjectInspector(fieldNames,objectInspectors);
    }
    UDAF[] aggs=null;
    Object[][] lastInvoke=null;
    if (aggregations != null) {
      boolean keysAreEqual=newKeys.equals(currentKeys);
      if (currentKeys != null && !keysAreEqual) {
        forward(currentKeys,aggregations);
      }
      if (currentKeys == null || !keysAreEqual) {
        currentKeys=newKeys;
        for (        UDAF aggregation : aggregations) {
          aggregation.init();
        }
        for (int i=0; i < aggregationsParametersLastInvoke.length; i++) {
          aggregationsParametersLastInvoke[i]=null;
        }
      }
      aggs=aggregations;
      lastInvoke=aggregationsParametersLastInvoke;
    }
 else {
      aggs=hashAggregations.get(newKeys);
      if (aggs == null) {
        aggs=newAggregations();
        hashAggregations.put(newKeys,aggs);
        lastInvoke=null;
      }
    }
    updateAggregations(aggs,row,rowInspector,lastInvoke);
  }
 catch (  Exception e) {
    e.printStackTrace();
    throw new HiveException(e);
  }
}
