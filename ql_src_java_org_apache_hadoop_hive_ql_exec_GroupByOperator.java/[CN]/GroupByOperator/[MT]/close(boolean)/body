{
  if (!abort) {
    try {
      if (firstRow && (keyFields.length == 0)) {
        firstRow=false;
        for (int ai=0; ai < aggregations.length; ai++) {
          Object[] o=new Object[aggregationParameterFields[ai].length];
          for (int pi=0; pi < aggregationParameterFields[ai].length; pi++)           o[pi]=null;
          FunctionRegistry.invoke(aggregationsAggregateMethods[ai],aggregations[ai],o);
        }
        forward(new ArrayList<Object>(0),aggregations);
      }
 else {
        if (hashAggregations != null) {
          LOG.warn("Begin Hash Table flush at close: size = " + hashAggregations.size());
          Iterator iter=hashAggregations.entrySet().iterator();
          while (iter.hasNext()) {
            Map.Entry<ArrayList<Object>,UDAFEvaluator[]> m=(Map.Entry)iter.next();
            forward(m.getKey(),m.getValue());
            iter.remove();
          }
          hashAggregations.clear();
        }
 else         if (aggregations != null) {
          if (currentKeys != null) {
            forward(currentKeys,aggregations);
          }
          currentKeys=null;
        }
 else {
        }
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
      throw new HiveException(e);
    }
  }
  super.close(abort);
}
