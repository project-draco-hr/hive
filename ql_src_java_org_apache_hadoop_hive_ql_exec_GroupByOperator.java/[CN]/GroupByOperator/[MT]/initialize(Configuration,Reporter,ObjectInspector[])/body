{
  super.initialize(hconf,reporter,inputObjInspector);
  totalMemory=Runtime.getRuntime().totalMemory();
  numRowsInput=0;
  numRowsHashTbl=0;
  keyFields=new ExprNodeEvaluator[conf.getKeys().size()];
  keyObjectInspectors=new ObjectInspector[conf.getKeys().size()];
  keyObjects=new Object[conf.getKeys().size()];
  for (int i=0; i < keyFields.length; i++) {
    keyFields[i]=ExprNodeEvaluatorFactory.get(conf.getKeys().get(i));
    keyObjectInspectors[i]=null;
    keyObjects[i]=null;
  }
  newKeys=new ArrayList<Object>(keyFields.length);
  aggregationParameterFields=new ExprNodeEvaluator[conf.getAggregators().size()][];
  aggregationParameterObjectInspectors=new ObjectInspector[conf.getAggregators().size()][];
  aggregationParameterObjects=new Object[conf.getAggregators().size()][];
  for (int i=0; i < aggregationParameterFields.length; i++) {
    ArrayList<exprNodeDesc> parameters=conf.getAggregators().get(i).getParameters();
    aggregationParameterFields[i]=new ExprNodeEvaluator[parameters.size()];
    aggregationParameterObjectInspectors[i]=new ObjectInspector[parameters.size()];
    aggregationParameterObjects[i]=new Object[parameters.size()];
    for (int j=0; j < parameters.size(); j++) {
      aggregationParameterFields[i][j]=ExprNodeEvaluatorFactory.get(parameters.get(j));
      aggregationParameterObjectInspectors[i][j]=null;
      aggregationParameterObjects[i][j]=null;
    }
  }
  aggregationIsDistinct=new boolean[conf.getAggregators().size()];
  for (int i=0; i < aggregationIsDistinct.length; i++) {
    aggregationIsDistinct[i]=conf.getAggregators().get(i).getDistinct();
  }
  aggregationClasses=(Class<? extends UDAFEvaluator>[])new Class[conf.getAggregators().size()];
  for (int i=0; i < conf.getAggregators().size(); i++) {
    aggregationDesc agg=conf.getAggregators().get(i);
    aggregationClasses[i]=agg.getAggregationClass();
  }
  aggregationsAggregateMethods=new Method[aggregationClasses.length];
  aggregationsEvaluateMethods=new Method[aggregationClasses.length];
  for (int i=0; i < aggregationClasses.length; i++) {
    String evaluateMethodName=conf.getEvalMethods().get(i);
    String aggregateMethodName=conf.getAggMethods().get(i);
    for (    Method m : aggregationClasses[i].getMethods()) {
      if (m.getName().equals(aggregateMethodName) && m.getParameterTypes().length == aggregationParameterFields[i].length) {
        aggregationsAggregateMethods[i]=m;
        break;
      }
    }
    if (null == aggregationsAggregateMethods[i]) {
      throw new HiveException("Cannot find " + aggregateMethodName + " method of UDAF class "+ aggregationClasses[i].getName()+ " that accepts "+ aggregationParameterFields[i].length+ " parameters!");
    }
    try {
      aggregationsEvaluateMethods[i]=aggregationClasses[i].getMethod(evaluateMethodName);
    }
 catch (    Exception e) {
      throw new HiveException("Unable to get the method named " + evaluateMethodName + " from "+ aggregationClasses[i]+ ": "+ e.getMessage());
    }
    if (null == aggregationsEvaluateMethods[i]) {
      throw new HiveException("Cannot find " + evaluateMethodName + " method of UDAF class "+ aggregationClasses[i].getName()+ "!");
    }
    assert(aggregationsEvaluateMethods[i] != null);
  }
  aggregationsParametersLastInvoke=new Object[conf.getAggregators().size()][];
  if (conf.getMode() != groupByDesc.Mode.HASH) {
    aggregations=newAggregations();
    hashAggr=false;
  }
 else {
    hashAggregations=new HashMap<ArrayList<Object>,UDAFEvaluator[]>();
    aggregations=newAggregations();
    hashAggr=true;
    keyPositionsSize=new ArrayList<Integer>();
    aggrPositions=new ArrayList<varLenFields>();
    groupbyMapAggrInterval=HiveConf.getIntVar(hconf,HiveConf.ConfVars.HIVEGROUPBYMAPINTERVAL);
    numRowsCompareHashAggr=groupbyMapAggrInterval;
  }
  int totalFields=keyFields.length + aggregationClasses.length;
  objectInspectors=new ArrayList<ObjectInspector>(totalFields);
  for (int i=0; i < keyFields.length; i++) {
    objectInspectors.add(null);
  }
  for (int i=0; i < aggregationClasses.length; i++) {
    objectInspectors.add(PrimitiveObjectInspectorFactory.getPrimitiveWritableObjectInspector(PrimitiveObjectInspectorUtils.getTypeEntryFromPrimitiveWritableClass(aggregationsEvaluateMethods[i].getReturnType()).primitiveCategory));
  }
  fieldNames=new ArrayList<String>(objectInspectors.size());
  for (int i=0; i < objectInspectors.size(); i++) {
    fieldNames.add(Integer.valueOf(i).toString());
  }
  outputObjectInspector=ObjectInspectorFactory.getStandardStructObjectInspector(fieldNames,objectInspectors);
  firstRow=true;
  if (conf.getMode() == groupByDesc.Mode.HASH)   computeMaxEntriesHashAggr(hconf);
}
