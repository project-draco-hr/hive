{
  AggregationBuffer[] aggs=null;
  boolean newEntryForHashAggr=false;
  KeyWrapper keyProber=new KeyWrapper();
  keyProber.hashcode=newKeys.hashCode();
  keyProber.copiedKeys=newKeys;
  aggs=hashAggregations.get(keyProber);
  ArrayList<Object> newDefaultKeys=null;
  if (aggs == null) {
    newDefaultKeys=deepCopyElements(keyObjects,keyObjectInspectors,ObjectInspectorCopyOption.WRITABLE);
    keyProber.copiedKeys=newDefaultKeys;
    aggs=newAggregations();
    hashAggregations.put(keyProber,aggs);
    newEntryForHashAggr=true;
    numRowsHashTbl++;
  }
  if (groupKeyIsNotReduceKey) {
    if (newDefaultKeys == null)     newDefaultKeys=deepCopyElements(keyObjects,keyObjectInspectors,ObjectInspectorCopyOption.WRITABLE);
    newEntryForHashAggr=keysCurrentGroup.add(newDefaultKeys);
  }
  updateAggregations(aggs,row,rowInspector,true,newEntryForHashAggr,null);
  if ((!groupKeyIsNotReduceKey || firstRowInGroup) && shouldBeFlushed(newKeys)) {
    flush(false);
  }
}
