{
  numRowsInput=0;
  numRowsHashTbl=0;
  heartbeatInterval=HiveConf.getIntVar(hconf,HiveConf.ConfVars.HIVESENDHEARTBEAT);
  countAfterReport=0;
  groupingSetsPresent=conf.isGroupingSetsPresent();
  ObjectInspector rowInspector=inputObjInspectors[0];
  int numKeys=conf.getKeys().size();
  keyFields=new ExprNodeEvaluator[numKeys];
  keyObjectInspectors=new ObjectInspector[numKeys];
  currentKeyObjectInspectors=new ObjectInspector[numKeys];
  for (int i=0; i < numKeys; i++) {
    keyFields[i]=ExprNodeEvaluatorFactory.get(conf.getKeys().get(i));
    keyObjectInspectors[i]=keyFields[i].initialize(rowInspector);
    currentKeyObjectInspectors[i]=ObjectInspectorUtils.getStandardObjectInspector(keyObjectInspectors[i],ObjectInspectorCopyOption.WRITABLE);
  }
  if (groupingSetsPresent) {
    groupingSets=conf.getListGroupingSets();
    groupingSetsPosition=conf.getGroupingSetPosition();
    newKeysGroupingSets=new Text[groupingSets.size()];
    groupingSetsBitSet=new FastBitSet[groupingSets.size()];
    int pos=0;
    for (    Integer groupingSet : groupingSets) {
      newKeysGroupingSets[pos]=new Text(String.valueOf(groupingSet));
      groupingSetsBitSet[pos]=groupingSet2BitSet(groupingSet);
      pos++;
    }
  }
  List<? extends StructField> sfs=((StructObjectInspector)rowInspector).getAllStructFieldRefs();
  if (sfs.size() > 0) {
    StructField keyField=sfs.get(0);
    if (keyField.getFieldName().toUpperCase().equals(Utilities.ReduceField.KEY.name())) {
      ObjectInspector keyObjInspector=keyField.getFieldObjectInspector();
      if (keyObjInspector instanceof StructObjectInspector) {
        List<? extends StructField> keysfs=((StructObjectInspector)keyObjInspector).getAllStructFieldRefs();
        if (keysfs.size() > 0) {
          StructField sf=keysfs.get(keysfs.size() - 1);
          if (sf.getFieldObjectInspector().getCategory().equals(ObjectInspector.Category.UNION)) {
            unionExprEval=ExprNodeEvaluatorFactory.get(new ExprNodeColumnDesc(TypeInfoUtils.getTypeInfoFromObjectInspector(sf.getFieldObjectInspector()),keyField.getFieldName() + "." + sf.getFieldName(),null,false));
            unionExprEval.initialize(rowInspector);
          }
        }
      }
    }
  }
  ArrayList<AggregationDesc> aggrs=conf.getAggregators();
  aggregationParameterFields=new ExprNodeEvaluator[aggrs.size()][];
  aggregationParameterObjectInspectors=new ObjectInspector[aggrs.size()][];
  aggregationParameterStandardObjectInspectors=new ObjectInspector[aggrs.size()][];
  aggregationParameterObjects=new Object[aggrs.size()][];
  aggregationIsDistinct=new boolean[aggrs.size()];
  for (int i=0; i < aggrs.size(); i++) {
    AggregationDesc aggr=aggrs.get(i);
    ArrayList<ExprNodeDesc> parameters=aggr.getParameters();
    aggregationParameterFields[i]=new ExprNodeEvaluator[parameters.size()];
    aggregationParameterObjectInspectors[i]=new ObjectInspector[parameters.size()];
    aggregationParameterStandardObjectInspectors[i]=new ObjectInspector[parameters.size()];
    aggregationParameterObjects[i]=new Object[parameters.size()];
    for (int j=0; j < parameters.size(); j++) {
      aggregationParameterFields[i][j]=ExprNodeEvaluatorFactory.get(parameters.get(j));
      aggregationParameterObjectInspectors[i][j]=aggregationParameterFields[i][j].initialize(rowInspector);
      if (unionExprEval != null) {
        String[] names=parameters.get(j).getExprString().split("\\.");
        if (Utilities.ReduceField.KEY.name().equals(names[0]) && names.length > 2) {
          String name=names[names.length - 2];
          int tag=Integer.parseInt(name.split("\\:")[1]);
          if (aggr.getDistinct()) {
            Set<Integer> set=distinctKeyAggrs.get(tag);
            if (null == set) {
              set=new HashSet<Integer>();
              distinctKeyAggrs.put(tag,set);
            }
            if (!set.contains(i)) {
              set.add(i);
            }
          }
 else {
            Set<Integer> set=nonDistinctKeyAggrs.get(tag);
            if (null == set) {
              set=new HashSet<Integer>();
              nonDistinctKeyAggrs.put(tag,set);
            }
            if (!set.contains(i)) {
              set.add(i);
            }
          }
        }
 else {
          if (!nonDistinctAggrs.contains(i)) {
            nonDistinctAggrs.add(i);
          }
        }
      }
 else {
        if (aggr.getDistinct()) {
          aggregationIsDistinct[i]=true;
        }
      }
      aggregationParameterStandardObjectInspectors[i][j]=ObjectInspectorUtils.getStandardObjectInspector(aggregationParameterObjectInspectors[i][j],ObjectInspectorCopyOption.WRITABLE);
      aggregationParameterObjects[i][j]=null;
    }
    if (parameters.size() == 0) {
      if (!nonDistinctAggrs.contains(i)) {
        nonDistinctAggrs.add(i);
      }
    }
  }
  aggregationEvaluators=new GenericUDAFEvaluator[conf.getAggregators().size()];
  for (int i=0; i < aggregationEvaluators.length; i++) {
    AggregationDesc agg=conf.getAggregators().get(i);
    aggregationEvaluators[i]=agg.getGenericUDAFEvaluator();
  }
  MapredContext context=MapredContext.get();
  if (context != null) {
    for (    GenericUDAFEvaluator genericUDAFEvaluator : aggregationEvaluators) {
      context.setup(genericUDAFEvaluator);
    }
  }
  aggregationsParametersLastInvoke=new Object[conf.getAggregators().size()][];
  if ((conf.getMode() != GroupByDesc.Mode.HASH || conf.getBucketGroup()) && (!groupingSetsPresent)) {
    aggregations=newAggregations();
    hashAggr=false;
  }
 else {
    hashAggregations=new HashMap<KeyWrapper,AggregationBuffer[]>(256);
    aggregations=newAggregations();
    hashAggr=true;
    keyPositionsSize=new ArrayList<Integer>();
    aggrPositions=new List[aggregations.length];
    groupbyMapAggrInterval=HiveConf.getIntVar(hconf,HiveConf.ConfVars.HIVEGROUPBYMAPINTERVAL);
    numRowsCompareHashAggr=groupbyMapAggrInterval;
    minReductionHashAggr=HiveConf.getFloatVar(hconf,HiveConf.ConfVars.HIVEMAPAGGRHASHMINREDUCTION);
    groupKeyIsNotReduceKey=conf.getGroupKeyNotReductionKey();
    if (groupKeyIsNotReduceKey) {
      keysCurrentGroup=new HashSet<KeyWrapper>();
    }
  }
  List<String> fieldNames=new ArrayList<String>(conf.getOutputColumnNames());
  outputKeyLength=conf.pruneGroupingSetId() ? keyFields.length - 1 : keyFields.length;
  ObjectInspector[] objectInspectors=new ObjectInspector[outputKeyLength + aggregationEvaluators.length];
  for (int i=0; i < outputKeyLength; i++) {
    objectInspectors[i]=currentKeyObjectInspectors[i];
  }
  for (int i=0; i < aggregationEvaluators.length; i++) {
    objectInspectors[outputKeyLength + i]=aggregationEvaluators[i].init(conf.getAggregators().get(i).getMode(),aggregationParameterObjectInspectors[i]);
  }
  outputObjInspector=ObjectInspectorFactory.getStandardStructObjectInspector(fieldNames,Arrays.asList(objectInspectors));
  KeyWrapperFactory keyWrapperFactory=new KeyWrapperFactory(keyFields,keyObjectInspectors,currentKeyObjectInspectors);
  newKeys=keyWrapperFactory.getKeyWrapper();
  firstRow=true;
  if (hashAggr) {
    computeMaxEntriesHashAggr(hconf);
  }
  memoryMXBean=ManagementFactory.getMemoryMXBean();
  maxMemory=memoryMXBean.getHeapMemoryUsage().getMax();
  memoryThreshold=this.getConf().getMemoryThreshold();
  initializeChildren(hconf);
}
