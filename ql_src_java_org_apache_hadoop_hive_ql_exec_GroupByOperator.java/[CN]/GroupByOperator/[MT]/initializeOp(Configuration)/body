{
  totalMemory=Runtime.getRuntime().totalMemory();
  numRowsInput=0;
  numRowsHashTbl=0;
  heartbeatInterval=HiveConf.getIntVar(hconf,HiveConf.ConfVars.HIVESENDHEARTBEAT);
  countAfterReport=0;
  groupingSetsPresent=conf.isGroupingSetsPresent();
  ObjectInspector rowInspector=inputObjInspectors[0];
  int numKeys=conf.getKeys().size();
  keyFields=new ExprNodeEvaluator[numKeys];
  keyObjectInspectors=new ObjectInspector[numKeys];
  currentKeyObjectInspectors=new ObjectInspector[numKeys];
  for (int i=0; i < numKeys; i++) {
    keyFields[i]=ExprNodeEvaluatorFactory.get(conf.getKeys().get(i));
    keyObjectInspectors[i]=keyFields[i].initialize(rowInspector);
    currentKeyObjectInspectors[i]=ObjectInspectorUtils.getStandardObjectInspector(keyObjectInspectors[i],ObjectInspectorCopyOption.WRITABLE);
  }
  if (groupingSetsPresent) {
    groupingSets=conf.getListGroupingSets();
    groupingSetsPosition=conf.getGroupingSetPosition();
    newKeysGroupingSets=new ArrayList<Object>();
    groupingSetsBitSet=new ArrayList<FastBitSet>();
    for (    Integer groupingSet : groupingSets) {
      ExprNodeEvaluator groupingSetValueEvaluator=ExprNodeEvaluatorFactory.get(new ExprNodeConstantDesc(String.valueOf(groupingSet)));
      newKeysGroupingSets.add(groupingSetValueEvaluator.evaluate(null));
      groupingSetsBitSet.add(groupingSet2BitSet(groupingSet));
    }
  }
  List<? extends StructField> sfs=((StructObjectInspector)rowInspector).getAllStructFieldRefs();
  if (sfs.size() > 0) {
    StructField keyField=sfs.get(0);
    if (keyField.getFieldName().toUpperCase().equals(Utilities.ReduceField.KEY.name())) {
      ObjectInspector keyObjInspector=keyField.getFieldObjectInspector();
      if (keyObjInspector instanceof StructObjectInspector) {
        List<? extends StructField> keysfs=((StructObjectInspector)keyObjInspector).getAllStructFieldRefs();
        if (keysfs.size() > 0) {
          StructField sf=keysfs.get(keysfs.size() - 1);
          if (sf.getFieldObjectInspector().getCategory().equals(ObjectInspector.Category.UNION)) {
            unionExprEval=ExprNodeEvaluatorFactory.get(new ExprNodeColumnDesc(TypeInfoUtils.getTypeInfoFromObjectInspector(sf.getFieldObjectInspector()),keyField.getFieldName() + "." + sf.getFieldName(),null,false));
            unionExprEval.initialize(rowInspector);
          }
        }
      }
    }
  }
  ArrayList<AggregationDesc> aggrs=conf.getAggregators();
  aggregationParameterFields=new ExprNodeEvaluator[aggrs.size()][];
  aggregationParameterObjectInspectors=new ObjectInspector[aggrs.size()][];
  aggregationParameterStandardObjectInspectors=new ObjectInspector[aggrs.size()][];
  aggregationParameterObjects=new Object[aggrs.size()][];
  aggregationIsDistinct=new boolean[aggrs.size()];
  for (int i=0; i < aggrs.size(); i++) {
    AggregationDesc aggr=aggrs.get(i);
    ArrayList<ExprNodeDesc> parameters=aggr.getParameters();
    aggregationParameterFields[i]=new ExprNodeEvaluator[parameters.size()];
    aggregationParameterObjectInspectors[i]=new ObjectInspector[parameters.size()];
    aggregationParameterStandardObjectInspectors[i]=new ObjectInspector[parameters.size()];
    aggregationParameterObjects[i]=new Object[parameters.size()];
    for (int j=0; j < parameters.size(); j++) {
      aggregationParameterFields[i][j]=ExprNodeEvaluatorFactory.get(parameters.get(j));
      aggregationParameterObjectInspectors[i][j]=aggregationParameterFields[i][j].initialize(rowInspector);
      if (unionExprEval != null) {
        String[] names=parameters.get(j).getExprString().split("\\.");
        if (Utilities.ReduceField.KEY.name().equals(names[0])) {
          String name=names[names.length - 2];
          int tag=Integer.parseInt(name.split("\\:")[1]);
          if (aggr.getDistinct()) {
            Set<Integer> set=distinctKeyAggrs.get(tag);
            if (null == set) {
              set=new HashSet<Integer>();
              distinctKeyAggrs.put(tag,set);
            }
            if (!set.contains(i)) {
              set.add(i);
            }
          }
 else {
            Set<Integer> set=nonDistinctKeyAggrs.get(tag);
            if (null == set) {
              set=new HashSet<Integer>();
              nonDistinctKeyAggrs.put(tag,set);
            }
            if (!set.contains(i)) {
              set.add(i);
            }
          }
        }
 else {
          if (!nonDistinctAggrs.contains(i)) {
            nonDistinctAggrs.add(i);
          }
        }
      }
 else {
        if (aggr.getDistinct()) {
          aggregationIsDistinct[i]=true;
        }
      }
      aggregationParameterStandardObjectInspectors[i][j]=ObjectInspectorUtils.getStandardObjectInspector(aggregationParameterObjectInspectors[i][j],ObjectInspectorCopyOption.WRITABLE);
      aggregationParameterObjects[i][j]=null;
    }
    if (parameters.size() == 0) {
      if (!nonDistinctAggrs.contains(i)) {
        nonDistinctAggrs.add(i);
      }
    }
  }
  aggregationEvaluators=new GenericUDAFEvaluator[conf.getAggregators().size()];
  for (int i=0; i < aggregationEvaluators.length; i++) {
    AggregationDesc agg=conf.getAggregators().get(i);
    aggregationEvaluators[i]=agg.getGenericUDAFEvaluator();
  }
  int totalFields=keyFields.length + aggregationEvaluators.length;
  objectInspectors=new ArrayList<ObjectInspector>(totalFields);
  for (  ExprNodeEvaluator keyField : keyFields) {
    objectInspectors.add(null);
  }
  MapredContext context=MapredContext.get();
  if (context != null) {
    for (    GenericUDAFEvaluator genericUDAFEvaluator : aggregationEvaluators) {
      context.setup(genericUDAFEvaluator);
    }
  }
  for (int i=0; i < aggregationEvaluators.length; i++) {
    ObjectInspector roi=aggregationEvaluators[i].init(conf.getAggregators().get(i).getMode(),aggregationParameterObjectInspectors[i]);
    objectInspectors.add(roi);
  }
  aggregationsParametersLastInvoke=new Object[conf.getAggregators().size()][];
  if ((conf.getMode() != GroupByDesc.Mode.HASH || conf.getBucketGroup()) && (!groupingSetsPresent)) {
    aggregations=newAggregations();
    hashAggr=false;
  }
 else {
    hashAggregations=new HashMap<KeyWrapper,AggregationBuffer[]>(256);
    aggregations=newAggregations();
    hashAggr=true;
    keyPositionsSize=new ArrayList<Integer>();
    aggrPositions=new List[aggregations.length];
    groupbyMapAggrInterval=HiveConf.getIntVar(hconf,HiveConf.ConfVars.HIVEGROUPBYMAPINTERVAL);
    numRowsCompareHashAggr=groupbyMapAggrInterval;
    minReductionHashAggr=HiveConf.getFloatVar(hconf,HiveConf.ConfVars.HIVEMAPAGGRHASHMINREDUCTION);
    groupKeyIsNotReduceKey=conf.getGroupKeyNotReductionKey();
    if (groupKeyIsNotReduceKey) {
      keysCurrentGroup=new HashSet<KeyWrapper>();
    }
  }
  fieldNames=conf.getOutputColumnNames();
  for (int i=0; i < keyFields.length; i++) {
    objectInspectors.set(i,currentKeyObjectInspectors[i]);
  }
  ArrayList<String> keyNames=new ArrayList<String>(keyFields.length);
  for (int i=0; i < keyFields.length; i++) {
    keyNames.add(fieldNames.get(i));
  }
  newKeyObjectInspector=ObjectInspectorFactory.getStandardStructObjectInspector(keyNames,Arrays.asList(keyObjectInspectors));
  currentKeyObjectInspector=ObjectInspectorFactory.getStandardStructObjectInspector(keyNames,Arrays.asList(currentKeyObjectInspectors));
  outputObjInspector=ObjectInspectorFactory.getStandardStructObjectInspector(fieldNames,objectInspectors);
  KeyWrapperFactory keyWrapperFactory=new KeyWrapperFactory(keyFields,keyObjectInspectors,currentKeyObjectInspectors);
  newKeys=keyWrapperFactory.getKeyWrapper();
  firstRow=true;
  if (hashAggr) {
    computeMaxEntriesHashAggr(hconf);
  }
  memoryMXBean=ManagementFactory.getMemoryMXBean();
  maxMemory=memoryMXBean.getHeapMemoryUsage().getMax();
  memoryThreshold=this.getConf().getMemoryThreshold();
  initializeChildren(hconf);
}
