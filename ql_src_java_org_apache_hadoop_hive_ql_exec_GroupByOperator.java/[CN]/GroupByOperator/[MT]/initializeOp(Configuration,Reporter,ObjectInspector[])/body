{
  totalMemory=Runtime.getRuntime().totalMemory();
  numRowsInput=0;
  numRowsHashTbl=0;
  keyFields=new ExprNodeEvaluator[conf.getKeys().size()];
  keyObjectInspectors=new ObjectInspector[conf.getKeys().size()];
  keyObjects=new Object[conf.getKeys().size()];
  for (int i=0; i < keyFields.length; i++) {
    keyFields[i]=ExprNodeEvaluatorFactory.get(conf.getKeys().get(i));
    keyObjectInspectors[i]=null;
    keyObjects[i]=null;
  }
  newKeys=new ArrayList<Object>(keyFields.length);
  currentKeyObjectInspectors=new ObjectInspector[conf.getKeys().size()];
  aggregationParameterFields=new ExprNodeEvaluator[conf.getAggregators().size()][];
  aggregationParameterObjectInspectors=new ObjectInspector[conf.getAggregators().size()][];
  aggregationParameterStandardObjectInspectors=new ObjectInspector[conf.getAggregators().size()][];
  aggregationParameterObjects=new Object[conf.getAggregators().size()][];
  for (int i=0; i < aggregationParameterFields.length; i++) {
    ArrayList<exprNodeDesc> parameters=conf.getAggregators().get(i).getParameters();
    aggregationParameterFields[i]=new ExprNodeEvaluator[parameters.size()];
    aggregationParameterObjectInspectors[i]=new ObjectInspector[parameters.size()];
    aggregationParameterStandardObjectInspectors[i]=new ObjectInspector[parameters.size()];
    aggregationParameterObjects[i]=new Object[parameters.size()];
    for (int j=0; j < parameters.size(); j++) {
      aggregationParameterFields[i][j]=ExprNodeEvaluatorFactory.get(parameters.get(j));
      aggregationParameterObjectInspectors[i][j]=null;
      aggregationParameterStandardObjectInspectors[i][j]=null;
      aggregationParameterObjects[i][j]=null;
    }
  }
  aggregationIsDistinct=new boolean[conf.getAggregators().size()];
  for (int i=0; i < aggregationIsDistinct.length; i++) {
    aggregationIsDistinct[i]=conf.getAggregators().get(i).getDistinct();
  }
  aggregationClasses=(Class<? extends UDAFEvaluator>[])new Class[conf.getAggregators().size()];
  for (int i=0; i < conf.getAggregators().size(); i++) {
    aggregationDesc agg=conf.getAggregators().get(i);
    aggregationClasses[i]=agg.getAggregationClass();
  }
  aggregationsAggregateMethods=new Method[aggregationClasses.length];
  aggregationsEvaluateMethods=new Method[aggregationClasses.length];
  for (int i=0; i < aggregationClasses.length; i++) {
    String evaluateMethodName=conf.getEvalMethods().get(i);
    String aggregateMethodName=conf.getAggMethods().get(i);
    for (    Method m : aggregationClasses[i].getMethods()) {
      if (m.getName().equals(aggregateMethodName) && m.getParameterTypes().length == aggregationParameterFields[i].length) {
        aggregationsAggregateMethods[i]=m;
        break;
      }
    }
    if (null == aggregationsAggregateMethods[i]) {
      throw new HiveException("Cannot find " + aggregateMethodName + " method of UDAF class "+ aggregationClasses[i].getName()+ " that accepts "+ aggregationParameterFields[i].length+ " parameters!");
    }
    try {
      aggregationsEvaluateMethods[i]=aggregationClasses[i].getMethod(evaluateMethodName);
    }
 catch (    Exception e) {
      throw new HiveException("Unable to get the method named " + evaluateMethodName + " from "+ aggregationClasses[i]+ ": "+ e.getMessage());
    }
    if (null == aggregationsEvaluateMethods[i]) {
      throw new HiveException("Cannot find " + evaluateMethodName + " method of UDAF class "+ aggregationClasses[i].getName()+ "!");
    }
    assert(aggregationsEvaluateMethods[i] != null);
  }
  aggregationsParametersLastInvoke=new Object[conf.getAggregators().size()][];
  if (conf.getMode() != groupByDesc.Mode.HASH) {
    aggregations=newAggregations();
    hashAggr=false;
  }
 else {
    hashAggregations=new HashMap<ArrayList<Object>,UDAFEvaluator[]>();
    aggregations=newAggregations();
    hashAggr=true;
    keyPositionsSize=new ArrayList<Integer>();
    aggrPositions=new ArrayList<varLenFields>();
    groupbyMapAggrInterval=HiveConf.getIntVar(hconf,HiveConf.ConfVars.HIVEGROUPBYMAPINTERVAL);
    numRowsCompareHashAggr=groupbyMapAggrInterval;
    minReductionHashAggr=HiveConf.getFloatVar(hconf,HiveConf.ConfVars.HIVEMAPAGGRHASHMINREDUCTION);
  }
  int totalFields=keyFields.length + aggregationClasses.length;
  objectInspectors=new ArrayList<ObjectInspector>(totalFields);
  for (int i=0; i < keyFields.length; i++) {
    objectInspectors.add(null);
  }
  for (int i=0; i < aggregationClasses.length; i++) {
    objectInspectors.add(PrimitiveObjectInspectorFactory.getPrimitiveWritableObjectInspector(PrimitiveObjectInspectorUtils.getTypeEntryFromPrimitiveWritableClass(aggregationsEvaluateMethods[i].getReturnType()).primitiveCategory));
  }
  fieldNames=conf.getOutputColumnNames();
  for (int i=0; i < keyFields.length; i++) {
    if (keyObjectInspectors[i] == null) {
      keyObjectInspectors[i]=keyFields[i].initialize(inputObjInspector[0]);
      currentKeyObjectInspectors[i]=ObjectInspectorUtils.getStandardObjectInspector(keyObjectInspectors[i],ObjectInspectorCopyOption.WRITABLE);
    }
    objectInspectors.set(i,currentKeyObjectInspectors[i]);
  }
  ArrayList<String> keyNames=new ArrayList<String>(keyFields.length);
  for (int i=0; i < keyFields.length; i++) {
    keyNames.add(fieldNames.get(i));
  }
  newKeyObjectInspector=ObjectInspectorFactory.getStandardStructObjectInspector(keyNames,Arrays.asList(keyObjectInspectors));
  currentKeyObjectInspector=ObjectInspectorFactory.getStandardStructObjectInspector(keyNames,Arrays.asList(currentKeyObjectInspectors));
  outputObjectInspector=ObjectInspectorFactory.getStandardStructObjectInspector(fieldNames,objectInspectors);
  firstRow=true;
  if (conf.getMode() == groupByDesc.Mode.HASH)   computeMaxEntriesHashAggr(hconf);
  initializeChildren(hconf,reporter,new ObjectInspector[]{outputObjectInspector});
}
