{
  boolean isLocal=false;
  boolean isOverWrite=false;
  Tree fromTree=ast.getChild(0);
  Tree tableTree=ast.getChild(1);
  if (ast.getChildCount() == 4) {
    isLocal=true;
    isOverWrite=true;
  }
  if (ast.getChildCount() == 3) {
    if (ast.getChild(2).getText().toLowerCase().equals("local")) {
      isLocal=true;
    }
 else {
      isOverWrite=true;
    }
  }
  URI fromURI;
  try {
    String fromPath=stripQuotes(fromTree.getText());
    fromURI=initializeFromURI(fromPath,isLocal);
  }
 catch (  IOException e) {
    throw new SemanticException(ErrorMsg.INVALID_PATH.getMsg(fromTree,e.getMessage()),e);
  }
catch (  URISyntaxException e) {
    throw new SemanticException(ErrorMsg.INVALID_PATH.getMsg(fromTree,e.getMessage()),e);
  }
  TableSpec ts=new TableSpec(db,conf,(ASTNode)tableTree);
  if (ts.tableHandle.isOffline()) {
    throw new SemanticException(ErrorMsg.OFFLINE_TABLE_OR_PARTITION.getMsg(":Table " + ts.tableName));
  }
  if (ts.tableHandle.isView()) {
    throw new SemanticException(ErrorMsg.DML_AGAINST_VIEW.getMsg());
  }
  if (ts.tableHandle.isNonNative()) {
    throw new SemanticException(ErrorMsg.LOAD_INTO_NON_NATIVE.getMsg());
  }
  if (ts.tableHandle.isStoredAsSubDirectories()) {
    throw new SemanticException(ErrorMsg.LOAD_INTO_STORED_AS_DIR.getMsg());
  }
  URI toURI=((ts.partHandle != null) ? ts.partHandle.getDataLocation() : ts.tableHandle.getDataLocation()).toUri();
  List<FieldSchema> parts=ts.tableHandle.getPartitionKeys();
  if ((parts != null && parts.size() > 0) && (ts.partSpec == null || ts.partSpec.size() == 0)) {
    throw new SemanticException(ErrorMsg.NEED_PARTITION_ERROR.getMsg());
  }
  applyConstraints(fromURI,toURI,fromTree,isLocal);
  if (TableType.MANAGED_TABLE.equals(ts.tableHandle.getTableType())) {
    ensureFileFormatsMatch(ts,fromURI);
  }
  inputs.add(toReadEntity(new Path(fromURI)));
  Task<? extends Serializable> rTask=null;
  boolean preservePartitionSpecs=false;
  Map<String,String> partSpec=ts.getPartSpec();
  if (partSpec == null) {
    partSpec=new LinkedHashMap<String,String>();
    outputs.add(new WriteEntity(ts.tableHandle,(isOverWrite ? WriteEntity.WriteType.INSERT_OVERWRITE : WriteEntity.WriteType.INSERT)));
  }
 else {
    try {
      Partition part=Hive.get().getPartition(ts.tableHandle,partSpec,false);
      if (part != null) {
        if (part.isOffline()) {
          throw new SemanticException(ErrorMsg.OFFLINE_TABLE_OR_PARTITION.getMsg(ts.tableName + ":" + part.getName()));
        }
        if (isOverWrite) {
          outputs.add(new WriteEntity(part,WriteEntity.WriteType.INSERT_OVERWRITE));
        }
 else {
          outputs.add(new WriteEntity(part,WriteEntity.WriteType.INSERT));
          preservePartitionSpecs=true;
        }
      }
 else {
        outputs.add(new WriteEntity(ts.tableHandle,(isOverWrite ? WriteEntity.WriteType.INSERT_OVERWRITE : WriteEntity.WriteType.INSERT)));
      }
    }
 catch (    HiveException e) {
      throw new SemanticException(e);
    }
  }
  LoadTableDesc loadTableWork;
  loadTableWork=new LoadTableDesc(new Path(fromURI),Utilities.getTableDesc(ts.tableHandle),partSpec,isOverWrite);
  if (preservePartitionSpecs) {
    loadTableWork.setInheritTableSpecs(false);
  }
  Task<? extends Serializable> childTask=TaskFactory.get(new MoveWork(getInputs(),getOutputs(),loadTableWork,null,true,isLocal),conf);
  if (rTask != null) {
    rTask.addDependentTask(childTask);
  }
 else {
    rTask=childTask;
  }
  rootTasks.add(rTask);
  Task<? extends Serializable> statTask=null;
  if (conf.getBoolVar(HiveConf.ConfVars.HIVESTATSAUTOGATHER)) {
    StatsWork statDesc=new StatsWork(loadTableWork);
    statDesc.setNoStatsAggregator(true);
    statDesc.setClearAggregatorStats(true);
    statDesc.setStatsReliable(conf.getBoolVar(HiveConf.ConfVars.HIVE_STATS_RELIABLE));
    statTask=TaskFactory.get(statDesc,conf);
  }
  if (HiveConf.getBoolVar(conf,HiveConf.ConfVars.HIVEINDEXAUTOUPDATE)) {
    IndexUpdater indexUpdater=new IndexUpdater(loadTableWork,getInputs(),conf);
    try {
      List<Task<? extends Serializable>> indexUpdateTasks=indexUpdater.generateUpdateTasks();
      for (      Task<? extends Serializable> updateTask : indexUpdateTasks) {
        childTask.addDependentTask(updateTask);
        if (statTask != null) {
          updateTask.addDependentTask(statTask);
        }
      }
    }
 catch (    HiveException e) {
      console.printInfo("WARNING: could not auto-update stale indexes, indexes are not out of sync");
    }
  }
 else   if (statTask != null) {
    childTask.addDependentTask(statTask);
  }
}
