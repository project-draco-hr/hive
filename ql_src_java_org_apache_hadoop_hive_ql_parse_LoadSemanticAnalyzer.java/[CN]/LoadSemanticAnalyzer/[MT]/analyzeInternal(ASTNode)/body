{
  isLocal=false;
  isOverWrite=false;
  Tree fromTree=ast.getChild(0);
  Tree tableTree=ast.getChild(1);
  if (ast.getChildCount() == 4) {
    isLocal=true;
    isOverWrite=true;
  }
  if (ast.getChildCount() == 3) {
    if (ast.getChild(2).getText().toLowerCase().equals("local")) {
      isLocal=true;
    }
 else {
      isOverWrite=true;
    }
  }
  URI fromURI;
  try {
    String fromPath=stripQuotes(fromTree.getText());
    fromURI=initializeFromURI(fromPath);
  }
 catch (  IOException e) {
    throw new SemanticException(ErrorMsg.INVALID_PATH.getMsg(fromTree,e.getMessage()),e);
  }
catch (  URISyntaxException e) {
    throw new SemanticException(ErrorMsg.INVALID_PATH.getMsg(fromTree,e.getMessage()),e);
  }
  tableSpec ts=new tableSpec(db,conf,(ASTNode)tableTree);
  if (ts.tableHandle.isOffline()) {
    throw new SemanticException(ErrorMsg.OFFLINE_TABLE_OR_PARTITION.getMsg(":Table " + ts.tableName));
  }
  if (ts.tableHandle.isView()) {
    throw new SemanticException(ErrorMsg.DML_AGAINST_VIEW.getMsg());
  }
  if (ts.tableHandle.isNonNative()) {
    throw new SemanticException(ErrorMsg.LOAD_INTO_NON_NATIVE.getMsg());
  }
  URI toURI=(ts.partHandle != null) ? ts.partHandle.getDataLocation() : ts.tableHandle.getDataLocation();
  List<FieldSchema> parts=ts.tableHandle.getPartitionKeys();
  if ((parts != null && parts.size() > 0) && (ts.partSpec == null || ts.partSpec.size() == 0)) {
    throw new SemanticException(ErrorMsg.NEED_PARTITION_ERROR.getMsg());
  }
  applyConstraints(fromURI,toURI,fromTree,isLocal);
  Task<? extends Serializable> rTask=null;
  if (isLocal) {
    String copyURIStr=ctx.getExternalTmpFileURI(toURI);
    URI copyURI=URI.create(copyURIStr);
    rTask=TaskFactory.get(new CopyWork(fromURI.toString(),copyURIStr),conf);
    fromURI=copyURI;
  }
  String loadTmpPath=ctx.getExternalTmpFileURI(toURI);
  Map<String,String> partSpec=ts.getPartSpec();
  if (partSpec == null) {
    partSpec=new LinkedHashMap<String,String>();
    outputs.add(new WriteEntity(ts.tableHandle));
  }
 else {
    try {
      Partition part=Hive.get().getPartition(ts.tableHandle,partSpec,false);
      if (part != null) {
        if (part.isOffline()) {
          throw new SemanticException(ErrorMsg.OFFLINE_TABLE_OR_PARTITION.getMsg(ts.tableName + ":" + part.getName()));
        }
        outputs.add(new WriteEntity(part));
      }
 else {
        outputs.add(new WriteEntity(ts.tableHandle));
      }
    }
 catch (    HiveException e) {
      throw new SemanticException(e);
    }
  }
  LoadTableDesc loadTableWork=new LoadTableDesc(fromURI.toString(),loadTmpPath,Utilities.getTableDesc(ts.tableHandle),partSpec,isOverWrite);
  Task<? extends Serializable> childTask=TaskFactory.get(new MoveWork(getInputs(),getOutputs(),loadTableWork,null,true),conf);
  if (rTask != null) {
    rTask.addDependentTask(childTask);
  }
 else {
    rTask=childTask;
  }
  rootTasks.add(rTask);
  Task<? extends Serializable> statTask=null;
  if (conf.getBoolVar(HiveConf.ConfVars.HIVESTATSAUTOGATHER)) {
    StatsWork statDesc=new StatsWork(loadTableWork);
    statDesc.setNoStatsAggregator(true);
    statDesc.setClearAggregatorStats(true);
    statDesc.setStatsReliable(conf.getBoolVar(HiveConf.ConfVars.HIVE_STATS_RELIABLE));
    statTask=TaskFactory.get(statDesc,conf);
  }
  if (HiveConf.getBoolVar(conf,HiveConf.ConfVars.HIVEINDEXAUTOUPDATE)) {
    IndexUpdater indexUpdater=new IndexUpdater(loadTableWork,getInputs(),conf);
    try {
      List<Task<? extends Serializable>> indexUpdateTasks=indexUpdater.generateUpdateTasks();
      for (      Task<? extends Serializable> updateTask : indexUpdateTasks) {
        childTask.addDependentTask(updateTask);
        if (statTask != null) {
          updateTask.addDependentTask(statTask);
        }
      }
    }
 catch (    HiveException e) {
      console.printInfo("WARNING: could not auto-update stale indexes, indexes are not out of sync");
    }
  }
 else   if (statTask != null) {
    childTask.addDependentTask(statTask);
  }
}
