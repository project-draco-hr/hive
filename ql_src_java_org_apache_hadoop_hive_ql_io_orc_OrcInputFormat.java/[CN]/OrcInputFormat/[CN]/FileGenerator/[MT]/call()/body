{
  final SplitStrategy splitStrategy;
  AcidUtils.Directory dirInfo=AcidUtils.getAcidState(dir,context.conf,context.transactionList,useFileIds);
  List<Long> deltas=AcidUtils.serializeDeltas(dirInfo.getCurrentDirectories());
  Path base=dirInfo.getBaseDirectory();
  List<HdfsFileStatusWithId> original=dirInfo.getOriginalFiles();
  boolean[] covered=new boolean[context.numBuckets];
  boolean isOriginal=base == null;
  if (base != null || !original.isEmpty()) {
    List<HdfsFileStatusWithId> children=original;
    if (base != null) {
      children=findBaseFiles(base,useFileIds);
    }
    long totalFileSize=0;
    for (    HdfsFileStatusWithId child : children) {
      totalFileSize+=child.getFileStatus().getLen();
      AcidOutputFormat.Options opts=AcidUtils.parseBaseBucketFilename(child.getFileStatus().getPath(),context.conf);
      int b=opts.getBucket();
      if (b >= 0 && b < covered.length) {
        covered[b]=true;
      }
    }
    int numFiles=children.size();
    long avgFileSize=totalFileSize / numFiles;
switch (context.splitStrategyKind) {
case BI:
      splitStrategy=new BISplitStrategy(context,fs,dir,children,isOriginal,deltas,covered);
    break;
case ETL:
  splitStrategy=new ETLSplitStrategy(context,fs,dir,children,isOriginal,deltas,covered);
break;
default :
if (avgFileSize > context.maxSize || numFiles <= context.minSplits) {
splitStrategy=new ETLSplitStrategy(context,fs,dir,children,isOriginal,deltas,covered);
}
 else {
splitStrategy=new BISplitStrategy(context,fs,dir,children,isOriginal,deltas,covered);
}
break;
}
}
 else {
splitStrategy=new ACIDSplitStrategy(dir,context.numBuckets,deltas,covered);
}
return splitStrategy;
}
