{
  JoinCondDesc[] joinCondns;
  boolean semiJoin;
  boolean noOuterJoin;
  if (join instanceof HiveMultiJoin) {
    HiveMultiJoin hmj=(HiveMultiJoin)join;
    joinCondns=new JoinCondDesc[hmj.getJoinInputs().size()];
    for (int i=0; i < hmj.getJoinInputs().size(); i++) {
      joinCondns[i]=new JoinCondDesc(new JoinCond(hmj.getJoinInputs().get(i).left,hmj.getJoinInputs().get(i).right,transformJoinType(hmj.getJoinTypes().get(i))));
    }
    semiJoin=false;
    noOuterJoin=!hmj.isOuterJoin();
  }
 else {
    joinCondns=new JoinCondDesc[1];
    JoinType joinType=extractJoinType((HiveJoin)join);
    joinCondns[0]=new JoinCondDesc(new JoinCond(0,1,joinType));
    semiJoin=joinType == JoinType.LEFTSEMI;
    noOuterJoin=joinType != JoinType.FULLOUTER && joinType != JoinType.LEFTOUTER && joinType != JoinType.RIGHTOUTER;
  }
  ArrayList<ColumnInfo> outputColumns=new ArrayList<ColumnInfo>();
  ArrayList<String> outputColumnNames=new ArrayList<String>(join.getRowType().getFieldNames());
  Operator<?>[] childOps=new Operator[children.size()];
  Map<String,Byte> reversedExprs=new HashMap<String,Byte>();
  Map<Byte,List<ExprNodeDesc>> exprMap=new HashMap<Byte,List<ExprNodeDesc>>();
  Map<Byte,List<ExprNodeDesc>> filters=new HashMap<Byte,List<ExprNodeDesc>>();
  Map<String,ExprNodeDesc> colExprMap=new HashMap<String,ExprNodeDesc>();
  HashMap<Integer,Set<String>> posToAliasMap=new HashMap<Integer,Set<String>>();
  int outputPos=0;
  for (int pos=0; pos < children.size(); pos++) {
    ReduceSinkOperator inputRS=(ReduceSinkOperator)children.get(pos);
    if (inputRS.getNumParent() != 1) {
      throw new SemanticException("RS should have single parent");
    }
    Operator<?> parent=inputRS.getParentOperators().get(0);
    ReduceSinkDesc rsDesc=inputRS.getConf();
    int[] index=inputRS.getValueIndex();
    Byte tag=(byte)rsDesc.getTag();
    if (semiJoin && pos != 0) {
      exprMap.put(tag,new ArrayList<ExprNodeDesc>());
      childOps[pos]=inputRS;
      continue;
    }
    List<String> keyColNames=rsDesc.getOutputKeyColumnNames();
    List<String> valColNames=rsDesc.getOutputValueColumnNames();
    posToAliasMap.put(pos,new HashSet<String>(inputRS.getSchema().getTableNames()));
    Map<String,ExprNodeDesc> descriptors=buildBacktrackFromReduceSinkForJoin(outputPos,outputColumnNames,keyColNames,valColNames,index,parent,baseSrc[pos]);
    List<ColumnInfo> parentColumns=parent.getSchema().getSignature();
    for (int i=0; i < index.length; i++) {
      ColumnInfo info=new ColumnInfo(parentColumns.get(i));
      info.setInternalName(outputColumnNames.get(outputPos));
      info.setTabAlias(tabAlias);
      outputColumns.add(info);
      reversedExprs.put(outputColumnNames.get(outputPos),tag);
      outputPos++;
    }
    exprMap.put(tag,new ArrayList<ExprNodeDesc>(descriptors.values()));
    colExprMap.putAll(descriptors);
    childOps[pos]=inputRS;
  }
  List<List<ExprNodeDesc>> filtersPerInput=Lists.newArrayList();
  int[][] filterMap=new int[children.size()][];
  for (int i=0; i < children.size(); i++) {
    filtersPerInput.add(new ArrayList<ExprNodeDesc>());
  }
  for (int i=0; i < filterExpressions.size(); i++) {
    int leftPos=joinCondns[i].getLeft();
    int rightPos=joinCondns[i].getRight();
    for (    ExprNodeDesc expr : filterExpressions.get(i)) {
      int inputPos=updateExprNode(expr,reversedExprs,colExprMap);
      if (inputPos == -1) {
        inputPos=leftPos;
      }
      filtersPerInput.get(inputPos).add(expr);
      if (joinCondns[i].getType() == JoinDesc.FULL_OUTER_JOIN || joinCondns[i].getType() == JoinDesc.LEFT_OUTER_JOIN || joinCondns[i].getType() == JoinDesc.RIGHT_OUTER_JOIN) {
        if (inputPos == leftPos) {
          updateFilterMap(filterMap,leftPos,rightPos);
        }
 else {
          updateFilterMap(filterMap,rightPos,leftPos);
        }
      }
    }
  }
  for (int pos=0; pos < children.size(); pos++) {
    ReduceSinkOperator inputRS=(ReduceSinkOperator)children.get(pos);
    ReduceSinkDesc rsDesc=inputRS.getConf();
    Byte tag=(byte)rsDesc.getTag();
    filters.put(tag,filtersPerInput.get(pos));
  }
  JoinDesc desc=new JoinDesc(exprMap,outputColumnNames,noOuterJoin,joinCondns,filters,joinExpressions);
  desc.setReversedExprs(reversedExprs);
  desc.setFilterMap(filterMap);
  JoinOperator joinOp=(JoinOperator)OperatorFactory.getAndMakeChild(desc,new RowSchema(outputColumns),childOps);
  joinOp.setColumnExprMap(colExprMap);
  joinOp.setPosToAliasMap(posToAliasMap);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Generated " + joinOp + " with row schema: ["+ joinOp.getSchema()+ "]");
  }
  return joinOp;
}
