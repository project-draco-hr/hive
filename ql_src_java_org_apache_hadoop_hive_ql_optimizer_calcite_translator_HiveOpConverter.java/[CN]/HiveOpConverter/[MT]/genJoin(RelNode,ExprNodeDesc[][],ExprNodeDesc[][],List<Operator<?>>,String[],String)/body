{
  JoinCondDesc[] joinCondns;
  boolean semiJoin;
  boolean noOuterJoin;
  if (join instanceof HiveMultiJoin) {
    HiveMultiJoin hmj=(HiveMultiJoin)join;
    joinCondns=new JoinCondDesc[hmj.getJoinInputs().size()];
    for (int i=0; i < hmj.getJoinInputs().size(); i++) {
      joinCondns[i]=new JoinCondDesc(new JoinCond(hmj.getJoinInputs().get(i).left,hmj.getJoinInputs().get(i).right,transformJoinType(hmj.getJoinTypes().get(i))));
    }
    semiJoin=false;
    noOuterJoin=!hmj.isOuterJoin();
  }
 else {
    joinCondns=new JoinCondDesc[1];
    JoinType joinType=extractJoinType((HiveJoin)join);
    joinCondns[0]=new JoinCondDesc(new JoinCond(0,1,joinType));
    semiJoin=joinType == JoinType.LEFTSEMI;
    noOuterJoin=joinType != JoinType.FULLOUTER && joinType != JoinType.LEFTOUTER && joinType != JoinType.RIGHTOUTER;
  }
  ArrayList<ColumnInfo> outputColumns=new ArrayList<ColumnInfo>();
  ArrayList<String> outputColumnNames=new ArrayList<String>(join.getRowType().getFieldNames());
  Operator<?>[] childOps=new Operator[children.size()];
  Map<String,Byte> reversedExprs=new HashMap<String,Byte>();
  Map<Byte,List<ExprNodeDesc>> exprMap=new HashMap<Byte,List<ExprNodeDesc>>();
  Map<Byte,List<ExprNodeDesc>> filters=new HashMap<Byte,List<ExprNodeDesc>>();
  Map<String,ExprNodeDesc> colExprMap=new HashMap<String,ExprNodeDesc>();
  HashMap<Integer,Set<String>> posToAliasMap=new HashMap<Integer,Set<String>>();
  int outputPos=0;
  for (int pos=0; pos < children.size(); pos++) {
    ReduceSinkOperator inputRS=(ReduceSinkOperator)children.get(pos);
    if (inputRS.getNumParent() != 1) {
      throw new SemanticException("RS should have single parent");
    }
    Operator<?> parent=inputRS.getParentOperators().get(0);
    ReduceSinkDesc rsDesc=inputRS.getConf();
    int[] index=inputRS.getValueIndex();
    Byte tag=(byte)rsDesc.getTag();
    if (semiJoin && pos != 0) {
      exprMap.put(tag,new ArrayList<ExprNodeDesc>());
      childOps[pos]=inputRS;
      continue;
    }
    List<String> keyColNames=rsDesc.getOutputKeyColumnNames();
    List<String> valColNames=rsDesc.getOutputValueColumnNames();
    posToAliasMap.put(pos,new HashSet<String>(inputRS.getSchema().getTableNames()));
    Map<String,ExprNodeDesc> descriptors=buildBacktrackFromReduceSinkForJoin(outputPos,outputColumnNames,keyColNames,valColNames,index,parent,baseSrc[pos]);
    List<ColumnInfo> parentColumns=parent.getSchema().getSignature();
    for (int i=0; i < index.length; i++) {
      ColumnInfo info=new ColumnInfo(parentColumns.get(i));
      info.setInternalName(outputColumnNames.get(outputPos));
      info.setTabAlias(tabAlias);
      outputColumns.add(info);
      reversedExprs.put(outputColumnNames.get(outputPos),tag);
      outputPos++;
    }
    exprMap.put(tag,new ArrayList<ExprNodeDesc>(descriptors.values()));
    colExprMap.putAll(descriptors);
    childOps[pos]=inputRS;
    List<ExprNodeDesc> filtersForInput=new ArrayList<ExprNodeDesc>();
    for (    ExprNodeDesc expr : filterExpressions[pos]) {
      if (expr instanceof ExprNodeGenericFuncDesc) {
        ExprNodeGenericFuncDesc func=(ExprNodeGenericFuncDesc)expr;
        List<ExprNodeDesc> newChildren=new ArrayList<ExprNodeDesc>();
        for (        ExprNodeDesc functionChild : func.getChildren()) {
          if (functionChild instanceof ExprNodeColumnDesc) {
            newChildren.add(colExprMap.get(functionChild.getExprString()));
          }
 else {
            newChildren.add(functionChild);
          }
        }
        func.setChildren(newChildren);
        filtersForInput.add(expr);
      }
 else {
        filtersForInput.add(expr);
      }
    }
    filters.put(tag,filtersForInput);
  }
  JoinDesc desc=new JoinDesc(exprMap,outputColumnNames,noOuterJoin,joinCondns,filters,joinExpressions);
  desc.setReversedExprs(reversedExprs);
  int[][] filterMap=new int[joinExpressions.length][];
  desc.setFilterMap(filterMap);
  JoinOperator joinOp=(JoinOperator)OperatorFactory.getAndMakeChild(desc,new RowSchema(outputColumns),childOps);
  joinOp.setColumnExprMap(colExprMap);
  joinOp.setPosToAliasMap(posToAliasMap);
  if (LOG.isDebugEnabled()) {
    LOG.debug("Generated " + joinOp + " with row schema: ["+ joinOp.getSchema()+ "]");
  }
  return joinOp;
}
