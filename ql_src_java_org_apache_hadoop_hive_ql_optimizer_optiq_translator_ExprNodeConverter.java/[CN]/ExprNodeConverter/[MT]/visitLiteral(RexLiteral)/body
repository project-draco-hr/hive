{
  RelDataType lType=literal.getType();
switch (literal.getType().getSqlTypeName()) {
case BOOLEAN:
    return new ExprNodeConstantDesc(TypeInfoFactory.booleanTypeInfo,Boolean.valueOf(RexLiteral.booleanValue(literal)));
case TINYINT:
  return new ExprNodeConstantDesc(TypeInfoFactory.byteTypeInfo,Byte.valueOf(((Number)literal.getValue3()).byteValue()));
case SMALLINT:
return new ExprNodeConstantDesc(TypeInfoFactory.shortTypeInfo,Short.valueOf(((Number)literal.getValue3()).shortValue()));
case INTEGER:
return new ExprNodeConstantDesc(TypeInfoFactory.intTypeInfo,Integer.valueOf(((Number)literal.getValue3()).intValue()));
case BIGINT:
return new ExprNodeConstantDesc(TypeInfoFactory.longTypeInfo,Long.valueOf(((Number)literal.getValue3()).longValue()));
case FLOAT:
return new ExprNodeConstantDesc(TypeInfoFactory.floatTypeInfo,Float.valueOf(((Number)literal.getValue3()).floatValue()));
case DOUBLE:
return new ExprNodeConstantDesc(TypeInfoFactory.doubleTypeInfo,Double.valueOf(((Number)literal.getValue3()).doubleValue()));
case DATE:
return new ExprNodeConstantDesc(TypeInfoFactory.dateTypeInfo,literal.getValue3());
case TIMESTAMP:
return new ExprNodeConstantDesc(TypeInfoFactory.timestampTypeInfo,literal.getValue3());
case BINARY:
return new ExprNodeConstantDesc(TypeInfoFactory.binaryTypeInfo,literal.getValue3());
case DECIMAL:
return new ExprNodeConstantDesc(TypeInfoFactory.getDecimalTypeInfo(lType.getPrecision(),lType.getScale()),literal.getValue3());
case VARCHAR:
return new ExprNodeConstantDesc(TypeInfoFactory.getVarcharTypeInfo(lType.getPrecision()),new HiveVarchar((String)literal.getValue3(),lType.getPrecision()));
case CHAR:
return new ExprNodeConstantDesc(TypeInfoFactory.getCharTypeInfo(lType.getPrecision()),new HiveChar((String)literal.getValue3(),lType.getPrecision()));
case OTHER:
default :
return new ExprNodeConstantDesc(TypeInfoFactory.voidTypeInfo,literal.getValue3());
}
}
