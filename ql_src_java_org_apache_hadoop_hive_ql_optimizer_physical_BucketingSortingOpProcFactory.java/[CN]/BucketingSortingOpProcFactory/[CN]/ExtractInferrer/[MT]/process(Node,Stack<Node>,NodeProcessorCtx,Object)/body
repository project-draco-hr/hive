{
  BucketingSortingCtx bctx=(BucketingSortingCtx)procCtx;
  ExtractOperator exop=(ExtractOperator)nd;
  if (exop.getParentOperators().size() != 1) {
    return null;
  }
  Operator<? extends OperatorDesc> parent=exop.getParentOperators().get(0);
  assert(parent instanceof ReduceSinkOperator);
  ReduceSinkOperator rop=(ReduceSinkOperator)parent;
  List<BucketCol> bucketCols=new ArrayList<BucketCol>();
  for (int i=0; i < rop.getConf().getPartitionCols().size(); i++) {
    boolean valueColFound=false;
    for (int j=0; j < rop.getConf().getValueCols().size(); j++) {
      if (new ExprNodeDescEqualityWrapper(rop.getConf().getValueCols().get(j)).equals(new ExprNodeDescEqualityWrapper(rop.getConf().getPartitionCols().get(i)))) {
        bucketCols.add(new BucketCol(rop.getSchema().getSignature().get(j).getInternalName(),j));
        valueColFound=true;
        break;
      }
    }
    if (!valueColFound) {
      bucketCols.clear();
      break;
    }
  }
  String sortOrder=rop.getConf().getOrder();
  List<SortCol> sortCols=new ArrayList<SortCol>();
  for (int i=0; i < rop.getConf().getKeyCols().size(); i++) {
    boolean valueColFound=false;
    for (int j=0; j < rop.getConf().getValueCols().size(); j++) {
      if (new ExprNodeDescEqualityWrapper(rop.getConf().getValueCols().get(j)).equals(new ExprNodeDescEqualityWrapper(rop.getConf().getKeyCols().get(i)))) {
        sortCols.add(new SortCol(rop.getSchema().getSignature().get(j).getInternalName(),j,sortOrder.charAt(i)));
        valueColFound=true;
        break;
      }
    }
    if (!valueColFound) {
      break;
    }
  }
  List<ColumnInfo> colInfos=exop.getSchema().getSignature();
  if (!bucketCols.isEmpty()) {
    List<BucketCol> newBucketCols=getNewBucketCols(bucketCols,colInfos);
    bctx.setBucketedCols(exop,newBucketCols);
  }
  if (!sortCols.isEmpty()) {
    List<SortCol> newSortCols=getNewSortCols(sortCols,colInfos);
    bctx.setSortedCols(exop,newSortCols);
  }
  return null;
}
