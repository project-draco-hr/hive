{
  HiveMetaStoreClient client=null;
  try {
    Configuration conf=job.getConfiguration();
    client=createHiveClient(outputInfo.getServerUri(),conf);
    Table table=client.getTable(outputInfo.getDatabaseName(),outputInfo.getTableName());
    if (table.getPartitionKeysSize() == 0) {
      if ((outputInfo.getPartitionValues() != null) && (!outputInfo.getPartitionValues().isEmpty())) {
        throw new HCatException(ErrorType.ERROR_INVALID_PARTITION_VALUES,"Partition values specified for non-partitioned table");
      }
      outputInfo.setPartitionValues(new HashMap<String,String>());
    }
 else {
      Map<String,String> valueMap=new HashMap<String,String>();
      if (outputInfo.getPartitionValues() != null) {
        for (        Map.Entry<String,String> entry : outputInfo.getPartitionValues().entrySet()) {
          valueMap.put(entry.getKey().toLowerCase(),entry.getValue());
        }
      }
      if ((outputInfo.getPartitionValues() == null) || (outputInfo.getPartitionValues().size() < table.getPartitionKeysSize())) {
        List<String> dynamicPartitioningKeys=new ArrayList<String>();
        boolean firstItem=true;
        for (        FieldSchema fs : table.getPartitionKeys()) {
          if (!valueMap.containsKey(fs.getName().toLowerCase())) {
            dynamicPartitioningKeys.add(fs.getName().toLowerCase());
          }
        }
        if (valueMap.size() + dynamicPartitioningKeys.size() != table.getPartitionKeysSize()) {
          throw new HCatException(ErrorType.ERROR_INVALID_PARTITION_VALUES,"Invalid partition keys specified");
        }
        outputInfo.setDynamicPartitioningKeys(dynamicPartitioningKeys);
        String dynHash;
        if ((dynHash=conf.get(HCatConstants.HCAT_DYNAMIC_PTN_JOBID)) == null) {
          dynHash=String.valueOf(Math.random());
        }
        conf.set(HCatConstants.HCAT_DYNAMIC_PTN_JOBID,dynHash);
      }
      outputInfo.setPartitionValues(valueMap);
    }
    handleDuplicatePublish(job,outputInfo,client,table);
    StorageDescriptor tblSD=table.getSd();
    HCatSchema tableSchema=HCatUtil.extractSchemaFromStorageDescriptor(tblSD);
    StorerInfo storerInfo=InitializeInput.extractStorerInfo(tblSD,table.getParameters());
    List<String> partitionCols=new ArrayList<String>();
    for (    FieldSchema schema : table.getPartitionKeys()) {
      partitionCols.add(schema.getName());
    }
    Class<? extends HCatOutputStorageDriver> driverClass=(Class<? extends HCatOutputStorageDriver>)Class.forName(storerInfo.getOutputSDClass());
    HCatOutputStorageDriver driver=driverClass.newInstance();
    String tblLocation=tblSD.getLocation();
    String location=driver.getOutputLocation(job,tblLocation,partitionCols,outputInfo.getPartitionValues(),conf.get(HCatConstants.HCAT_DYNAMIC_PTN_JOBID));
    OutputJobInfo jobInfo=new OutputJobInfo(outputInfo,tableSchema,tableSchema,storerInfo,location,table);
    jobInfo.setHarRequested(harRequested);
    jobInfo.setMaximumDynamicPartitions(maxDynamicPartitions);
    conf.set(HCatConstants.HCAT_KEY_OUTPUT_INFO,HCatUtil.serialize(jobInfo));
    Path tblPath=new Path(tblLocation);
    FsPermission.setUMask(conf,FsPermission.getDefault().applyUMask(tblPath.getFileSystem(conf).getFileStatus(tblPath).getPermission()));
    if (UserGroupInformation.isSecurityEnabled()) {
      UserGroupInformation ugi=UserGroupInformation.getCurrentUser();
      TokenSelector<? extends TokenIdentifier> tokenSelector=new DelegationTokenSelector();
      Token<? extends TokenIdentifier> token=tokenSelector.selectToken(new Text(),ugi.getTokens());
      if (token != null) {
        job.getCredentials().addToken(new Text(ugi.getUserName()),token);
      }
 else {
        String tokenSignature=getTokenSignature(outputInfo);
        if (tokenMap.get(tokenSignature) == null) {
          tokenMap.put(tokenSignature,HCatUtil.extractThriftToken(client.getDelegationToken(ugi.getUserName()),tokenSignature));
        }
        String jcTokenSignature="jc." + tokenSignature;
        if (tokenMap.get(jcTokenSignature) == null) {
          tokenMap.put(jcTokenSignature,HCatUtil.getJobTrackerDelegationToken(conf,ugi.getUserName()));
        }
        job.getCredentials().addToken(new Text(ugi.getUserName() + tokenSignature),tokenMap.get(tokenSignature));
        job.getCredentials().addToken(new Text(ugi.getUserName() + jcTokenSignature),tokenMap.get(jcTokenSignature));
        job.getConfiguration().set(HCatConstants.HCAT_KEY_TOKEN_SIGNATURE,tokenSignature);
        job.getConfiguration().set(HCatConstants.HCAT_KEY_JOBCLIENT_TOKEN_SIGNATURE,jcTokenSignature);
        job.getConfiguration().set(HCatConstants.HCAT_KEY_JOBCLIENT_TOKEN_STRFORM,tokenMap.get(jcTokenSignature).encodeToUrlString());
      }
    }
  }
 catch (  Exception e) {
    if (e instanceof HCatException) {
      throw (HCatException)e;
    }
 else {
      throw new HCatException(ErrorType.ERROR_SET_OUTPUT,e);
    }
  }
 finally {
    if (client != null) {
      client.close();
    }
  }
}
