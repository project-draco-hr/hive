{
  int partitionColumnCount=table.getPartitionKeys().size();
  int partitionColumnIndex;
  for (partitionColumnIndex=0; partitionColumnIndex < partitionColumnCount; partitionColumnIndex++) {
    if (table.getPartitionKeys().get(partitionColumnIndex).getName().equalsIgnoreCase(keyName)) {
      break;
    }
  }
  assert(table.getPartitionKeys().size() > 0);
  if (partitionColumnIndex == table.getPartitionKeys().size()) {
    throw new MetaException("Specified key <" + keyName + "> is not a partitioning key for the table");
  }
  if (!table.getPartitionKeys().get(partitionColumnIndex).getType().equals(Constants.STRING_TYPE_NAME)) {
    throw new MetaException("Filtering is supported only on partition keys of type string");
  }
  String paramName=PARAM_PREFIX + params.size();
  params.put(paramName,value);
  String filter;
  if (isReverseOrder) {
    if (operator == Operator.LIKE) {
      throw new MetaException("Value should be on the RHS for LIKE operator : " + "Key <" + keyName + ">");
    }
 else     if (operator == Operator.EQUALS) {
      filter=makeFilterForEquals(keyName,value,paramName,params,partitionColumnIndex,partitionColumnCount);
    }
 else {
      filter=paramName + " " + operator.getJdoOp()+ " "+ " this.values.get("+ partitionColumnIndex+ ")";
    }
  }
 else {
    if (operator == Operator.LIKE) {
      filter=" this.values.get(" + partitionColumnIndex + ")."+ operator.getJdoOp()+ "("+ paramName+ ") ";
    }
 else     if (operator == Operator.EQUALS) {
      filter=makeFilterForEquals(keyName,value,paramName,params,partitionColumnIndex,partitionColumnCount);
    }
 else {
      filter=" this.values.get(" + partitionColumnIndex + ") "+ operator.getJdoOp()+ " "+ paramName;
    }
  }
  return filter;
}
