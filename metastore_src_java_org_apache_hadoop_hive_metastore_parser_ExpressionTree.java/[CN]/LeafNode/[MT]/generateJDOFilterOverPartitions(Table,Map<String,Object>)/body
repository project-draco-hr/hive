{
  int partitionColumnCount=table.getPartitionKeys().size();
  int partitionColumnIndex;
  for (partitionColumnIndex=0; partitionColumnIndex < partitionColumnCount; partitionColumnIndex++) {
    if (table.getPartitionKeys().get(partitionColumnIndex).getName().equalsIgnoreCase(keyName)) {
      break;
    }
  }
  assert(table.getPartitionKeys().size() > 0);
  if (partitionColumnIndex == table.getPartitionKeys().size()) {
    throw new MetaException("Specified key <" + keyName + "> is not a partitioning key for the table");
  }
  String keyType=table.getPartitionKeys().get(partitionColumnIndex).getType();
  boolean isIntegralSupported=doesOperatorSupportIntegral(operator);
  if (!keyType.equals(org.apache.hadoop.hive.serde.serdeConstants.STRING_TYPE_NAME) && (!isIntegralSupported || !isIntegralType(keyType))) {
    throw new MetaException("Filtering is supported only on partition keys of type " + "string" + (isIntegralSupported ? ", or integral types" : ""));
  }
  boolean isStringValue=value instanceof String;
  if (!isStringValue && (!isIntegralSupported || !(value instanceof Long))) {
    throw new MetaException("Filtering is supported only on partition keys of type " + "string" + (isIntegralSupported ? ", or integral types" : ""));
  }
  String valueAsString=null;
  try {
    valueAsString=isStringValue ? (String)value : Long.toString((Long)value);
  }
 catch (  ClassCastException e) {
    throw new MetaException("Unable to cast the constexpr to " + (isStringValue ? "string" : "long"));
  }
  String paramName=PARAM_PREFIX + params.size();
  params.put(paramName,valueAsString);
  boolean isOpEquals=operator == Operator.EQUALS;
  if (isOpEquals || operator == Operator.NOTEQUALS || operator == Operator.NOTEQUALS2) {
    return makeFilterForEquals(keyName,valueAsString,paramName,params,partitionColumnIndex,partitionColumnCount,isOpEquals);
  }
  String keyEqual=FileUtils.escapePathName(keyName) + "=";
  int keyEqualLength=keyEqual.length();
  String valString;
  if (partitionColumnIndex == (partitionColumnCount - 1)) {
    valString="partitionName.substring(partitionName.indexOf(\"" + keyEqual + "\")+"+ keyEqualLength+ ")";
  }
 else {
    valString="partitionName.substring(partitionName.indexOf(\"" + keyEqual + "\")+"+ keyEqualLength+ ").substring(0, partitionName.substring(partitionName.indexOf(\""+ keyEqual+ "\")+"+ keyEqualLength+ ").indexOf(\"/\"))";
  }
  if (operator == Operator.LIKE) {
    if (isReverseOrder) {
      throw new MetaException("Value should be on the RHS for LIKE operator : Key <" + keyName + ">");
    }
    return " " + valString + "."+ operator.getJdoOp()+ "("+ paramName+ ") ";
  }
  return isReverseOrder ? paramName + " " + operator.getJdoOp()+ " "+ valString : " " + valString + " "+ operator.getJdoOp()+ " "+ paramName;
}
