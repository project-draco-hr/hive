{
  if (argTypeInfos.size() != 3) {
    return null;
  }
  List<TypeInfo> pClasses=new ArrayList<TypeInfo>(3);
  pClasses.add(TypeInfoFactory.booleanTypeInfo);
  for (int i=0; i < classPriority.length; i++) {
    if (argTypeInfos.get(1).equals(classPriority[i]) || argTypeInfos.get(2).equals(classPriority[i])) {
      pClasses.add(classPriority[i]);
      pClasses.add(classPriority[i]);
      break;
    }
  }
  if (pClasses.size() != 3) {
    return null;
  }
  Method udfMethod=null;
  for (  Method m : Arrays.asList(udfClass.getMethods())) {
    if (m.getName().equals("evaluate")) {
      List<TypeInfo> acceptedTypeInfos=TypeInfoUtils.getParameterTypeInfos(m);
      boolean match=(acceptedTypeInfos.size() == pClasses.size());
      for (int i=0; i < pClasses.size() && match; i++) {
        TypeInfo accepted=acceptedTypeInfos.get(i);
        if (!accepted.equals(pClasses.get(i))) {
          match=false;
        }
      }
      if (match) {
        if (udfMethod != null) {
          throw new AmbiguousMethodException(udfClass,argTypeInfos);
        }
 else {
          udfMethod=m;
        }
      }
    }
  }
  return udfMethod;
}
