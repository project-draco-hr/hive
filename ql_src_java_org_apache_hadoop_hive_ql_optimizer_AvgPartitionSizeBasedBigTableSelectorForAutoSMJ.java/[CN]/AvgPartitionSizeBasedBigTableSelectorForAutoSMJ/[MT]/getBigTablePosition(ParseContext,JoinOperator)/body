{
  int bigTablePos=0;
  long maxSize=-1;
  int numPartitionsCurrentBigTable=0;
  HiveConf conf=parseCtx.getConf();
  try {
    List<TableScanOperator> topOps=new ArrayList<TableScanOperator>();
    getListTopOps(joinOp,topOps);
    int currentPos=0;
    for (    TableScanOperator topOp : topOps) {
      if (topOp == null) {
        return -1;
      }
      int numPartitions=1;
      Table table=parseCtx.getTopToTable().get(topOp);
      long averageSize=0;
      if (!table.isPartitioned()) {
        averageSize=getSize(conf,table);
      }
 else {
        PrunedPartitionList partsList=PartitionPruner.prune(parseCtx.getTopToTable().get(topOp),parseCtx.getOpToPartPruner().get(topOp),parseCtx.getConf(),null,parseCtx.getPrunedPartitions());
        numPartitions=partsList.getNotDeniedPartns().size();
        long totalSize=0;
        for (        Partition part : partsList.getNotDeniedPartns()) {
          totalSize+=getSize(conf,part);
        }
        averageSize=numPartitions == 0 ? 0 : totalSize / numPartitions;
      }
      if (averageSize > maxSize) {
        maxSize=averageSize;
        bigTablePos=currentPos;
        numPartitionsCurrentBigTable=numPartitions;
      }
 else       if (averageSize == maxSize) {
        if (numPartitions < numPartitionsCurrentBigTable) {
          bigTablePos=currentPos;
          numPartitionsCurrentBigTable=numPartitions;
        }
      }
      currentPos++;
    }
  }
 catch (  HiveException e) {
    throw new SemanticException(e.getMessage());
  }
  return bigTablePos;
}
