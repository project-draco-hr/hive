{
  BinarySortableSerializeWrite binarySortableSerializeWrite=new BinarySortableSerializeWrite(columnSortOrderIsDesc,columnNullMarker,columnNotNullMarker);
  BytesWritable serializeWriteBytes[]=new BytesWritable[myTestPrimitiveClasses.length];
  int[][] perFieldWriteLengthsArray=new int[myTestPrimitiveClasses.length][];
  for (int i=0; i < myTestPrimitiveClasses.length; i++) {
    MyTestPrimitiveClass t=myTestPrimitiveClasses[i];
    Output output=new Output();
    binarySortableSerializeWrite.set(output);
    int[] perFieldWriteLengths=new int[MyTestPrimitiveClass.primitiveCount];
    for (int index=0; index < MyTestPrimitiveClass.primitiveCount; index++) {
      Object object=t.getPrimitiveObject(index);
      VerifyFast.serializeWrite(binarySortableSerializeWrite,primitiveTypeInfoMap.get(t)[index],object);
      perFieldWriteLengths[index]=output.getLength();
    }
    perFieldWriteLengthsArray[i]=perFieldWriteLengths;
    BytesWritable bytesWritable=new BytesWritable();
    bytesWritable.set(output.getData(),0,output.getLength());
    serializeWriteBytes[i]=bytesWritable;
    if (i > 0) {
      int compareResult=serializeWriteBytes[i - 1].compareTo(serializeWriteBytes[i]);
      if ((compareResult < 0 && !ascending) || (compareResult > 0 && ascending)) {
        System.out.println("Test failed in " + (ascending ? "ascending" : "descending") + " order with "+ (i - 1)+ " and "+ i);
        System.out.println("serialized data [" + (i - 1) + "] = "+ TestBinarySortableSerDe.hexString(serializeWriteBytes[i - 1]));
        System.out.println("serialized data [" + i + "] = "+ TestBinarySortableSerDe.hexString(serializeWriteBytes[i]));
        fail("Sort order of serialized " + (i - 1) + " and "+ i+ " are reversed!");
      }
    }
  }
  for (int i=0; i < myTestPrimitiveClasses.length; i++) {
    MyTestPrimitiveClass t=myTestPrimitiveClasses[i];
    PrimitiveTypeInfo[] primitiveTypeInfos=primitiveTypeInfoMap.get(t);
    BinarySortableDeserializeRead binarySortableDeserializeRead=new BinarySortableDeserializeRead(primitiveTypeInfos,columnSortOrderIsDesc);
    BytesWritable bytesWritable=serializeWriteBytes[i];
    binarySortableDeserializeRead.set(bytesWritable.getBytes(),0,bytesWritable.getLength());
    for (int index=0; index < MyTestPrimitiveClass.primitiveCount; index++) {
      Object object=t.getPrimitiveObject(index);
      VerifyFast.verifyDeserializeRead(binarySortableDeserializeRead,primitiveTypeInfos[index],object);
    }
    binarySortableDeserializeRead.extraFieldsCheck();
    TestCase.assertTrue(!binarySortableDeserializeRead.readBeyondConfiguredFieldsWarned());
    TestCase.assertTrue(!binarySortableDeserializeRead.readBeyondBufferRangeWarned());
    TestCase.assertTrue(!binarySortableDeserializeRead.bufferRangeHasExtraDataWarned());
  }
  for (int i=0; i < myTestPrimitiveClasses.length; i++) {
    BytesWritable bytesWritable=serializeWriteBytes[i];
    List<Object> deserializedRow=(List<Object>)serde.deserialize(bytesWritable);
    MyTestPrimitiveClass t=myTestPrimitiveClasses[i];
    PrimitiveTypeInfo[] primitiveTypeInfos=primitiveTypeInfoMap.get(t);
    for (int index=0; index < MyTestPrimitiveClass.primitiveCount; index++) {
      Object expected=t.getPrimitiveWritableObject(index,primitiveTypeInfos[index]);
      Object object=deserializedRow.get(index);
      if (expected == null || object == null) {
        if (expected != null || object != null) {
          fail("SerDe deserialized NULL column mismatch");
        }
      }
 else {
        if (!object.equals(expected)) {
          fail("SerDe deserialized value does not match");
        }
      }
    }
  }
  BytesWritable serdeBytes[]=new BytesWritable[myTestPrimitiveClasses.length];
  for (int i=0; i < myTestPrimitiveClasses.length; i++) {
    MyTestPrimitiveClass t=myTestPrimitiveClasses[i];
    BytesWritable serialized=(BytesWritable)serde.serialize(t,rowOI);
    BytesWritable bytesWritable=new BytesWritable();
    bytesWritable.set(serialized);
    byte[] serDeOutput=Arrays.copyOfRange(bytesWritable.getBytes(),0,bytesWritable.getLength());
    byte[] serializeWriteExpected=Arrays.copyOfRange(serializeWriteBytes[i].getBytes(),0,serializeWriteBytes[i].getLength());
    if (!Arrays.equals(serDeOutput,serializeWriteExpected)) {
      int mismatchPos=-1;
      if (serDeOutput.length != serializeWriteExpected.length) {
        for (int b=0; b < Math.min(serDeOutput.length,serializeWriteExpected.length); b++) {
          if (serDeOutput[b] != serializeWriteExpected[b]) {
            mismatchPos=b;
            break;
          }
        }
        fail("Different byte array lengths: serDeOutput.length " + serDeOutput.length + ", serializeWriteExpected.length "+ serializeWriteExpected.length+ " mismatchPos "+ mismatchPos+ " perFieldWriteLengths "+ Arrays.toString(perFieldWriteLengthsArray[i]));
      }
      for (int b=0; b < serDeOutput.length; b++) {
        if (serDeOutput[b] != serializeWriteExpected[b]) {
          fail("SerializeWrite and SerDe serialization does not match at position " + b);
        }
      }
    }
    serdeBytes[i]=bytesWritable;
  }
  for (int i=0; i < myTestPrimitiveClasses.length; i++) {
    MyTestPrimitiveClass t=myTestPrimitiveClasses[i];
    PrimitiveTypeInfo[] primitiveTypeInfos=primitiveTypeInfoMap.get(t);
    BinarySortableDeserializeRead binarySortableDeserializeRead=new BinarySortableDeserializeRead(primitiveTypeInfos,columnSortOrderIsDesc);
    BytesWritable bytesWritable=serdeBytes[i];
    binarySortableDeserializeRead.set(bytesWritable.getBytes(),0,bytesWritable.getLength());
    for (int index=0; index < MyTestPrimitiveClass.primitiveCount; index++) {
      Object object=t.getPrimitiveObject(index);
      VerifyFast.verifyDeserializeRead(binarySortableDeserializeRead,primitiveTypeInfos[index],object);
    }
    binarySortableDeserializeRead.extraFieldsCheck();
    TestCase.assertTrue(!binarySortableDeserializeRead.readBeyondConfiguredFieldsWarned());
    TestCase.assertTrue(!binarySortableDeserializeRead.readBeyondBufferRangeWarned());
    TestCase.assertTrue(!binarySortableDeserializeRead.bufferRangeHasExtraDataWarned());
  }
}
