{
  try {
    data=preallocate(arenaSize);
  }
 catch (  OutOfMemoryError oom) {
    throw new OutOfMemoryError("Cannot allocate " + arenaSize + " bytes: "+ oom.getMessage()+ "; make sure your xmx and process size are set correctly.");
  }
  int maxMinAllocs=1 << (arenaSizeLog2 - minAllocLog2);
  headers=new byte[maxMinAllocs];
  int allocLog2Diff=maxAllocLog2 - minAllocLog2, freeListCount=allocLog2Diff + 1;
  freeLists=new FreeList[freeListCount];
  for (int i=0; i < freeListCount; ++i) {
    freeLists[i]=new FreeList();
  }
  int maxMaxAllocs=1 << (arenaSizeLog2 - maxAllocLog2), headerIndex=0, headerStep=1 << allocLog2Diff;
  freeLists[allocLog2Diff].listHead=0;
  for (int i=0, offset=0; i < maxMaxAllocs; ++i, offset+=maxAllocation) {
    headers[headerIndex]=makeHeader(allocLog2Diff,false);
    data.putInt(offset,(i == 0) ? -1 : (headerIndex - headerStep));
    data.putInt(offset + 4,(i == maxMaxAllocs - 1) ? -1 : (headerIndex + headerStep));
    headerIndex+=headerStep;
  }
}
