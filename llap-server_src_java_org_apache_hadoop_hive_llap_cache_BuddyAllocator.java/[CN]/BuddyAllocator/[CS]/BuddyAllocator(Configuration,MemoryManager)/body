{
  isDirect=HiveConf.getBoolVar(conf,ConfVars.LLAP_ORC_CACHE_ALLOCATE_DIRECT);
  minAllocation=HiveConf.getIntVar(conf,ConfVars.LLAP_ORC_CACHE_MIN_ALLOC);
  maxAllocation=HiveConf.getIntVar(conf,ConfVars.LLAP_ORC_CACHE_MAX_ALLOC);
  arenaSize=HiveConf.getIntVar(conf,ConfVars.LLAP_ORC_CACHE_ARENA_SIZE);
  maxSize=HiveConf.getLongVar(conf,ConfVars.LLAP_ORC_CACHE_MAX_SIZE);
  if (minAllocation < 8) {
    throw new AssertionError("Min allocation must be at least 8: " + minAllocation);
  }
  if (maxSize < arenaSize || arenaSize < maxAllocation || maxAllocation < minAllocation) {
    throw new AssertionError("Inconsistent sizes of cache, arena and allocations: " + minAllocation + ", "+ maxAllocation+ ", "+ arenaSize+ ", "+ maxSize);
  }
  if ((Integer.bitCount(minAllocation) != 1) || (Integer.bitCount(maxAllocation) != 1) || (Long.bitCount(arenaSize) != 1)) {
    throw new AssertionError("Allocation and arena sizes must be powers of two: " + minAllocation + ", "+ maxAllocation+ ", "+ arenaSize);
  }
  if ((maxSize % arenaSize) > 0 || (maxSize / arenaSize) > Integer.MAX_VALUE) {
    throw new AssertionError("Cache size not consistent with arena size: " + arenaSize + ","+ maxSize);
  }
  minAllocLog2=31 - Integer.numberOfLeadingZeros(minAllocation);
  maxAllocLog2=31 - Integer.numberOfLeadingZeros(maxAllocation);
  arenaSizeLog2=63 - Long.numberOfLeadingZeros(arenaSize);
  maxArenas=(int)(maxSize / arenaSize);
  arenas=new Arena[maxArenas];
  for (int i=0; i < maxArenas; ++i) {
    arenas[i]=new Arena();
  }
  arenas[0].init();
  allocatedArenas.set(1);
  this.memoryManager=memoryManager;
}
