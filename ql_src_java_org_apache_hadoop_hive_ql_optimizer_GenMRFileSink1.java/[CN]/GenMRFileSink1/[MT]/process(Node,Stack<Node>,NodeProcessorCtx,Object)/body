{
  GenMRProcContext ctx=(GenMRProcContext)opProcCtx;
  ParseContext parseCtx=ctx.getParseCtx();
  boolean chDir=false;
  Task<? extends Serializable> currTask=ctx.getCurrTask();
  ctx.addRootIfPossible(currTask);
  FileSinkOperator fsOp=(FileSinkOperator)nd;
  boolean isInsertTable=GenMapRedUtils.isInsertInto(parseCtx,fsOp);
  HiveConf hconf=parseCtx.getConf();
  ((MapredWork)currTask.getWork()).setFinalMapRed(true);
  Map<FileSinkDesc,Task<? extends Serializable>> fileSinkDescs=ctx.getLinkedFileDescTasks();
  if (fileSinkDescs != null) {
    Task<? extends Serializable> childTask=fileSinkDescs.get(fsOp.getConf());
    processLinkedFileDesc(ctx,childTask);
    return true;
  }
  if ((ctx.getSeenFileSinkOps() == null) || (!ctx.getSeenFileSinkOps().contains(nd))) {
    chDir=GenMapRedUtils.isMergeRequired(ctx.getMvTask(),hconf,fsOp,currTask,isInsertTable);
  }
  Path finalName=processFS(fsOp,stack,opProcCtx,chDir);
  if (chDir) {
    LOG.info("using CombineHiveInputformat for the merge job");
    GenMapRedUtils.createMRWorkForMergingFiles(fsOp,finalName,ctx.getDependencyTaskForMultiInsert(),ctx.getMvTask(),hconf,currTask);
  }
  FileSinkDesc fileSinkDesc=fsOp.getConf();
  if (fileSinkDesc.isLinkedFileSink()) {
    Map<FileSinkDesc,Task<? extends Serializable>> linkedFileDescTasks=ctx.getLinkedFileDescTasks();
    if (linkedFileDescTasks == null) {
      linkedFileDescTasks=new HashMap<FileSinkDesc,Task<? extends Serializable>>();
      ctx.setLinkedFileDescTasks(linkedFileDescTasks);
    }
    if ((currTask.getChildTasks() != null) && (currTask.getChildTasks().size() == 1)) {
      for (      FileSinkDesc fileDesc : fileSinkDesc.getLinkedFileSinkDesc()) {
        linkedFileDescTasks.put(fileDesc,currTask.getChildTasks().get(0));
      }
    }
  }
  return true;
}
