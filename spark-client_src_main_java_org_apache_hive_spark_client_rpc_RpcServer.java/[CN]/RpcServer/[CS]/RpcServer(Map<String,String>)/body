{
  this.config=new RpcConfiguration(config);
  this.group=new NioEventLoopGroup(this.config.getRpcThreadCount(),new ThreadFactoryBuilder().setNameFormat("RPC-Handler-%d").setDaemon(true).build());
  this.channel=new ServerBootstrap().group(group).channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer<SocketChannel>(){
    @Override public void initChannel(    SocketChannel ch) throws Exception {
      HelloDispatcher dispatcher=new HelloDispatcher();
      final Rpc newRpc=Rpc.createRpc(RpcServer.this.config,ch,dispatcher,group);
      dispatcher.rpc=newRpc;
      Runnable cancelTask=new Runnable(){
        @Override public void run(){
          LOG.warn("Timed out waiting for hello from client.");
          newRpc.close();
        }
      }
;
      dispatcher.cancelTask=group.schedule(cancelTask,RpcServer.this.config.getServerConnectTimeoutMs(),TimeUnit.MILLISECONDS);
    }
  }
).option(ChannelOption.SO_BACKLOG,1).option(ChannelOption.SO_REUSEADDR,true).childOption(ChannelOption.SO_KEEPALIVE,true).bind(0).sync().channel();
  this.port=((InetSocketAddress)channel.localAddress()).getPort();
  this.pendingClients=new ConcurrentLinkedQueue<ClientInfo>();
  this.address=this.config.getServerAddress();
}
