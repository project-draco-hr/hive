{
  String indexFileStr=job.get(indexFile);
  l4j.info("index_file is " + indexFileStr);
  HiveIndexResult hiveIndexResult=null;
  if (indexFileStr != null) {
    try {
      hiveIndexResult=new HiveIndexResult(indexFileStr,job);
    }
 catch (    HiveException e) {
      l4j.error("Unable to read index..");
      throw new IOException(e);
    }
    Set<String> inputFiles=hiveIndexResult.buckets.keySet();
    Iterator<String> iter=inputFiles.iterator();
    boolean first=true;
    StringBuilder newInputPaths=new StringBuilder();
    while (iter.hasNext()) {
      String path=iter.next();
      if (path.trim().equalsIgnoreCase("")) {
        continue;
      }
      if (!first) {
        newInputPaths.append(",");
      }
 else {
        first=false;
      }
      newInputPaths.append(path);
    }
    FileInputFormat.setInputPaths(job,newInputPaths.toString());
  }
 else {
    return super.getSplits(job,numSplits);
  }
  HiveInputSplit[] splits=(HiveInputSplit[])this.doGetSplits(job,numSplits);
  ArrayList<HiveInputSplit> newSplits=new ArrayList<HiveInputSplit>(numSplits);
  for (  HiveInputSplit split : splits) {
    l4j.info("split start : " + split.getStart());
    l4j.info("split end : " + (split.getStart() + split.getLength()));
    try {
      if (hiveIndexResult.contains(split)) {
        HiveInputSplit newSplit=split;
        if (split.inputFormatClassName().contains("RCFile") || split.inputFormatClassName().contains("SequenceFile")) {
          if (split.getStart() > SequenceFile.SYNC_INTERVAL) {
            newSplit=new HiveInputSplit(new FileSplit(split.getPath(),split.getStart() - SequenceFile.SYNC_INTERVAL,split.getLength() + SequenceFile.SYNC_INTERVAL,split.getLocations()),split.inputFormatClassName());
          }
        }
        newSplits.add(newSplit);
      }
    }
 catch (    HiveException e) {
      throw new RuntimeException("Unable to get metadata for input table split" + split.getPath());
    }
  }
  InputSplit retA[]=newSplits.toArray((new FileSplit[newSplits.size()]));
  l4j.info("Number of input splits: " + splits.length + " new input splits: "+ retA.length);
  return retA;
}
