{
  LOG.debug("Starting deadlock test");
  if (txnHandler instanceof TxnHandler) {
    final TxnHandler tHndlr=(TxnHandler)txnHandler;
    Connection conn=tHndlr.getDbConn(Connection.TRANSACTION_SERIALIZABLE);
    Statement stmt=conn.createStatement();
    long now=tHndlr.getDbTime(conn);
    stmt.executeUpdate("insert into TXNS (txn_id, txn_state, txn_started, txn_last_heartbeat, " + "txn_user, txn_host) values (1, 'o', " + now + ", "+ now+ ", 'shagy', "+ "'scooby.com')");
    stmt.executeUpdate("insert into HIVE_LOCKS (hl_lock_ext_id, hl_lock_int_id, hl_txnid, " + "hl_db, hl_table, hl_partition, hl_lock_state, hl_lock_type, hl_last_heartbeat, " + "hl_user, hl_host) values (1, 1, 1, 'mydb', 'mytable', 'mypartition', '" + tHndlr.LOCK_WAITING + "', '"+ tHndlr.LOCK_EXCLUSIVE+ "', "+ now+ ", 'fred', "+ "'scooby.com')");
    conn.commit();
    tHndlr.closeDbConn(conn);
    final AtomicBoolean sawDeadlock=new AtomicBoolean();
    final Connection conn1=tHndlr.getDbConn(Connection.TRANSACTION_SERIALIZABLE);
    final Connection conn2=tHndlr.getDbConn(Connection.TRANSACTION_SERIALIZABLE);
    try {
      for (int i=0; i < 5; i++) {
        Thread t1=new Thread(){
          @Override public void run(){
            try {
              try {
                updateTxns(conn1);
                updateLocks(conn1);
                Thread.sleep(1000);
                conn1.commit();
                LOG.debug("no exception, no deadlock");
              }
 catch (              SQLException e) {
                try {
                  tHndlr.checkRetryable(conn1,e,"thread t1");
                  LOG.debug("Got an exception, but not a deadlock, SQLState is " + e.getSQLState() + " class of exception is "+ e.getClass().getName()+ " msg is <"+ e.getMessage()+ ">");
                }
 catch (                TxnHandler.RetryException de) {
                  LOG.debug("Forced a deadlock, SQLState is " + e.getSQLState() + " class of "+ "exception is "+ e.getClass().getName()+ " msg is <"+ e.getMessage()+ ">");
                  sawDeadlock.set(true);
                }
              }
              conn1.rollback();
            }
 catch (            Exception e) {
              throw new RuntimeException(e);
            }
          }
        }
;
        Thread t2=new Thread(){
          @Override public void run(){
            try {
              try {
                updateLocks(conn2);
                updateTxns(conn2);
                Thread.sleep(1000);
                conn2.commit();
                LOG.debug("no exception, no deadlock");
              }
 catch (              SQLException e) {
                try {
                  tHndlr.checkRetryable(conn2,e,"thread t2");
                  LOG.debug("Got an exception, but not a deadlock, SQLState is " + e.getSQLState() + " class of exception is "+ e.getClass().getName()+ " msg is <"+ e.getMessage()+ ">");
                }
 catch (                TxnHandler.RetryException de) {
                  LOG.debug("Forced a deadlock, SQLState is " + e.getSQLState() + " class of "+ "exception is "+ e.getClass().getName()+ " msg is <"+ e.getMessage()+ ">");
                  sawDeadlock.set(true);
                }
              }
              conn2.rollback();
            }
 catch (            Exception e) {
              throw new RuntimeException(e);
            }
          }
        }
;
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        if (sawDeadlock.get())         break;
      }
      assertTrue(sawDeadlock.get());
    }
  finally {
      conn1.rollback();
      tHndlr.closeDbConn(conn1);
      conn2.rollback();
      tHndlr.closeDbConn(conn2);
    }
  }
}
