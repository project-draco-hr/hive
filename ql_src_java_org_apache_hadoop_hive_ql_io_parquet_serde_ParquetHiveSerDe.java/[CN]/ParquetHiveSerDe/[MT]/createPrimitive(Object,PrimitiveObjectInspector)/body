{
  if (obj == null) {
    return null;
  }
switch (inspector.getPrimitiveCategory()) {
case VOID:
    return null;
case BOOLEAN:
  return new BooleanWritable(((BooleanObjectInspector)inspector).get(obj) ? Boolean.TRUE : Boolean.FALSE);
case BYTE:
return new ByteWritable((byte)((ByteObjectInspector)inspector).get(obj));
case DOUBLE:
return new DoubleWritable(((DoubleObjectInspector)inspector).get(obj));
case FLOAT:
return new FloatWritable(((FloatObjectInspector)inspector).get(obj));
case INT:
return new IntWritable(((IntObjectInspector)inspector).get(obj));
case LONG:
return new LongWritable(((LongObjectInspector)inspector).get(obj));
case SHORT:
return new ShortWritable((short)((ShortObjectInspector)inspector).get(obj));
case STRING:
String v=((StringObjectInspector)inspector).getPrimitiveJavaObject(obj);
try {
return new BytesWritable(v.getBytes("UTF-8"));
}
 catch (UnsupportedEncodingException e) {
throw new SerDeException("Failed to encode string in UTF-8",e);
}
case DECIMAL:
HiveDecimal hd=(HiveDecimal)inspector.getPrimitiveJavaObject(obj);
DecimalTypeInfo decTypeInfo=(DecimalTypeInfo)inspector.getTypeInfo();
int prec=decTypeInfo.precision();
int scale=decTypeInfo.scale();
byte[] src=hd.setScale(scale).unscaledValue().toByteArray();
int bytes=PRECISION_TO_BYTE_COUNT[prec - 1];
if (bytes == src.length) {
return new BytesWritable(src);
}
byte[] tgt=new byte[bytes];
if (hd.signum() == -1) {
for (int i=0; i < bytes; i++) {
tgt[i]|=0xFF;
}
}
System.arraycopy(src,0,tgt,bytes - src.length,src.length);
return new BytesWritable(tgt);
case TIMESTAMP:
return new TimestampWritable(((TimestampObjectInspector)inspector).getPrimitiveJavaObject(obj));
default :
throw new SerDeException("Unknown primitive : " + inspector.getPrimitiveCategory());
}
}
