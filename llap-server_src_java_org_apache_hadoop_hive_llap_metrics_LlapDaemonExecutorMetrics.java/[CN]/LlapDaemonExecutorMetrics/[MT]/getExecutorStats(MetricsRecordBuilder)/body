{
  updateThreadMetrics(rb);
  final int totalSlots=waitQueueSize.value() + numExecutors;
  final int slotsAvailableInQueue=waitQueueSize.value() - executorNumQueuedRequests.value();
  final int slotsAvailableTotal=slotsAvailableInQueue + numExecutorsAvailable.value();
  final float slotsAvailablePercent=totalSlots <= 0 ? 0.0f : (float)slotsAvailableTotal / (float)totalSlots;
  rb.addCounter(ExecutorTotalRequestsHandled,executorTotalRequestHandled.value()).addCounter(ExecutorTotalSuccess,executorTotalSuccess.value()).addCounter(ExecutorTotalFailed,executorTotalExecutionFailed.value()).addCounter(ExecutorTotalKilled,executorTotalIKilled.value()).addCounter(ExecutorTotalEvictedFromWaitQueue,totalEvictedFromWaitQueue.value()).addCounter(ExecutorTotalRejectedRequests,totalRejectedRequests.value()).addGauge(ExecutorNumQueuedRequests,executorNumQueuedRequests.value()).addGauge(ExecutorNumPreemptableRequests,executorNumPreemptableRequests.value()).addGauge(ExecutorMemoryPerInstance,memoryPerInstance.value()).addGauge(ExecutorCacheMemoryPerInstance,cacheMemoryPerInstance.value()).addGauge(ExecutorJvmMaxMemory,jvmMaxMemory.value()).addGauge(ExecutorMaxFreeSlots,totalSlots).addGauge(ExecutorNumExecutorsPerInstance,numExecutors).addGauge(ExecutorWaitQueueSize,waitQueueSize.value()).addGauge(ExecutorNumExecutorsAvailable,numExecutorsAvailable.value()).addGauge(ExecutorAvailableFreeSlots,slotsAvailableTotal).addGauge(ExecutorAvailableFreeSlotsPercent,slotsAvailablePercent).addCounter(ExecutorTotalPreemptionTimeToKill,totalPreemptionTimeToKill.value()).addCounter(ExecutorTotalPreemptionTimeLost,totalPreemptionTimeLost.value()).addGauge(ExecutorMaxPreemptionTimeToKill,maxPreemptionTimeToKill.value()).addGauge(ExecutorMaxPreemptionTimeLost,maxPreemptionTimeLost.value());
  for (  MutableQuantiles q : percentileTimeToKill) {
    q.snapshot(rb,true);
  }
  for (  MutableQuantiles q : percentileTimeLost) {
    q.snapshot(rb,true);
  }
}
