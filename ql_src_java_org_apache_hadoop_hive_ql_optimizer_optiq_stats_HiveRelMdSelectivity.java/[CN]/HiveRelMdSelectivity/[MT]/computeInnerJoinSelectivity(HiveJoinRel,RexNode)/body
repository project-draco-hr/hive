{
  double ndvCrossProduct=1;
  Pair<Boolean,RexNode> predInfo=getCombinedPredicateForJoin(j,predicate);
  if (!predInfo.getKey()) {
    return new FilterSelectivityEstimator(j).estimateSelectivity(predInfo.getValue());
  }
  RexNode combinedPredicate=predInfo.getValue();
  JoinPredicateInfo jpi=JoinPredicateInfo.constructJoinPredicateInfo(j,combinedPredicate);
  ImmutableMap.Builder<Integer,Double> colStatMapBuilder=ImmutableMap.builder();
  ImmutableMap<Integer,Double> colStatMap;
  int rightOffSet=j.getLeft().getRowType().getFieldCount();
  for (  Integer ljk : jpi.getProjsFromLeftPartOfJoinKeysInChildSchema()) {
    colStatMapBuilder.put(ljk,HiveRelMdDistinctRowCount.getDistinctRowCount(j.getLeft(),ljk));
  }
  for (  Integer rjk : jpi.getProjsFromRightPartOfJoinKeysInChildSchema()) {
    colStatMapBuilder.put(rjk + rightOffSet,HiveRelMdDistinctRowCount.getDistinctRowCount(j.getRight(),rjk));
  }
  colStatMap=colStatMapBuilder.build();
  List<JoinLeafPredicateInfo> peLst=jpi.getEquiJoinPredicateElements();
  int noOfPE=peLst.size();
  if (noOfPE > 0) {
    ndvCrossProduct=exponentialBackoff(peLst,colStatMap);
    if (j.isLeftSemiJoin())     ndvCrossProduct=Math.min(RelMetadataQuery.getRowCount(j.getLeft()),ndvCrossProduct);
 else     ndvCrossProduct=Math.min(RelMetadataQuery.getRowCount(j.getLeft()) * RelMetadataQuery.getRowCount(j.getRight()),ndvCrossProduct);
  }
  return (1 / ndvCrossProduct);
}
