{
  String hbaseColumnNameProperty=tbl.getProperty(HBaseSerDe.HBASE_COLUMNS_MAPPING);
  String columnTypeProperty=tbl.getProperty(Constants.LIST_COLUMN_TYPES);
  hbaseColumnNames=parseColumnMapping(hbaseColumnNameProperty);
  iKey=hbaseColumnNames.indexOf(HBASE_KEY_COL);
  hbaseColumnNamesBytes=initColumnNamesBytes(hbaseColumnNames);
  if (columnTypeProperty == null) {
    StringBuilder sb=new StringBuilder();
    for (int i=0; i < hbaseColumnNames.size(); i++) {
      if (sb.length() > 0) {
        sb.append(":");
      }
      String colName=hbaseColumnNames.get(i);
      if (isSpecialColumn(colName)) {
        sb.append(Constants.STRING_TYPE_NAME);
      }
 else       if (colName.endsWith(":")) {
        sb.append(Constants.MAP_TYPE_NAME + "<" + Constants.STRING_TYPE_NAME+ ","+ Constants.STRING_TYPE_NAME+ ">");
      }
 else {
        sb.append(Constants.STRING_TYPE_NAME);
      }
    }
    tbl.setProperty(Constants.LIST_COLUMN_TYPES,sb.toString());
  }
  serdeParams=LazySimpleSerDe.initSerdeParams(job,tbl,serdeName);
  if (hbaseColumnNames.size() != serdeParams.getColumnNames().size()) {
    throw new SerDeException(serdeName + ": columns has " + serdeParams.getColumnNames().size()+ " elements while hbase.columns.mapping has "+ hbaseColumnNames.size()+ " elements"+ " (counting the key if implicit)");
  }
  separators=serdeParams.getSeparators();
  escaped=serdeParams.isEscaped();
  escapeChar=serdeParams.getEscapeChar();
  needsEscape=serdeParams.getNeedsEscape();
  for (int i=0; i < hbaseColumnNames.size(); i++) {
    String hbaseColName=hbaseColumnNames.get(i);
    if (hbaseColName.endsWith(":")) {
      TypeInfo typeInfo=serdeParams.getColumnTypes().get(i);
      if ((typeInfo.getCategory() != Category.MAP) || (((MapTypeInfo)typeInfo).getMapKeyTypeInfo().getTypeName() != Constants.STRING_TYPE_NAME)) {
        throw new SerDeException(serdeName + ": hbase column family '" + hbaseColName+ "' should be mapped to map<string,?> but is mapped to "+ typeInfo.getTypeName());
      }
    }
  }
}
