{
  MRInputLegacy theMRInput=null;
  Set<Input> li=new HashSet<Input>();
  for (  LogicalInput inp : inputs.values()) {
    if (inp instanceof MRInputLegacy || inp instanceof MultiMRInput) {
      inp.start();
      li.add(inp);
    }
  }
  processorContext.waitForAllInputsReady(li);
  l4j.info("The input names are: " + Arrays.toString(inputs.keySet().toArray()));
  for (  Entry<String,LogicalInput> inp : inputs.entrySet()) {
    if (inp.getValue() instanceof MRInputLegacy) {
      if (theMRInput != null) {
        throw new IllegalArgumentException("Only one MRInput is expected");
      }
      theMRInput=(MRInputLegacy)inp.getValue();
    }
 else     if (inp.getValue() instanceof MultiMRInput) {
      multiMRInputMap.put(inp.getKey(),(MultiMRInput)inp.getValue());
    }
  }
  if (theMRInput != null) {
    theMRInput.init();
  }
 else {
    String alias=mapWork.getAliasToWork().keySet().iterator().next();
    if (inputs.get(alias) instanceof MultiMRInput) {
      mainWorkMultiMRInput=(MultiMRInput)inputs.get(alias);
    }
 else {
      throw new IOException("Unexpected input type found: " + inputs.get(alias).getClass().getCanonicalName());
    }
  }
  return theMRInput;
}
