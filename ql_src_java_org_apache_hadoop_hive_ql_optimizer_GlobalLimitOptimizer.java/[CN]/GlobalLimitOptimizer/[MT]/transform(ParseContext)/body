{
  Context ctx=pctx.getContext();
  Map<String,Operator<? extends OperatorDesc>> topOps=pctx.getTopOps();
  GlobalLimitCtx globalLimitCtx=pctx.getGlobalLimitCtx();
  Map<TableScanOperator,ExprNodeDesc> opToPartPruner=pctx.getOpToPartPruner();
  Map<String,SplitSample> nameToSplitSample=pctx.getNameToSplitSample();
  if (ctx.getTryCount() == 0 && topOps.size() == 1 && !globalLimitCtx.ifHasTransformOrUDTF() && nameToSplitSample.isEmpty()) {
    TableScanOperator ts=(TableScanOperator)topOps.values().toArray()[0];
    Integer tempGlobalLimit=checkQbpForGlobalLimit(ts);
    if (tempGlobalLimit != null && tempGlobalLimit != 0) {
      Table tab=ts.getConf().getTableMetadata();
      Set<FilterOperator> filterOps=OperatorUtils.findOperators(ts,FilterOperator.class);
      if (!tab.isPartitioned()) {
        if (filterOps.size() == 0) {
          globalLimitCtx.enableOpt(tempGlobalLimit);
        }
      }
 else {
        if (onlyContainsPartnCols(tab,filterOps)) {
          String alias=(String)topOps.keySet().toArray()[0];
          PrunedPartitionList partsList=pctx.getPrunedPartitions(alias,ts);
          if (!partsList.hasUnknownPartitions()) {
            globalLimitCtx.enableOpt(tempGlobalLimit);
          }
        }
      }
      if (globalLimitCtx.isEnable()) {
        LOG.info("Qualify the optimize that reduces input size for 'limit' for limit " + globalLimitCtx.getGlobalLimit());
      }
    }
  }
  return pctx;
}
