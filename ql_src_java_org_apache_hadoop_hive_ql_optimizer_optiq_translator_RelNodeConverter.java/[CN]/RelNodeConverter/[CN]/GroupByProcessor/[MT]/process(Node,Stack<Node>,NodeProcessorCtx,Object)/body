{
  Context ctx=(Context)procCtx;
  HiveRel input=(HiveRel)ctx.getParentNode((Operator<? extends OperatorDesc>)nd,0);
  GroupByOperator groupByOp=(GroupByOperator)nd;
  RowResolver rr=ctx.sA.getRowResolver(groupByOp);
  ArrayList<ColumnInfo> signature=rr.getRowSchema().getSignature();
  if (groupByOp.getParentOperators().get(0) instanceof ReduceSinkOperator) {
    ctx.hiveOpToRelNode.put(groupByOp,input);
    return input;
  }
  final List<RexNode> extraExprs=Lists.newArrayList();
  final BitSet groupSet=new BitSet();
  for (  ExprNodeDesc key : groupByOp.getConf().getKeys()) {
    int index=convertExpr(ctx,input,key,extraExprs);
    groupSet.set(index);
  }
  List<AggregateCall> aggregateCalls=Lists.newArrayList();
  int i=groupByOp.getConf().getKeys().size();
  for (  AggregationDesc agg : groupByOp.getConf().getAggregators()) {
    aggregateCalls.add(convertAgg(ctx,agg,input,signature.get(i++),extraExprs));
  }
  if (!extraExprs.isEmpty()) {
    input=HiveProjectRel.create(input,CompositeList.of(Lists.transform(input.getRowType().getFieldList(),new Function<RelDataTypeField,RexNode>(){
      public RexNode apply(      RelDataTypeField input){
        return new RexInputRef(input.getIndex(),input.getType());
      }
    }
),extraExprs),null);
  }
  try {
    HiveRel aggregateRel=new HiveAggregateRel(ctx.cluster,ctx.cluster.traitSetOf(HiveRel.CONVENTION),input,groupSet,aggregateCalls);
    ctx.buildColumnMap(groupByOp,aggregateRel);
    ctx.hiveOpToRelNode.put(groupByOp,aggregateRel);
    return aggregateRel;
  }
 catch (  InvalidRelException e) {
    throw new AssertionError(e);
  }
}
