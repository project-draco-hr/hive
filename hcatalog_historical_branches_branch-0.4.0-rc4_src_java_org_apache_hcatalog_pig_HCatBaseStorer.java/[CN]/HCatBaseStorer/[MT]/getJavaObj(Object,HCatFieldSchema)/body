{
  try {
    Type type=hcatFS.getType();
switch (type) {
case BINARY:
      ByteArrayRef ba=new ByteArrayRef();
    byte[] bytes=(null == pigObj) ? new byte[0] : ((DataByteArray)pigObj).get();
  ba.setData(bytes);
return ba;
case STRUCT:
if (pigObj == null) {
return null;
}
HCatSchema structSubSchema=hcatFS.getStructSubSchema();
List<Object> all=((Tuple)pigObj).getAll();
ArrayList<Object> converted=new ArrayList<Object>(all.size());
for (int i=0; i < all.size(); i++) {
converted.add(getJavaObj(all.get(i),structSubSchema.get(i)));
}
return converted;
case ARRAY:
if (pigObj == null) {
return null;
}
DataBag pigBag=(DataBag)pigObj;
HCatFieldSchema tupFS=hcatFS.getArrayElementSchema().get(0);
boolean needTuple=tupFS.getType() == Type.STRUCT;
List<Object> bagContents=new ArrayList<Object>((int)pigBag.size());
Iterator<Tuple> bagItr=pigBag.iterator();
while (bagItr.hasNext()) {
bagContents.add(getJavaObj(needTuple ? bagItr.next() : bagItr.next().get(0),tupFS));
}
return bagContents;
case MAP:
if (pigObj == null) {
return null;
}
Map<?,?> pigMap=(Map<?,?>)pigObj;
Map<Object,Object> typeMap=new HashMap<Object,Object>();
for (Entry<?,?> entry : pigMap.entrySet()) {
typeMap.put((String)entry.getKey(),getJavaObj(entry.getValue(),hcatFS.getMapValueSchema().get(0)));
}
return typeMap;
case STRING:
case INT:
case BIGINT:
case FLOAT:
case DOUBLE:
return pigObj;
case SMALLINT:
case TINYINT:
case BOOLEAN:
throw new BackendException("Incompatible type " + type + " found in hcat table schema: "+ hcatFS,PigHCatUtil.PIG_EXCEPTION_CODE);
default :
throw new BackendException("Unexpected type " + type + " for value "+ pigObj+ (pigObj == null ? "" : " of class " + pigObj.getClass().getName()),PigHCatUtil.PIG_EXCEPTION_CODE);
}
}
 catch (BackendException e) {
throw new BackendException((hcatFS.getName() == null ? " " : hcatFS.getName() + ".") + e.getMessage(),e.getCause() == null ? e : e.getCause());
}
}
