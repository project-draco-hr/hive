{
  ByteBuffer slice=null;
  ByteBuffer compressed=current.chunk;
  long cbStartOffset=current.getOffset();
  int b0=compressed.get() & 0xff;
  int b1=compressed.get() & 0xff;
  int b2=compressed.get() & 0xff;
  int chunkLength=(b2 << 15) | (b1 << 7) | (b0 >> 1);
  if (chunkLength > bufferSize) {
    throw new IllegalArgumentException("Buffer size too small. size = " + bufferSize + " needed = "+ chunkLength);
  }
  int consumedLength=chunkLength + OutStream.HEADER_SIZE;
  long cbEndOffset=cbStartOffset + consumedLength;
  boolean isUncompressed=((b0 & 0x01) == 1);
  if (isDebugTracingEnabled) {
    LOG.info("Found CB at " + cbStartOffset + ", chunk length "+ chunkLength+ ", total "+ consumedLength+ ", "+ (isUncompressed ? "not " : "")+ "compressed");
  }
  if (compressed.remaining() >= chunkLength) {
    slice=compressed.slice();
    slice.limit(chunkLength);
    ProcCacheChunk cc=addOneCompressionBlockByteBuffer(slice,isUncompressed,cbStartOffset,cbEndOffset,chunkLength,current,toDecompress,cacheBuffers);
    if (compressed.remaining() <= 0 && dataReader.isTrackingDiskRanges()) {
      toRelease.add(compressed);
    }
    return cc;
  }
  if (current.getEnd() < cbEndOffset && !current.hasContiguousNext()) {
    addIncompleteCompressionBuffer(cbStartOffset,current,0);
    return null;
  }
  ByteBuffer copy=allocateBuffer(chunkLength,compressed.isDirect());
  int remaining=chunkLength - compressed.remaining();
  int originalPos=compressed.position();
  copy.put(compressed);
  if (isDebugTracingEnabled) {
    LOG.info("Removing partial CB " + current + " from ranges after copying its contents");
  }
  DiskRangeList next=current.next;
  current.removeSelf();
  if (dataReader.isTrackingDiskRanges()) {
    if (originalPos == 0) {
      dataReader.releaseBuffer(compressed);
    }
 else {
      toRelease.add(compressed);
    }
  }
  int extraChunkCount=0;
  while (true) {
    if (!(next instanceof BufferChunk)) {
      throw new IOException("Trying to extend compressed block into uncompressed block " + next);
    }
    compressed=next.getData();
    ++extraChunkCount;
    if (compressed.remaining() >= remaining) {
      slice=compressed.slice();
      slice.limit(remaining);
      copy.put(slice);
      ProcCacheChunk cc=addOneCompressionBlockByteBuffer(copy,isUncompressed,cbStartOffset,cbEndOffset,remaining,(BufferChunk)next,toDecompress,cacheBuffers);
      if (compressed.remaining() <= 0 && dataReader.isTrackingDiskRanges()) {
        dataReader.releaseBuffer(compressed);
      }
      return cc;
    }
    remaining-=compressed.remaining();
    copy.put(compressed);
    if (dataReader.isTrackingDiskRanges()) {
      dataReader.releaseBuffer(compressed);
    }
    DiskRangeList tmp=next;
    next=next.hasContiguousNext() ? next.next : null;
    if (next != null) {
      if (isDebugTracingEnabled) {
        LOG.info("Removing partial CB " + tmp + " from ranges after copying its contents");
      }
      tmp.removeSelf();
    }
 else {
      addIncompleteCompressionBuffer(cbStartOffset,tmp,extraChunkCount);
      return null;
    }
  }
}
