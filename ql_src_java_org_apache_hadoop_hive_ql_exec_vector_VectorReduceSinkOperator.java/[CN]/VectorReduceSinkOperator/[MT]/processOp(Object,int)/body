{
  VectorizedRowBatch vrg=(VectorizedRowBatch)row;
  LOG.info(String.format("sinking %d rows, %d values, %d keys, %d parts",vrg.size,valueEval.length,keyEval.length,partitionEval.length));
  try {
    for (int i=0; i < partitionEval.length; i++) {
      partitionEval[i].evaluate(vrg);
    }
    for (int i=0; i < valueEval.length; i++) {
      valueEval[i].evaluate(vrg);
    }
    for (int i=0; i < keyEval.length; i++) {
      keyEval[i].evaluate(vrg);
    }
    Object[] distributionKeys=new Object[numDistributionKeys];
    for (int j=0; j < vrg.size; ++j) {
      int rowIndex=j;
      if (vrg.selectedInUse) {
        rowIndex=vrg.selected[j];
      }
      for (int i=0; i < valueEval.length; i++) {
        int batchColumn=valueEval[i].getOutputColumn();
        ColumnVector vectorColumn=vrg.cols[batchColumn];
        cachedValues[i]=vectorColumn.getWritableObject(rowIndex);
      }
      value=valueSerializer.serialize(cachedValues,valueObjectInspector);
      for (int i=0; i < keyEval.length; i++) {
        int batchColumn=keyEval[i].getOutputColumn();
        ColumnVector vectorColumn=vrg.cols[batchColumn];
        distributionKeys[i]=vectorColumn.getWritableObject(rowIndex);
      }
      System.arraycopy(distributionKeys,0,cachedKeys[0],0,numDistributionKeys);
      for (int i=0; i < cachedKeys.length; i++) {
        if (keyIsText) {
          Text key=(Text)keySerializer.serialize(cachedKeys[i],keyObjectInspector);
          if (tag == -1) {
            keyWritable.set(key.getBytes(),0,key.getLength());
          }
 else {
            int keyLength=key.getLength();
            keyWritable.setSize(keyLength + 1);
            System.arraycopy(key.getBytes(),0,keyWritable.get(),0,keyLength);
            keyWritable.get()[keyLength]=tagByte[0];
          }
        }
 else {
          BytesWritable key=(BytesWritable)keySerializer.serialize(cachedKeys[i],keyObjectInspector);
          if (tag == -1) {
            keyWritable.set(key.getBytes(),0,key.getLength());
          }
 else {
            int keyLength=key.getLength();
            keyWritable.setSize(keyLength + 1);
            System.arraycopy(key.getBytes(),0,keyWritable.get(),0,keyLength);
            keyWritable.get()[keyLength]=tagByte[0];
          }
        }
        int keyHashCode=0;
        if (partitionEval.length == 0) {
          if (random == null) {
            random=new Random(12345);
          }
          keyHashCode=random.nextInt();
        }
 else {
          for (int p=0; p < partitionEval.length; p++) {
            keyHashCode=keyHashCode * 31 + ObjectInspectorUtils.hashCode(vrg.cols[partitionEval[p].getOutputColumn()].getWritableObject(rowIndex),partitionObjectInspectors[i]);
          }
        }
        keyWritable.setHashCode(keyHashCode);
        if (out != null) {
          out.collect(keyWritable,value);
          if (counterNameToEnum != null) {
            ++outputRows;
            if (outputRows % 1000 == 0) {
              incrCounter(numOutputRowsCntr,outputRows);
              outputRows=0;
            }
          }
        }
      }
    }
  }
 catch (  SerDeException e) {
    throw new HiveException(e);
  }
catch (  IOException e) {
    throw new HiveException(e);
  }
}
