{
  if (equalsCheck && inputOI.equals(outputOI)) {
    return outputOI;
  }
switch (outputOI.getCategory()) {
case PRIMITIVE:
    PrimitiveObjectInspector primInputOI=(PrimitiveObjectInspector)inputOI;
  return PrimitiveObjectInspectorFactory.getPrimitiveWritableObjectInspector(primInputOI);
case STRUCT:
StructObjectInspector structOutputOI=(StructObjectInspector)outputOI;
if (structOutputOI.isSettable()) {
return outputOI;
}
 else {
List<? extends StructField> listFields=structOutputOI.getAllStructFieldRefs();
List<String> structFieldNames=new ArrayList<String>(listFields.size());
List<ObjectInspector> structFieldObjectInspectors=new ArrayList<ObjectInspector>(listFields.size());
for (StructField listField : listFields) {
  structFieldNames.add(listField.getFieldName());
  structFieldObjectInspectors.add(getConvertedOI(listField.getFieldObjectInspector(),listField.getFieldObjectInspector(),false));
}
return ObjectInspectorFactory.getStandardStructObjectInspector(structFieldNames,structFieldObjectInspectors);
}
case LIST:
ListObjectInspector listOutputOI=(ListObjectInspector)outputOI;
return ObjectInspectorFactory.getStandardListObjectInspector(listOutputOI.getListElementObjectInspector());
case MAP:
MapObjectInspector mapOutputOI=(MapObjectInspector)outputOI;
return ObjectInspectorFactory.getStandardMapObjectInspector(mapOutputOI.getMapKeyObjectInspector(),mapOutputOI.getMapValueObjectInspector());
default :
throw new RuntimeException("Hive internal error: conversion of " + inputOI.getTypeName() + " to "+ outputOI.getTypeName()+ " not supported yet.");
}
}
