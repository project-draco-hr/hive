{
  if (inputOI.equals(outputOI)) {
    return outputOI;
  }
switch (outputOI.getCategory()) {
case PRIMITIVE:
    return outputOI;
case STRUCT:
  StructObjectInspector structOutputOI=(StructObjectInspector)outputOI;
if (structOutputOI.isSettable()) {
  return outputOI;
}
 else {
  List<? extends StructField> listFields=structOutputOI.getAllStructFieldRefs();
  List<String> structFieldNames=new ArrayList<String>(listFields.size());
  List<ObjectInspector> structFieldObjectInspectors=new ArrayList<ObjectInspector>(listFields.size());
  for (  StructField listField : listFields) {
    structFieldNames.add(listField.getFieldName());
    structFieldObjectInspectors.add(listField.getFieldObjectInspector());
  }
  StandardStructObjectInspector structStandardOutputOI=ObjectInspectorFactory.getStandardStructObjectInspector(structFieldNames,structFieldObjectInspectors);
  return structStandardOutputOI;
}
case LIST:
return outputOI;
case MAP:
return outputOI;
default :
throw new RuntimeException("Hive internal error: conversion of " + inputOI.getTypeName() + " to "+ outputOI.getTypeName()+ " not supported yet.");
}
}
