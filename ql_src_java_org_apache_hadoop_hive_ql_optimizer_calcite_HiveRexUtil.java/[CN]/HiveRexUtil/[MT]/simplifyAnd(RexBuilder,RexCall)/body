{
  final List<RexNode> terms=RelOptUtil.conjunctions(e);
  final List<RexNode> notTerms=new ArrayList<>();
  final List<RexNode> negatedTerms=new ArrayList<>();
  final List<RexNode> nullOperands=new ArrayList<>();
  final List<RexNode> notNullOperands=new ArrayList<>();
  final Set<RexNode> comparedOperands=new HashSet<>();
  for (int i=0; i < terms.size(); i++) {
    final RexNode term=terms.get(i);
    if (!HiveCalciteUtil.isDeterministic(term)) {
      continue;
    }
switch (term.getKind()) {
case NOT:
      notTerms.add(((RexCall)term).getOperands().get(0));
    terms.remove(i);
  --i;
break;
case LITERAL:
if (!RexLiteral.booleanValue(term)) {
return term;
}
 else {
terms.remove(i);
--i;
}
break;
case EQUALS:
case NOT_EQUALS:
case LESS_THAN:
case GREATER_THAN:
case LESS_THAN_OR_EQUAL:
case GREATER_THAN_OR_EQUAL:
RexCall call=(RexCall)term;
RexNode left=call.getOperands().get(0);
comparedOperands.add(left);
if (left.getKind() == SqlKind.CAST) {
RexCall leftCast=(RexCall)left;
comparedOperands.add(leftCast.getOperands().get(0));
}
RexNode right=call.getOperands().get(1);
comparedOperands.add(right);
if (right.getKind() == SqlKind.CAST) {
RexCall rightCast=(RexCall)right;
comparedOperands.add(rightCast.getOperands().get(0));
}
RexCall negatedTerm=negate(rexBuilder,call);
if (negatedTerm != null) {
negatedTerms.add(negatedTerm);
RexCall invertNegatedTerm=invert(rexBuilder,negatedTerm);
if (invertNegatedTerm != null) {
negatedTerms.add(invertNegatedTerm);
}
}
break;
case IN:
comparedOperands.add(((RexCall)term).operands.get(0));
break;
case BETWEEN:
comparedOperands.add(((RexCall)term).operands.get(1));
break;
case IS_NOT_NULL:
notNullOperands.add(((RexCall)term).getOperands().get(0));
terms.remove(i);
--i;
break;
case IS_NULL:
nullOperands.add(((RexCall)term).getOperands().get(0));
}
}
if (terms.isEmpty() && notTerms.isEmpty() && notNullOperands.isEmpty()) {
return rexBuilder.makeLiteral(true);
}
if (!Collections.disjoint(nullOperands,comparedOperands)) {
return rexBuilder.makeLiteral(false);
}
for (RexNode operand : notNullOperands) {
if (!comparedOperands.contains(operand)) {
terms.add(rexBuilder.makeCall(SqlStdOperatorTable.IS_NOT_NULL,operand));
}
}
final Set<String> termsSet=new HashSet<String>(Lists.transform(terms,HiveCalciteUtil.REX_STR_FN));
for (RexNode notDisjunction : notTerms) {
final Set<String> notSet=new HashSet<String>(Lists.transform(RelOptUtil.conjunctions(notDisjunction),HiveCalciteUtil.REX_STR_FN));
if (termsSet.containsAll(notSet)) {
return rexBuilder.makeLiteral(false);
}
}
for (RexNode notDisjunction : notTerms) {
terms.add(rexBuilder.makeCall(SqlStdOperatorTable.NOT,notDisjunction));
}
for (RexNode notDisjunction : negatedTerms) {
final Set<String> notSet=new HashSet<String>(Lists.transform(RelOptUtil.conjunctions(notDisjunction),HiveCalciteUtil.REX_STR_FN));
if (termsSet.containsAll(notSet)) {
return rexBuilder.makeLiteral(false);
}
}
return RexUtil.composeConjunction(rexBuilder,terms,false);
}
