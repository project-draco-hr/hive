{
  boolean extended=false;
  boolean formatted=false;
  boolean dependency=false;
  boolean logical=false;
  if (ast.getChildCount() == 2) {
    int explainOptions=ast.getChild(1).getType();
    formatted=(explainOptions == HiveParser.KW_FORMATTED);
    extended=(explainOptions == HiveParser.KW_EXTENDED);
    dependency=(explainOptions == HiveParser.KW_DEPENDENCY);
    logical=(explainOptions == HiveParser.KW_LOGICAL);
  }
  ctx.setExplain(true);
  ctx.setExplainLogical(logical);
  ASTNode input=(ASTNode)ast.getChild(0);
  BaseSemanticAnalyzer sem=SemanticAnalyzerFactory.get(conf,input);
  sem.analyze(input,ctx);
  sem.validate();
  ctx.setResFile(new Path(ctx.getLocalTmpFileURI()));
  List<Task<? extends Serializable>> tasks=sem.getRootTasks();
  Task<? extends Serializable> fetchTask=sem.getFetchTask();
  if (tasks == null) {
    tasks=Collections.emptyList();
  }
  ParseContext pCtx=null;
  if (sem instanceof SemanticAnalyzer) {
    pCtx=((SemanticAnalyzer)sem).getParseContext();
  }
  ExplainWork work=new ExplainWork(ctx.getResFile(),pCtx,tasks,fetchTask,input.toStringTree(),sem.getInputs(),extended,formatted,dependency,logical);
  work.setAppendTaskType(HiveConf.getBoolVar(conf,HiveConf.ConfVars.HIVEEXPLAINDEPENDENCYAPPENDTASKTYPES));
  Task<? extends Serializable> explTask=TaskFactory.get(work,conf);
  fieldList=explTask.getResultSchema();
  rootTasks.add(explTask);
}
