{
  Map<String,Long> results=Maps.newLinkedHashMap();
  long executorDeserializeTime=0;
  long executorRunTime=0;
  long resultSize=0;
  long jvmGCTime=0;
  long resultSerializationTime=0;
  long memoryBytesSpilled=0;
  long diskBytesSpilled=0;
  long bytesRead=0;
  long remoteBlocksFetched=0;
  long localBlocksFetched=0;
  long fetchWaitTime=0;
  long remoteBytesRead=0;
  long shuffleBytesWritten=0;
  long shuffleWriteTime=0;
  boolean inputMetricExist=false;
  boolean shuffleReadMetricExist=false;
  boolean shuffleWriteMetricExist=false;
  for (  List<TaskMetrics> stageMetric : jobMetric.values()) {
    if (stageMetric != null) {
      for (      TaskMetrics taskMetrics : stageMetric) {
        if (taskMetrics != null) {
          executorDeserializeTime+=taskMetrics.executorDeserializeTime();
          executorRunTime+=taskMetrics.executorRunTime();
          resultSize+=taskMetrics.resultSize();
          jvmGCTime+=taskMetrics.jvmGCTime();
          resultSerializationTime+=taskMetrics.resultSerializationTime();
          memoryBytesSpilled+=taskMetrics.memoryBytesSpilled();
          diskBytesSpilled+=taskMetrics.diskBytesSpilled();
          if (!taskMetrics.inputMetrics().isEmpty()) {
            inputMetricExist=true;
            bytesRead+=taskMetrics.inputMetrics().get().bytesRead();
          }
          Option<ShuffleReadMetrics> shuffleReadMetricsOption=taskMetrics.shuffleReadMetrics();
          if (!shuffleReadMetricsOption.isEmpty()) {
            shuffleReadMetricExist=true;
            remoteBlocksFetched+=shuffleReadMetricsOption.get().remoteBlocksFetched();
            localBlocksFetched+=shuffleReadMetricsOption.get().localBlocksFetched();
            fetchWaitTime+=shuffleReadMetricsOption.get().fetchWaitTime();
            remoteBytesRead+=shuffleReadMetricsOption.get().remoteBytesRead();
          }
          Option<ShuffleWriteMetrics> shuffleWriteMetricsOption=taskMetrics.shuffleWriteMetrics();
          if (!shuffleWriteMetricsOption.isEmpty()) {
            shuffleWriteMetricExist=true;
            shuffleBytesWritten+=shuffleWriteMetricsOption.get().shuffleBytesWritten();
            shuffleWriteTime+=shuffleWriteMetricsOption.get().shuffleWriteTime();
          }
        }
      }
    }
  }
  results.put("ExecutorDeserializeTime",executorDeserializeTime);
  results.put("ExecutorRunTime",executorRunTime);
  results.put("ResultSize",resultSize);
  results.put("JvmGCTime",jvmGCTime);
  results.put("ResultSerializationTime",resultSerializationTime);
  results.put("MemoryBytesSpilled",memoryBytesSpilled);
  results.put("DiskBytesSpilled",diskBytesSpilled);
  if (inputMetricExist) {
    results.put("BytesRead",bytesRead);
  }
  if (shuffleReadMetricExist) {
    results.put("RemoteBlocksFetched",remoteBlocksFetched);
    results.put("LocalBlocksFetched",localBlocksFetched);
    results.put("TotalBlocksFetched",localBlocksFetched + remoteBlocksFetched);
    results.put("FetchWaitTime",fetchWaitTime);
    results.put("RemoteBytesRead",remoteBytesRead);
  }
  if (shuffleWriteMetricExist) {
    results.put("ShuffleBytesWritten",shuffleBytesWritten);
    results.put("ShuffleWriteTime",shuffleWriteTime);
  }
  return results;
}
