{
  long evicted=0;
  LlapCacheableBuffer nextCandidate, firstCandidate;
  listLock.lock();
  try {
    nextCandidate=firstCandidate=listTail;
    while (evicted < memoryToReserve && nextCandidate != null) {
      if (!nextCandidate.invalidate()) {
        LlapCacheableBuffer lockedBuffer=nextCandidate;
        if (firstCandidate == nextCandidate) {
          firstCandidate=nextCandidate.prev;
        }
        nextCandidate=nextCandidate.prev;
        removeFromListUnderLock(lockedBuffer);
        continue;
      }
      nextCandidate.indexInHeap=LlapCacheableBuffer.NOT_IN_CACHE;
      evicted+=nextCandidate.getMemoryUsage();
      nextCandidate=nextCandidate.prev;
    }
    if (firstCandidate != nextCandidate) {
      if (nextCandidate == null) {
        listHead=listTail=null;
      }
 else {
        removeFromListUnderLockNoStateUpdate(nextCandidate.next,firstCandidate);
      }
    }
  }
  finally {
    listLock.unlock();
  }
  while (firstCandidate != nextCandidate) {
    evictionListener.notifyEvicted(firstCandidate);
    firstCandidate=firstCandidate.prev;
  }
  if (evicted >= memoryToReserve)   return evicted;
  long time=timer.get();
  while (evicted < memoryToReserve) {
    LlapCacheableBuffer buffer=null;
synchronized (heap) {
      buffer=evictFromHeapUnderLock(time);
    }
    if (buffer == null)     return evicted;
    evicted+=buffer.getMemoryUsage();
    evictionListener.notifyEvicted(buffer);
  }
  return evicted;
}
