{
  String hfilePath=getFamilyPath(jc,tableProperties);
  if (hfilePath == null) {
    throw new RuntimeException("Please set " + HFILE_FAMILY_PATH + " to target location for HFiles");
  }
  final Path columnFamilyPath=new Path(hfilePath);
  final String columnFamilyName=columnFamilyPath.getName();
  final byte[] columnFamilyNameBytes=Bytes.toBytes(columnFamilyName);
  final Job job=new Job(jc);
  setCompressOutput(job,isCompressed);
  setOutputPath(job,finalOutPath);
  final org.apache.hadoop.mapreduce.TaskAttemptContext tac=ShimLoader.getHadoopShims().newTaskAttemptContext(job.getConfiguration(),progressable);
  final Path outputdir=FileOutputFormat.getOutputPath(tac);
  final org.apache.hadoop.mapreduce.RecordWriter<ImmutableBytesWritable,KeyValue> fileWriter=getFileWriter(tac);
  String columnList=tableProperties.getProperty("columns");
  String[] columnArray=columnList.split(",");
  final SortedMap<byte[],Integer> columnMap=new TreeMap<byte[],Integer>(Bytes.BYTES_COMPARATOR);
  int i=0;
  for (  String columnName : columnArray) {
    if (i != 0) {
      columnMap.put(Bytes.toBytes(columnName),i);
    }
    ++i;
  }
  return new RecordWriter(){
    @Override public void close(    boolean abort) throws IOException {
      try {
        fileWriter.close(null);
        if (abort) {
          return;
        }
        FileSystem fs=outputdir.getFileSystem(jc);
        fs.mkdirs(columnFamilyPath);
        Path srcDir=outputdir;
        for (; ; ) {
          FileStatus[] files=fs.listStatus(srcDir,FileUtils.STAGING_DIR_PATH_FILTER);
          if ((files == null) || (files.length == 0)) {
            throw new IOException("No family directories found in " + srcDir);
          }
          if (files.length != 1) {
            throw new IOException("Multiple family directories found in " + srcDir);
          }
          srcDir=files[0].getPath();
          if (srcDir.getName().equals(columnFamilyName)) {
            break;
          }
        }
        for (        FileStatus regionFile : fs.listStatus(srcDir,FileUtils.STAGING_DIR_PATH_FILTER)) {
          fs.rename(regionFile.getPath(),new Path(columnFamilyPath,regionFile.getPath().getName()));
        }
        fs.delete(outputdir,true);
        fs.createNewFile(outputdir);
      }
 catch (      InterruptedException ex) {
        throw new IOException(ex);
      }
    }
    private void writeText(    Text text) throws IOException {
      String s=text.toString();
      String[] fields=s.split("\u0001");
      assert(fields.length <= (columnMap.size() + 1));
      byte[] rowKeyBytes=Bytes.toBytes(fields[0]);
      for (      Map.Entry<byte[],Integer> entry : columnMap.entrySet()) {
        byte[] columnNameBytes=entry.getKey();
        int iColumn=entry.getValue();
        String val;
        if (iColumn >= fields.length) {
          val="";
        }
 else {
          val=fields[iColumn];
          if ("\\N".equals(val)) {
            continue;
          }
        }
        byte[] valBytes=Bytes.toBytes(val);
        KeyValue kv=new KeyValue(rowKeyBytes,columnFamilyNameBytes,columnNameBytes,valBytes);
        try {
          fileWriter.write(null,kv);
        }
 catch (        IOException e) {
          LOG.error("Failed while writing row: " + s);
          throw e;
        }
catch (        InterruptedException ex) {
          throw new IOException(ex);
        }
      }
    }
    private void writePut(    PutWritable put) throws IOException {
      ImmutableBytesWritable row=new ImmutableBytesWritable(put.getPut().getRow());
      SortedMap<byte[],List<Cell>> cells=put.getPut().getFamilyCellMap();
      for (      Map.Entry<byte[],List<Cell>> entry : cells.entrySet()) {
        Collections.sort(entry.getValue(),new CellComparator());
        for (        Cell c : entry.getValue()) {
          try {
            fileWriter.write(row,KeyValueUtil.copyToNewKeyValue(c));
          }
 catch (          InterruptedException e) {
            throw (InterruptedIOException)new InterruptedIOException().initCause(e);
          }
        }
      }
    }
    @Override public void write(    Writable w) throws IOException {
      if (w instanceof Text) {
        writeText((Text)w);
      }
 else       if (w instanceof PutWritable) {
        writePut((PutWritable)w);
      }
 else {
        throw new IOException("Unexpected writable " + w);
      }
    }
  }
;
}
