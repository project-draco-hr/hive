{
  if (overflowBatch.size > 0) {
    forwardOverflow();
  }
  ByteSegmentRef byteSegmentRef=hashMapResult.first();
  while (byteSegmentRef != null) {
    while (byteSegmentRef != null) {
      if (smallTableVectorDeserializeRow != null) {
        doSmallTableDeserializeRow(overflowBatch,overflowBatch.size,byteSegmentRef,hashMapResult);
      }
      overflowBatch.size++;
      if (overflowBatch.size == overflowBatch.DEFAULT_SIZE) {
        break;
      }
      byteSegmentRef=hashMapResult.next();
    }
    for (int i=0; i < duplicateCount; i++) {
      int batchIndex=allMatchs[allMatchesIndex + i];
      if (bigTableRetainedVectorCopy != null) {
        bigTableRetainedVectorCopy.copyByReference(batch,batchIndex,overflowBatch,0);
        for (        int column : bigTableRetainedMapping.getOutputColumns()) {
          overflowBatch.cols[column].isRepeating=true;
        }
      }
      forwardOverflowNoReset();
      for (      int column : bigTableRetainedMapping.getOutputColumns()) {
        ColumnVector colVector=overflowBatch.cols[column];
        colVector.reset();
      }
    }
    byteSegmentRef=hashMapResult.next();
    if (byteSegmentRef == null) {
      break;
    }
    overflowBatch.reset();
  }
  overflowBatch.reset();
}
