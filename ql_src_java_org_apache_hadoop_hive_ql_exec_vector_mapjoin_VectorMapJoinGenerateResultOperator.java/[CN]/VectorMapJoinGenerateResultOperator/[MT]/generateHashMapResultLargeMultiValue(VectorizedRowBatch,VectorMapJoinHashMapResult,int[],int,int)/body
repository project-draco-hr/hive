{
  if (overflowBatch.size > 0) {
    forwardOverflow();
  }
  ByteSegmentRef byteSegmentRef=hashMapResult.first();
  while (byteSegmentRef != null) {
    while (byteSegmentRef != null) {
      if (smallTableVectorDeserializeRow != null) {
        byte[] bytes=byteSegmentRef.getBytes();
        int offset=(int)byteSegmentRef.getOffset();
        int length=byteSegmentRef.getLength();
        smallTableVectorDeserializeRow.setBytes(bytes,offset,length);
        smallTableVectorDeserializeRow.deserialize(overflowBatch,overflowBatch.size);
      }
      overflowBatch.size++;
      if (overflowBatch.size == overflowBatch.DEFAULT_SIZE) {
        break;
      }
      byteSegmentRef=hashMapResult.next();
    }
    for (int i=0; i < duplicateCount; i++) {
      int batchIndex=allMatchs[allMatchesIndex + i];
      if (bigTableRetainedVectorCopy != null) {
        bigTableRetainedVectorCopy.copyByReference(batch,batchIndex,overflowBatch,0);
        for (        int column : bigTableRetainedMapping.getOutputColumns()) {
          overflowBatch.cols[column].isRepeating=true;
        }
      }
      forwardOverflowNoReset();
      for (      int column : bigTableRetainedMapping.getOutputColumns()) {
        ColumnVector colVector=overflowBatch.cols[column];
        colVector.reset();
      }
    }
    if (hashMapResult.isEof()) {
      break;
    }
    byteSegmentRef=hashMapResult.next();
    overflowBatch.reset();
  }
  overflowBatch.reset();
}
