{
  if (useOverflowRepeatedThreshold && hashMapResult.isCappedCountAvailable() && hashMapResult.cappedCount() > overflowRepeatedThreshold) {
    generateHashMapResultLargeMultiValue(batch,hashMapResult,allMatchs,allMatchesIndex,duplicateCount);
    return;
  }
  for (int i=0; i < duplicateCount; i++) {
    int batchIndex=allMatchs[allMatchesIndex + i];
    ByteSegmentRef byteSegmentRef=hashMapResult.first();
    while (byteSegmentRef != null) {
      if (bigTableRetainedVectorCopy != null) {
        bigTableRetainedVectorCopy.copyByValue(batch,batchIndex,overflowBatch,overflowBatch.size);
      }
      if (smallTableVectorDeserializeRow != null) {
        byte[] bytes=byteSegmentRef.getBytes();
        int offset=(int)byteSegmentRef.getOffset();
        int length=byteSegmentRef.getLength();
        smallTableVectorDeserializeRow.setBytes(bytes,offset,length);
        smallTableVectorDeserializeRow.deserializeByValue(overflowBatch,overflowBatch.size);
      }
      overflowBatch.size++;
      if (overflowBatch.size == overflowBatch.DEFAULT_SIZE) {
        forwardOverflow();
      }
      byteSegmentRef=hashMapResult.next();
    }
  }
}
