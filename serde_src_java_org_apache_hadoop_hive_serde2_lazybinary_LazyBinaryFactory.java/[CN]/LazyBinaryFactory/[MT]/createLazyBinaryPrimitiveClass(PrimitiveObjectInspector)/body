{
  PrimitiveCategory p=oi.getPrimitiveCategory();
switch (p) {
case BOOLEAN:
    return new LazyBinaryBoolean((WritableBooleanObjectInspector)oi);
case BYTE:
  return new LazyBinaryByte((WritableByteObjectInspector)oi);
case SHORT:
return new LazyBinaryShort((WritableShortObjectInspector)oi);
case INT:
return new LazyBinaryInteger((WritableIntObjectInspector)oi);
case LONG:
return new LazyBinaryLong((WritableLongObjectInspector)oi);
case FLOAT:
return new LazyBinaryFloat((WritableFloatObjectInspector)oi);
case DOUBLE:
return new LazyBinaryDouble((WritableDoubleObjectInspector)oi);
case STRING:
return new LazyBinaryString((WritableStringObjectInspector)oi);
case CHAR:
return new LazyBinaryHiveChar((WritableHiveCharObjectInspector)oi);
case VARCHAR:
return new LazyBinaryHiveVarchar((WritableHiveVarcharObjectInspector)oi);
case VOID:
return new LazyBinaryVoid((WritableVoidObjectInspector)oi);
case DATE:
return new LazyBinaryDate((WritableDateObjectInspector)oi);
case TIMESTAMP:
return new LazyBinaryTimestamp((WritableTimestampObjectInspector)oi);
case BINARY:
return new LazyBinaryBinary((WritableBinaryObjectInspector)oi);
case DECIMAL:
return new LazyBinaryHiveDecimal((WritableHiveDecimalObjectInspector)oi);
default :
throw new RuntimeException("Internal error: no LazyBinaryObject for " + p);
}
}
