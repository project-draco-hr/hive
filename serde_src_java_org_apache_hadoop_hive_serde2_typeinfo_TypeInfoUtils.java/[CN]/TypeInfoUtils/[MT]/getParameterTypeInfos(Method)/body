{
  Class<?>[] parameterTypes=m.getParameterTypes();
  List<TypeInfo> typeInfos=new ArrayList<TypeInfo>(parameterTypes.length);
  for (int i=0; i < parameterTypes.length; i++) {
    if (PrimitiveObjectInspectorUtils.isPrimitiveWritableClass(parameterTypes[i])) {
      typeInfos.add(TypeInfoFactory.getPrimitiveTypeInfoFromPrimitiveWritable(parameterTypes[i]));
    }
 else     if (PrimitiveObjectInspectorUtils.isPrimitiveJavaClass(parameterTypes[i]) || PrimitiveObjectInspectorUtils.isPrimitiveJavaType(parameterTypes[i])) {
      typeInfos.add(TypeInfoFactory.getPrimitiveTypeInfoFromJavaPrimitive(parameterTypes[i]));
    }
 else     if (Map.class.isAssignableFrom(parameterTypes[i])) {
      typeInfos.add(TypeInfoFactory.unknownMapTypeInfo);
    }
 else     if (List.class.isAssignableFrom(parameterTypes[i])) {
      typeInfos.add(TypeInfoFactory.unknownListTypeInfo);
    }
 else     if (parameterTypes[i].equals(Object.class)) {
      typeInfos.add(TypeInfoFactory.unknownTypeInfo);
    }
 else {
      throw new RuntimeException("Hive does not understand type " + parameterTypes[i] + " from "+ m);
    }
  }
  return typeInfos;
}
