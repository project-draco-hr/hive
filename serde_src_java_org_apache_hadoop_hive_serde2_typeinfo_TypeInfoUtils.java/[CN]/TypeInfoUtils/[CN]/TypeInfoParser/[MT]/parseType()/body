{
  Token t=expect("type");
  Class<?> clazz=ObjectInspectorUtils.typeNameToClass.get(t.text);
  if (clazz != null) {
    return TypeInfoFactory.getPrimitiveTypeInfo(clazz);
  }
  if (Constants.LIST_TYPE_NAME.equals(t.text)) {
    expect("<");
    TypeInfo listElementType=parseType();
    expect(">");
    return TypeInfoFactory.getListTypeInfo(listElementType);
  }
  if (Constants.MAP_TYPE_NAME.equals(t.text)) {
    expect("<");
    TypeInfo mapKeyType=parseType();
    expect(",");
    TypeInfo mapValueType=parseType();
    expect(">");
    return TypeInfoFactory.getMapTypeInfo(mapKeyType,mapValueType);
  }
  if (STRUCT_TYPE_NAME.equals(t.text)) {
    ArrayList<String> fieldNames=new ArrayList<String>();
    ArrayList<TypeInfo> fieldTypeInfos=new ArrayList<TypeInfo>();
    boolean first=true;
    do {
      if (first) {
        expect("<");
        first=false;
      }
 else {
        Token separator=expect(">",",");
        if (separator.text.equals(">")) {
          break;
        }
      }
      Token name=expect("name");
      fieldNames.add(name.text);
      expect(":");
      fieldTypeInfos.add(parseType());
    }
 while (true);
    return TypeInfoFactory.getStructTypeInfo(fieldNames,fieldTypeInfos);
  }
  throw new RuntimeException("Internal error parsing position " + t.position + " of '"+ typeInfoString+ "'");
}
