{
  Token t=expect("type");
  PrimitiveTypeEntry primitiveType=PrimitiveObjectInspectorUtils.getTypeEntryFromTypeName(t.text);
  if (primitiveType != null && !primitiveType.primitiveCategory.equals(PrimitiveCategory.UNKNOWN)) {
    return TypeInfoFactory.getPrimitiveTypeInfo(primitiveType.typeName);
  }
  if (Constants.LIST_TYPE_NAME.equals(t.text)) {
    expect("<");
    TypeInfo listElementType=parseType();
    expect(">");
    return TypeInfoFactory.getListTypeInfo(listElementType);
  }
  if (Constants.MAP_TYPE_NAME.equals(t.text)) {
    expect("<");
    TypeInfo mapKeyType=parseType();
    expect(",");
    TypeInfo mapValueType=parseType();
    expect(">");
    return TypeInfoFactory.getMapTypeInfo(mapKeyType,mapValueType);
  }
  if (Constants.STRUCT_TYPE_NAME.equals(t.text)) {
    ArrayList<String> fieldNames=new ArrayList<String>();
    ArrayList<TypeInfo> fieldTypeInfos=new ArrayList<TypeInfo>();
    boolean first=true;
    do {
      if (first) {
        expect("<");
        first=false;
      }
 else {
        Token separator=expect(">",",");
        if (separator.text.equals(">")) {
          break;
        }
      }
      Token name=expect("name");
      fieldNames.add(name.text);
      expect(":");
      fieldTypeInfos.add(parseType());
    }
 while (true);
    return TypeInfoFactory.getStructTypeInfo(fieldNames,fieldTypeInfos);
  }
  if (Constants.UNION_TYPE_NAME.equals(t.text)) {
    List<TypeInfo> objectTypeInfos=new ArrayList<TypeInfo>();
    boolean first=true;
    do {
      if (first) {
        expect("<");
        first=false;
      }
 else {
        Token separator=expect(">",",");
        if (separator.text.equals(">")) {
          break;
        }
      }
      objectTypeInfos.add(parseType());
    }
 while (true);
    return TypeInfoFactory.getUnionTypeInfo(objectTypeInfos);
  }
  throw new RuntimeException("Internal error parsing position " + t.position + " of '"+ typeInfoString+ "'");
}
