{
  Token t=expect("type");
  PrimitiveTypeEntry typeEntry=PrimitiveObjectInspectorUtils.getTypeEntryFromTypeName(t.text);
  if (typeEntry != null && typeEntry.primitiveCategory != PrimitiveCategory.UNKNOWN) {
    String[] params=parseParams();
switch (typeEntry.primitiveCategory) {
case CHAR:
case VARCHAR:
      if (params == null || params.length == 0) {
        throw new IllegalArgumentException(typeEntry.typeName + " type is specified without length: " + typeInfoString);
      }
    int length=1;
  if (params.length == 1) {
    length=Integer.valueOf(params[0]);
    if (typeEntry.primitiveCategory == PrimitiveCategory.VARCHAR) {
      BaseCharUtils.validateVarcharParameter(length);
      return TypeInfoFactory.getVarcharTypeInfo(length);
    }
 else {
      BaseCharUtils.validateCharParameter(length);
      return TypeInfoFactory.getCharTypeInfo(length);
    }
  }
 else   if (params.length > 1) {
    throw new IllegalArgumentException("Type " + typeEntry.typeName + " only takes one parameter, but "+ params.length+ " is seen");
  }
case DECIMAL:
int precision=HiveDecimal.DEFAULT_PRECISION;
int scale=HiveDecimal.DEFAULT_SCALE;
if (params == null || params.length == 0) {
}
 else if (params.length == 2) {
precision=Integer.valueOf(params[0]);
scale=Integer.valueOf(params[1]);
HiveDecimalUtils.validateParameter(precision,scale);
}
 else if (params.length > 2) {
throw new IllegalArgumentException("Type decimal only takes two parameter, but " + params.length + " is seen");
}
return TypeInfoFactory.getDecimalTypeInfo(precision,scale);
default :
return TypeInfoFactory.getPrimitiveTypeInfo(typeEntry.typeName);
}
}
if (serdeConstants.LIST_TYPE_NAME.equals(t.text)) {
expect("<");
TypeInfo listElementType=parseType();
expect(">");
return TypeInfoFactory.getListTypeInfo(listElementType);
}
if (serdeConstants.MAP_TYPE_NAME.equals(t.text)) {
expect("<");
TypeInfo mapKeyType=parseType();
expect(",");
TypeInfo mapValueType=parseType();
expect(">");
return TypeInfoFactory.getMapTypeInfo(mapKeyType,mapValueType);
}
if (serdeConstants.STRUCT_TYPE_NAME.equals(t.text)) {
ArrayList<String> fieldNames=new ArrayList<String>();
ArrayList<TypeInfo> fieldTypeInfos=new ArrayList<TypeInfo>();
boolean first=true;
do {
if (first) {
expect("<");
first=false;
}
 else {
Token separator=expect(">",",");
if (separator.text.equals(">")) {
break;
}
}
Token name=expect("name");
fieldNames.add(name.text);
expect(":");
fieldTypeInfos.add(parseType());
}
 while (true);
return TypeInfoFactory.getStructTypeInfo(fieldNames,fieldTypeInfos);
}
if (serdeConstants.UNION_TYPE_NAME.equals(t.text)) {
List<TypeInfo> objectTypeInfos=new ArrayList<TypeInfo>();
boolean first=true;
do {
if (first) {
expect("<");
first=false;
}
 else {
Token separator=expect(">",",");
if (separator.text.equals(">")) {
break;
}
}
objectTypeInfos.add(parseType());
}
 while (true);
return TypeInfoFactory.getUnionTypeInfo(objectTypeInfos);
}
throw new RuntimeException("Internal error parsing position " + t.position + " of '"+ typeInfoString+ "'");
}
