{
  Token t=expect("type");
  PrimitiveTypeEntry typeEntry=PrimitiveObjectInspectorUtils.getTypeEntryFromTypeName(t.text);
  if (typeEntry != null && typeEntry.primitiveCategory != PrimitiveCategory.UNKNOWN) {
    String qualifiedTypeName=typeEntry.typeName;
    if (typeEntry.primitiveCategory == PrimitiveCategory.VARCHAR) {
      int length=HiveVarchar.MAX_VARCHAR_LENGTH;
      String[] params=parseParams();
      if (params == null || params.length == 0) {
        throw new RuntimeException("Varchar type is specified without length: " + typeInfoString);
      }
      if (params.length == 1) {
        length=Integer.valueOf(params[0]);
        VarcharUtils.validateParameter(length);
      }
 else       if (params.length > 1) {
        throw new RuntimeException("Type varchar only takes one parameter, but " + params.length + " is seen");
      }
      qualifiedTypeName=BaseCharTypeInfo.getQualifiedName(typeEntry.typeName,length);
    }
    return TypeInfoFactory.getPrimitiveTypeInfo(qualifiedTypeName);
  }
  if (serdeConstants.LIST_TYPE_NAME.equals(t.text)) {
    expect("<");
    TypeInfo listElementType=parseType();
    expect(">");
    return TypeInfoFactory.getListTypeInfo(listElementType);
  }
  if (serdeConstants.MAP_TYPE_NAME.equals(t.text)) {
    expect("<");
    TypeInfo mapKeyType=parseType();
    expect(",");
    TypeInfo mapValueType=parseType();
    expect(">");
    return TypeInfoFactory.getMapTypeInfo(mapKeyType,mapValueType);
  }
  if (serdeConstants.STRUCT_TYPE_NAME.equals(t.text)) {
    ArrayList<String> fieldNames=new ArrayList<String>();
    ArrayList<TypeInfo> fieldTypeInfos=new ArrayList<TypeInfo>();
    boolean first=true;
    do {
      if (first) {
        expect("<");
        first=false;
      }
 else {
        Token separator=expect(">",",");
        if (separator.text.equals(">")) {
          break;
        }
      }
      Token name=expect("name");
      fieldNames.add(name.text);
      expect(":");
      fieldTypeInfos.add(parseType());
    }
 while (true);
    return TypeInfoFactory.getStructTypeInfo(fieldNames,fieldTypeInfos);
  }
  if (serdeConstants.UNION_TYPE_NAME.equals(t.text)) {
    List<TypeInfo> objectTypeInfos=new ArrayList<TypeInfo>();
    boolean first=true;
    do {
      if (first) {
        expect("<");
        first=false;
      }
 else {
        Token separator=expect(">",",");
        if (separator.text.equals(">")) {
          break;
        }
      }
      objectTypeInfos.add(parseType());
    }
 while (true);
    return TypeInfoFactory.getUnionTypeInfo(objectTypeInfos);
  }
  throw new RuntimeException("Internal error parsing position " + t.position + " of '"+ typeInfoString+ "'");
}
