{
  conf=new JobConf();
  List<String> columnNames=Arrays.asList("field1","field2","rid");
  List<TypeInfo> columnTypes=Arrays.<TypeInfo>asList(TypeInfoFactory.stringTypeInfo,TypeInfoFactory.intTypeInfo,TypeInfoFactory.stringTypeInfo);
  conf.set(serdeConstants.LIST_COLUMNS,Joiner.on(',').join(columnNames));
  conf.set(serdeConstants.LIST_COLUMN_TYPES,"string,int,string");
  String columnMappingStr="cf:f1,cf:f2,:rowID";
  conf.set(AccumuloSerDeParameters.COLUMN_MAPPINGS,columnMappingStr);
  columnMapper=new ColumnMapper(columnMappingStr,ColumnEncoding.STRING.getName(),columnNames,columnTypes);
  ExprNodeDesc column=new ExprNodeColumnDesc(TypeInfoFactory.stringTypeInfo,"field1",null,false);
  ExprNodeDesc constant=new ExprNodeConstantDesc(TypeInfoFactory.stringTypeInfo,"aaa");
  List<ExprNodeDesc> children=Lists.newArrayList();
  children.add(column);
  children.add(constant);
  ExprNodeDesc node=new ExprNodeGenericFuncDesc(TypeInfoFactory.stringTypeInfo,new GenericUDFOPEqualOrLessThan(),children);
  assertNotNull(node);
  ExprNodeDesc column2=new ExprNodeColumnDesc(TypeInfoFactory.intTypeInfo,"field2",null,false);
  ExprNodeDesc constant2=new ExprNodeConstantDesc(TypeInfoFactory.intTypeInfo,5);
  List<ExprNodeDesc> children2=Lists.newArrayList();
  children2.add(column2);
  children2.add(constant2);
  ExprNodeDesc node2=new ExprNodeGenericFuncDesc(TypeInfoFactory.stringTypeInfo,new GenericUDFOPGreaterThan(),children2);
  assertNotNull(node2);
  List<ExprNodeDesc> bothFilters=Lists.newArrayList();
  bothFilters.add(node);
  bothFilters.add(node2);
  ExprNodeGenericFuncDesc both=new ExprNodeGenericFuncDesc(TypeInfoFactory.stringTypeInfo,new GenericUDFOPAnd(),bothFilters);
  String filterExpr=Utilities.serializeExpression(both);
  conf.set(TableScanDesc.FILTER_EXPR_CONF_STR,filterExpr);
  List<IteratorSetting> iterators=handler.getIterators(conf,columnMapper);
  assertEquals(iterators.size(),2);
  IteratorSetting is1=iterators.get(0);
  IteratorSetting is2=iterators.get(1);
  boolean foundQual=false;
  boolean foundPCompare=false;
  boolean foundCOpt=false;
  boolean foundConst=false;
  for (  Map.Entry<String,String> option : is1.getOptions().entrySet()) {
    String optKey=option.getKey();
    if (optKey.equals(PrimitiveComparisonFilter.COLUMN)) {
      foundQual=true;
      assertEquals(option.getValue(),"cf:f1");
    }
 else     if (optKey.equals(PrimitiveComparisonFilter.CONST_VAL)) {
      foundConst=true;
      assertEquals(option.getValue(),new String(Base64.encodeBase64("aaa".getBytes())));
    }
 else     if (optKey.equals(PrimitiveComparisonFilter.COMPARE_OPT_CLASS)) {
      foundCOpt=true;
      assertEquals(option.getValue(),LessThanOrEqual.class.getName());
    }
 else     if (optKey.equals(PrimitiveComparisonFilter.P_COMPARE_CLASS)) {
      foundPCompare=true;
      assertEquals(option.getValue(),StringCompare.class.getName());
    }
  }
  assertTrue(foundConst & foundCOpt & foundPCompare& foundQual);
  foundQual=false;
  foundPCompare=false;
  foundCOpt=false;
  foundConst=false;
  for (  Map.Entry<String,String> option : is2.getOptions().entrySet()) {
    String optKey=option.getKey();
    if (optKey.equals(PrimitiveComparisonFilter.COLUMN)) {
      foundQual=true;
      assertEquals(option.getValue(),"cf:f2");
    }
 else     if (optKey.equals(PrimitiveComparisonFilter.CONST_VAL)) {
      foundConst=true;
      byte[] intVal=new byte[4];
      ByteBuffer.wrap(intVal).putInt(5);
      assertEquals(option.getValue(),new String(Base64.encodeBase64(intVal)));
    }
 else     if (optKey.equals(PrimitiveComparisonFilter.COMPARE_OPT_CLASS)) {
      foundCOpt=true;
      assertEquals(option.getValue(),GreaterThan.class.getName());
    }
 else     if (optKey.equals(PrimitiveComparisonFilter.P_COMPARE_CLASS)) {
      foundPCompare=true;
      assertEquals(option.getValue(),IntCompare.class.getName());
    }
  }
  assertTrue(foundConst & foundCOpt & foundPCompare& foundQual);
}
