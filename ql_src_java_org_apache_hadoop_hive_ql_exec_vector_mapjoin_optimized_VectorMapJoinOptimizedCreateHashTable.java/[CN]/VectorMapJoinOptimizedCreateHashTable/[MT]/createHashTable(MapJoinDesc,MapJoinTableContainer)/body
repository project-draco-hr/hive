{
  MapJoinKey refKey=mapJoinTableContainer.getAnyKey();
  ReusableGetAdaptor hashMapRowGetter=mapJoinTableContainer.createGetter(refKey);
  boolean isOuterJoin=!desc.isNoOuterJoin();
  VectorMapJoinDesc vectorDesc=desc.getVectorDesc();
  HashTableKind hashTableKind=vectorDesc.hashTableKind();
  HashTableKeyType hashTableKeyType=vectorDesc.hashTableKeyType();
  boolean minMaxEnabled=vectorDesc.minMaxEnabled();
  VectorMapJoinOptimizedHashTable hashTable=null;
switch (hashTableKeyType) {
case BOOLEAN:
case BYTE:
case SHORT:
case INT:
case LONG:
switch (hashTableKind) {
case HASH_MAP:
      hashTable=new VectorMapJoinOptimizedLongHashMap(minMaxEnabled,isOuterJoin,hashTableKeyType,mapJoinTableContainer,hashMapRowGetter);
    break;
case HASH_MULTISET:
  hashTable=new VectorMapJoinOptimizedLongHashMultiSet(minMaxEnabled,isOuterJoin,hashTableKeyType,mapJoinTableContainer,hashMapRowGetter);
break;
case HASH_SET:
hashTable=new VectorMapJoinOptimizedLongHashSet(minMaxEnabled,isOuterJoin,hashTableKeyType,mapJoinTableContainer,hashMapRowGetter);
break;
}
break;
case STRING:
switch (hashTableKind) {
case HASH_MAP:
hashTable=new VectorMapJoinOptimizedStringHashMap(isOuterJoin,mapJoinTableContainer,hashMapRowGetter);
break;
case HASH_MULTISET:
hashTable=new VectorMapJoinOptimizedStringHashMultiSet(isOuterJoin,mapJoinTableContainer,hashMapRowGetter);
break;
case HASH_SET:
hashTable=new VectorMapJoinOptimizedStringHashSet(isOuterJoin,mapJoinTableContainer,hashMapRowGetter);
break;
}
break;
case MULTI_KEY:
switch (hashTableKind) {
case HASH_MAP:
hashTable=new VectorMapJoinOptimizedMultiKeyHashMap(isOuterJoin,mapJoinTableContainer,hashMapRowGetter);
break;
case HASH_MULTISET:
hashTable=new VectorMapJoinOptimizedMultiKeyHashMultiSet(isOuterJoin,mapJoinTableContainer,hashMapRowGetter);
break;
case HASH_SET:
hashTable=new VectorMapJoinOptimizedMultiKeyHashSet(isOuterJoin,mapJoinTableContainer,hashMapRowGetter);
break;
}
break;
}
return hashTable;
}
