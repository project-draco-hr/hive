{
  LinkedList<DiskRange> result=new LinkedList<DiskRange>();
  long offset=0;
  boolean[] hasNull=new boolean[types.size()];
  for (  OrcProto.Stream stream : streamList) {
    if (stream.getKind() == OrcProto.Stream.Kind.PRESENT) {
      hasNull[stream.getColumn()]=true;
    }
  }
  for (  OrcProto.Stream stream : streamList) {
    long length=stream.getLength();
    int column=stream.getColumn();
    OrcProto.Stream.Kind streamKind=stream.getKind();
    if (StreamName.getArea(streamKind) == StreamName.Area.DATA && includedColumns[column]) {
      if (includedRowGroups == null || isDictionary(streamKind,encodings.get(column))) {
        result.add(new DiskRange(offset,offset + length));
      }
 else {
        DiskRange lastRange=null;
        for (int group=0; group < includedRowGroups.length; ++group) {
          if (includedRowGroups[group]) {
            int posn=getIndexPosition(encodings.get(column).getKind(),types.get(column).getKind(),stream.getKind(),isCompressed,hasNull[column]);
            long start=indexes[column].getEntry(group).getPositions(posn);
            final long nextGroupOffset;
            if (group < includedRowGroups.length - 1) {
              nextGroupOffset=indexes[column].getEntry(group + 1).getPositions(posn);
            }
 else {
              nextGroupOffset=length;
            }
            final long slop=isCompressed ? 2 * (OutStream.HEADER_SIZE + compressionSize) : WORST_UNCOMPRESSED_SLOP;
            long end=(group == includedRowGroups.length - 1) ? length : Math.min(length,nextGroupOffset + slop);
            start+=offset;
            end+=offset;
            if (lastRange != null && overlap(lastRange.offset,lastRange.end,start,end)) {
              lastRange.offset=Math.min(lastRange.offset,start);
              lastRange.end=Math.max(lastRange.end,end);
            }
 else {
              lastRange=new DiskRange(start,end);
              result.add(lastRange);
            }
          }
        }
      }
    }
    offset+=length;
  }
  return result;
}
