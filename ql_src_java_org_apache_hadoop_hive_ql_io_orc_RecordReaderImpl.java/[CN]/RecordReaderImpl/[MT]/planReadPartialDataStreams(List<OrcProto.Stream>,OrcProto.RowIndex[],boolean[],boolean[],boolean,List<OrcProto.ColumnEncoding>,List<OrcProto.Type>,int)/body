{
  List<DiskRange> result=new ArrayList<DiskRange>();
  long offset=0;
  boolean[] hasNull=new boolean[types.size()];
  for (  OrcProto.Stream stream : streamList) {
    if (stream.hasKind() && (stream.getKind() == OrcProto.Stream.Kind.PRESENT)) {
      hasNull[stream.getColumn()]=true;
    }
  }
  for (  OrcProto.Stream stream : streamList) {
    long length=stream.getLength();
    int column=stream.getColumn();
    OrcProto.Stream.Kind streamKind=stream.getKind();
    if (stream.hasKind() && (StreamName.getArea(streamKind) == StreamName.Area.DATA) && includedColumns[column]) {
      if (includedRowGroups == null || isDictionary(streamKind,encodings.get(column))) {
        result.add(new DiskRange(offset,offset + length));
      }
 else {
        for (int group=0; group < includedRowGroups.length; ++group) {
          if (includedRowGroups[group]) {
            int posn=getIndexPosition(encodings.get(column).getKind(),types.get(column).getKind(),stream.getKind(),isCompressed,hasNull[column]);
            long start=indexes[column].getEntry(group).getPositions(posn);
            final long nextGroupOffset;
            if (group < includedRowGroups.length - 1) {
              nextGroupOffset=indexes[column].getEntry(group + 1).getPositions(posn);
            }
 else {
              nextGroupOffset=length;
            }
            final long slop=isCompressed ? 2 * (OutStream.HEADER_SIZE + compressionSize) : WORST_UNCOMPRESSED_SLOP;
            long end=(group == includedRowGroups.length - 1) ? length : Math.min(length,nextGroupOffset + slop);
            result.add(new DiskRange(offset + start,offset + end));
          }
        }
      }
    }
    offset+=length;
  }
  return result;
}
