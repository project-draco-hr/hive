{
  OrcProto.Type type=types.get(columnId);
switch (type.getKind()) {
case BOOLEAN:
    return new BooleanTreeReader(path,columnId,conf);
case BYTE:
  return new ByteTreeReader(path,columnId,conf);
case DOUBLE:
return new DoubleTreeReader(path,columnId,conf);
case FLOAT:
return new FloatTreeReader(path,columnId,conf);
case SHORT:
return new ShortTreeReader(path,columnId,conf);
case INT:
return new IntTreeReader(path,columnId,conf);
case LONG:
return new LongTreeReader(path,columnId,conf);
case STRING:
return new StringTreeReader(path,columnId,conf);
case CHAR:
if (!type.hasMaximumLength()) {
throw new IllegalArgumentException("ORC char type has no length specified");
}
return new CharTreeReader(path,columnId,type.getMaximumLength(),conf);
case VARCHAR:
if (!type.hasMaximumLength()) {
throw new IllegalArgumentException("ORC varchar type has no length specified");
}
return new VarcharTreeReader(path,columnId,type.getMaximumLength(),conf);
case BINARY:
return new BinaryTreeReader(path,columnId,conf);
case TIMESTAMP:
return new TimestampTreeReader(path,columnId,conf);
case DATE:
return new DateTreeReader(path,columnId,conf);
case DECIMAL:
int precision=type.hasPrecision() ? type.getPrecision() : HiveDecimal.SYSTEM_DEFAULT_PRECISION;
int scale=type.hasScale() ? type.getScale() : HiveDecimal.SYSTEM_DEFAULT_SCALE;
return new DecimalTreeReader(path,columnId,precision,scale,conf);
case STRUCT:
return new StructTreeReader(path,columnId,types,included,conf);
case LIST:
return new ListTreeReader(path,columnId,types,included,conf);
case MAP:
return new MapTreeReader(path,columnId,types,included,conf);
case UNION:
return new UnionTreeReader(path,columnId,types,included,conf);
default :
throw new IllegalArgumentException("Unsupported type " + type.getKind());
}
}
