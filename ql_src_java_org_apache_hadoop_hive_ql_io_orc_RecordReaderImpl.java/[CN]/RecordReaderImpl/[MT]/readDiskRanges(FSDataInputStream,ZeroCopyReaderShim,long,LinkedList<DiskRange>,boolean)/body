{
  ListIterator<DiskRange> rangeIter=ranges.listIterator();
  while (rangeIter.hasNext()) {
    DiskRange range=rangeIter.next();
    if (range.hasData())     continue;
    int len=(int)(range.end - range.offset);
    long off=range.offset;
    file.seek(base + off);
    if (zcr != null) {
      boolean hasReplaced=false;
      while (len > 0) {
        ByteBuffer partial=zcr.readBuffer(len,false);
        BufferChunk bc=new BufferChunk(partial,off);
        if (!hasReplaced) {
          rangeIter.set(bc);
          hasReplaced=true;
        }
 else {
          rangeIter.add(bc);
        }
        int read=partial.remaining();
        len-=read;
        off+=read;
      }
    }
 else     if (doForceDirect) {
      ByteBuffer directBuf=ByteBuffer.allocateDirect(len);
      try {
        while (directBuf.remaining() > 0) {
          int count=file.read(directBuf);
          if (count < 0)           throw new EOFException();
          directBuf.position(directBuf.position() + count);
        }
      }
 catch (      UnsupportedOperationException ex) {
        LOG.error("Stream does not support direct read; we will copy.");
        byte[] buffer=new byte[len];
        file.readFully(buffer,0,buffer.length);
        directBuf.put(buffer);
      }
      directBuf.position(0);
      rangeIter.set(new BufferChunk(directBuf,range.offset));
    }
 else {
      byte[] buffer=new byte[len];
      file.readFully(buffer,0,buffer.length);
      rangeIter.set(new BufferChunk(ByteBuffer.wrap(buffer),range.offset));
    }
  }
}
