{
  StripeInformation stripe=stripes.get(currentStripe);
  List<OrcProto.Stream> streamList=this.streamList != null ? this.streamList : stripeFooter.getStreamsList();
  List<ColumnEncoding> encodings=this.encodings != null ? this.encodings : stripeFooter.getColumnsList();
  LinkedList<DiskRange> rangesToRead=new LinkedList<DiskRange>();
  long offset=0;
  boolean[] hasNull=findPresentStreamsByColumn(streamList,types);
  DiskRange lastRange=null;
  int colRgIx=-1, lastColIx=-1;
  ColumnReadContext[] colCtxs=new ColumnReadContext[colRgs.length];
  boolean[] includedRgs=null;
  for (  OrcProto.Stream stream : streamList) {
    long length=stream.getLength();
    int colIx=stream.getColumn();
    OrcProto.Stream.Kind streamKind=stream.getKind();
    if (!included[colIx] || StreamName.getArea(streamKind) != StreamName.Area.DATA) {
      offset+=length;
      continue;
    }
    if (lastColIx != colIx) {
      ++colRgIx;
      lastColIx=colIx;
      includedRgs=colRgs[colRgIx];
      colCtxs[colRgIx]=new ColumnReadContext(offset,colIx,encodings.get(colIx),indexes[colIx]);
    }
    colCtxs[colRgIx].addStream(offset,stream);
    if (includedRgs == null || isDictionary(streamKind,encodings.get(colIx))) {
      lastRange=addEntireStreamToResult(offset,length,lastRange,rangesToRead);
    }
 else {
      lastRange=addRgFilteredStreamToResult(stream,includedRgs,codec != null,indexes[colIx],encodings.get(colIx),types.get(colIx),bufferSize,hasNull[colIx],offset,length,lastRange,rangesToRead);
    }
    offset+=length;
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("chunks = " + stringifyDiskRanges(rangesToRead));
  }
  mergeDiskRanges(rangesToRead);
  if (this.cache != null) {
    cache.getFileData(fileName,rangesToRead);
  }
  readDiskRanges(file,zcr,stripe.getOffset(),rangesToRead);
  for (  ColumnReadContext colCtx : colCtxs) {
    colCtx.buffers=new List[colCtx.streamCount];
    for (int i=0; i < colCtx.streamCount; ++i) {
      colCtx.buffers[i]=getStreamBuffers(rangesToRead,colCtx.streamOffsets[i],colCtx.streams[i]);
      colCtx.bufferIters[i]=colCtx.buffers[i].listIterator();
    }
  }
  int rgCount=(int)Math.ceil((double)rowCountInStripe / rowIndexStride);
  for (int rgIx=0; rgIx < rgCount; ++rgIx) {
    boolean isLastRg=rgIx == rgCount - 1;
    EncodedColumnBatch<OrcBatchKey> ecb=new EncodedColumnBatch<OrcBatchKey>(new OrcBatchKey(fileName,stripeIx,rgIx),colRgs.length,0);
    for (int colIxMod=0; colIxMod < colRgs.length; ++colIxMod) {
      if (colRgs[colIxMod] != null && !colRgs[colIxMod][rgIx])       continue;
      ColumnReadContext ctx=colCtxs[colIxMod];
      RowIndexEntry index=indexes[ctx.colIx].getEntry(rgIx);
      ecb.initColumn(colIxMod,ctx.colIx,ctx.streamCount);
      for (int streamIx=0; streamIx < ctx.streamCount; ++streamIx) {
        OrcProto.Stream stream=ctx.streams[streamIx];
        StreamBuffer cb=null;
        if (isStripeLevelStream(stream.getKind(),ctx.encoding.getKind())) {
          if (ctx.stripeLevelStreams == null) {
            ctx.stripeLevelStreams=new StreamBuffer[ctx.streamCount];
          }
          cb=ctx.stripeLevelStreams[streamIx];
          if (cb == null) {
            cb=ctx.stripeLevelStreams[streamIx]=new StreamBuffer();
            cb.incRef();
            InStream.uncompressStream(fileName,zcr,ctx.bufferIters[streamIx],codec,bufferSize,cache,-1,-1,cb);
            ctx.buffers[streamIx]=null;
          }
          if (!isLastRg) {
            cb.incRef();
          }
        }
 else {
          long cOffset=0, nextCOffset=0, nextNextCOffset=0;
          int nextUcOffset=0;
          cb=new StreamBuffer();
          cb.incRef();
          long startCOffset=cOffset;
          long endCOffset=(nextUcOffset == 0) ? nextCOffset : nextNextCOffset;
          InStream.uncompressStream(fileName,zcr,ctx.bufferIters[streamIx],codec,bufferSize,cache,startCOffset,endCOffset,cb);
        }
        ecb.setStreamData(colIxMod,streamIx,cb);
      }
      consumer.consumeData(ecb);
    }
  }
  throw new UnsupportedOperationException("not implemented");
}
