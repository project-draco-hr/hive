{
  if (stream == OrcProto.Stream.Kind.PRESENT) {
    return 0;
  }
  int compressionValue=isCompressed ? 1 : 0;
  int base=hasNulls ? (BITFIELD_POSITIONS + compressionValue) : 0;
switch (type) {
case BOOLEAN:
case BYTE:
case SHORT:
case INT:
case LONG:
case FLOAT:
case DOUBLE:
case DATE:
case STRUCT:
case MAP:
case LIST:
case UNION:
    return base;
case STRING:
  if (encoding == OrcProto.ColumnEncoding.Kind.DICTIONARY || encoding == OrcProto.ColumnEncoding.Kind.DICTIONARY_V2) {
    return base;
  }
 else {
    if (stream == OrcProto.Stream.Kind.DATA) {
      return base;
    }
 else {
      return base + BYTE_STREAM_POSITIONS + compressionValue;
    }
  }
case BINARY:
if (stream == OrcProto.Stream.Kind.DATA) {
  return base;
}
return base + BYTE_STREAM_POSITIONS + compressionValue;
case DECIMAL:
if (stream == OrcProto.Stream.Kind.DATA) {
return base;
}
return base + BYTE_STREAM_POSITIONS + compressionValue;
case TIMESTAMP:
if (stream == OrcProto.Stream.Kind.DATA) {
return base;
}
return base + RUN_LENGTH_INT_POSITIONS + compressionValue;
default :
throw new IllegalArgumentException("Unknown type " + type);
}
}
