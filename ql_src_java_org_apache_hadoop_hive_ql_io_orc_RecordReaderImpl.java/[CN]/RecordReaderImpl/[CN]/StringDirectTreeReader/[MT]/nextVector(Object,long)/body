{
  BytesColumnVector result=null;
  if (previousVector == null) {
    result=new BytesColumnVector();
  }
 else {
    result=(BytesColumnVector)previousVector;
  }
  super.nextVector(result,batchSize);
  scratchlcv.isNull=result.isNull;
  lengths.nextVector(scratchlcv,batchSize);
  int totalLength=0;
  if (!scratchlcv.isRepeating) {
    for (int i=0; i < batchSize; i++) {
      if (!scratchlcv.isNull[i]) {
        totalLength+=(int)scratchlcv.vector[i];
      }
    }
  }
 else {
    if (!scratchlcv.isNull[0]) {
      totalLength=(int)(batchSize * scratchlcv.vector[0]);
    }
  }
  byte[] allBytes=new byte[totalLength];
  int offset=0;
  int len=totalLength;
  while (len > 0) {
    int bytesRead=stream.read(allBytes,offset,len);
    if (bytesRead < 0) {
      throw new EOFException("Can't finish byte read from " + stream);
    }
    len-=bytesRead;
    offset+=bytesRead;
  }
  result.isRepeating=false;
  offset=0;
  if (!scratchlcv.isRepeating) {
    for (int i=0; i < batchSize; i++) {
      if (!scratchlcv.isNull[i]) {
        result.setRef(i,allBytes,offset,(int)scratchlcv.vector[i]);
        offset+=scratchlcv.vector[i];
      }
 else {
        result.setRef(i,allBytes,0,0);
      }
    }
  }
 else {
    for (int i=0; i < batchSize; i++) {
      if (!scratchlcv.isNull[i]) {
        result.setRef(i,allBytes,offset,(int)scratchlcv.vector[0]);
        offset+=scratchlcv.vector[0];
      }
 else {
        result.setRef(i,allBytes,0,0);
      }
    }
  }
  return result;
}
