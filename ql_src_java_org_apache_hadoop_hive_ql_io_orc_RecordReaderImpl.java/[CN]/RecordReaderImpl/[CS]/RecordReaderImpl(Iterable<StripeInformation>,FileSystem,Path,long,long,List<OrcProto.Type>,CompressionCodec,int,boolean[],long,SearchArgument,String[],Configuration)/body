{
  this.file=fileSystem.open(path);
  this.codec=codec;
  this.types=types;
  this.bufferSize=bufferSize;
  this.included=included;
  this.conf=conf;
  this.sarg=sarg;
  if (sarg != null) {
    sargLeaves=sarg.getLeaves();
    filterColumns=new int[sargLeaves.size()];
    for (int i=0; i < filterColumns.length; ++i) {
      String colName=sargLeaves.get(i).getColumnName();
      filterColumns[i]=findColumns(columnNames,colName);
    }
  }
 else {
    sargLeaves=null;
    filterColumns=null;
  }
  long rows=0;
  long skippedRows=0;
  for (  StripeInformation stripe : stripes) {
    long stripeStart=stripe.getOffset();
    if (offset > stripeStart) {
      skippedRows+=stripe.getNumberOfRows();
    }
 else     if (stripeStart < offset + length) {
      this.stripes.add(stripe);
      rows+=stripe.getNumberOfRows();
    }
  }
  final boolean zeroCopy=(conf != null) && (HiveConf.getBoolVar(conf,HIVE_ORC_ZEROCOPY));
  if (zeroCopy && (codec == null || ((codec instanceof DirectDecompressionCodec) && ((DirectDecompressionCodec)codec).isAvailable()))) {
    this.zcr=ShimLoader.getHadoopShims().getZeroCopyReader(file,pool);
  }
 else {
    this.zcr=null;
  }
  firstRow=skippedRows;
  totalRowCount=rows;
  reader=createTreeReader(path,0,types,included,conf);
  indexes=new OrcProto.RowIndex[types.size()];
  rowIndexStride=strideRate;
  advanceToNextRow(0L);
}
