{
  SchemaEvolution treeReaderSchema;
  this.included=options.getInclude();
  included[0]=true;
  if (options.getSchema() == null) {
    if (LOG.isInfoEnabled()) {
      LOG.info("Schema on read not provided -- using file schema " + types.toString());
    }
    treeReaderSchema=new SchemaEvolution(fileSchema,included);
  }
 else {
    treeReaderSchema=new SchemaEvolution(fileSchema,options.getSchema(),included);
  }
  this.path=path;
  this.codec=codec;
  this.types=types;
  this.bufferSize=bufferSize;
  this.rowIndexStride=strideRate;
  this.metadata=new MetadataReaderImpl(fileSystem,path,codec,bufferSize,types.size());
  SearchArgument sarg=options.getSearchArgument();
  if (sarg != null && strideRate != 0) {
    sargApp=new SargApplier(sarg,options.getColumnNames(),strideRate,types,included.length);
  }
 else {
    sargApp=null;
  }
  long rows=0;
  long skippedRows=0;
  long offset=options.getOffset();
  long maxOffset=options.getMaxOffset();
  for (  StripeInformation stripe : stripes) {
    long stripeStart=stripe.getOffset();
    if (offset > stripeStart) {
      skippedRows+=stripe.getNumberOfRows();
    }
 else     if (stripeStart < maxOffset) {
      this.stripes.add(stripe);
      rows+=stripe.getNumberOfRows();
    }
  }
  Boolean zeroCopy=options.getUseZeroCopy();
  if (zeroCopy == null) {
    zeroCopy=OrcConf.USE_ZEROCOPY.getBoolean(conf);
  }
  this.dataReader=RecordReaderUtils.createDefaultDataReader(fileSystem,path,zeroCopy,codec);
  this.dataReader.open();
  firstRow=skippedRows;
  totalRowCount=rows;
  Boolean skipCorrupt=options.getSkipCorruptRecords();
  if (skipCorrupt == null) {
    skipCorrupt=OrcConf.SKIP_CORRUPT_DATA.getBoolean(conf);
  }
  reader=TreeReaderFactory.createTreeReader(treeReaderSchema.getReaderSchema(),treeReaderSchema,included,skipCorrupt);
  indexes=new OrcProto.RowIndex[types.size()];
  bloomFilterIndices=new OrcProto.BloomFilterIndex[types.size()];
  advanceToNextRow(reader,0L,true);
}
