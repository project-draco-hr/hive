{
  this.path=path;
  this.file=fileSystem.open(path);
  this.codec=codec;
  this.types=types;
  this.bufferSize=bufferSize;
  this.included=options.getInclude();
  this.conf=conf;
  this.sarg=options.getSearchArgument();
  if (sarg != null) {
    sargLeaves=sarg.getLeaves();
    filterColumns=mapSargColumns(sargLeaves,options.getColumnNames(),0);
    sargColumns=new boolean[included.length];
    for (    int i : filterColumns) {
      if (i > 0) {
        sargColumns[i]=true;
      }
    }
  }
 else {
    sargLeaves=null;
    filterColumns=null;
    sargColumns=null;
  }
  long rows=0;
  long skippedRows=0;
  long offset=options.getOffset();
  long maxOffset=options.getMaxOffset();
  for (  StripeInformation stripe : stripes) {
    long stripeStart=stripe.getOffset();
    if (offset > stripeStart) {
      skippedRows+=stripe.getNumberOfRows();
    }
 else     if (stripeStart < maxOffset) {
      this.stripes.add(stripe);
      rows+=stripe.getNumberOfRows();
    }
  }
  final boolean zeroCopy=(conf != null) && (HiveConf.getBoolVar(conf,HIVE_ORC_ZEROCOPY));
  if (zeroCopy && (codec == null || ((codec instanceof DirectDecompressionCodec) && ((DirectDecompressionCodec)codec).isAvailable()))) {
    this.zcr=ShimLoader.getHadoopShims().getZeroCopyReader(file,pool);
  }
 else {
    this.zcr=null;
  }
  firstRow=skippedRows;
  totalRowCount=rows;
  reader=createTreeReader(path,0,types,included,conf);
  indexes=new OrcProto.RowIndex[types.size()];
  bloomFilterIndices=new OrcProto.BloomFilterIndex[types.size()];
  rowIndexStride=strideRate;
  advanceToNextRow(0L);
}
