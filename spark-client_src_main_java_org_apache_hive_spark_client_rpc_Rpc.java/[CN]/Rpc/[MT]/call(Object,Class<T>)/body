{
  Preconditions.checkArgument(msg != null);
  Preconditions.checkState(channel.isActive(),"RPC channel is closed.");
  try {
    final long id=rpcId.getAndIncrement();
    final Promise<T> promise=createPromise();
    ChannelFutureListener listener=new ChannelFutureListener(){
      @Override public void operationComplete(      ChannelFuture cf){
        if (!cf.isSuccess() && !promise.isDone()) {
          promise.setFailure(cf.cause());
          dispatcher.get().discardRpc(id);
        }
      }
    }
;
    dispatcher.get().registerRpc(id,promise,msg.getClass().getName());
synchronized (channelLock) {
      channel.write(new MessageHeader(id,Rpc.MessageType.CALL)).addListener(listener);
      channel.writeAndFlush(msg).addListener(listener);
    }
    return promise;
  }
 catch (  Exception e) {
    throw Throwables.propagate(e);
  }
}
