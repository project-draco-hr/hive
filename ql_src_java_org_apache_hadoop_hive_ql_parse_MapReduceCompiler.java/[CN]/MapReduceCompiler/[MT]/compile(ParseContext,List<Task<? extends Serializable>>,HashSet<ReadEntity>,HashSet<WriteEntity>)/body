{
  Context ctx=pCtx.getContext();
  GlobalLimitCtx globalLimitCtx=pCtx.getGlobalLimitCtx();
  QB qb=pCtx.getQB();
  List<Task<MoveWork>> mvTask=new ArrayList<Task<MoveWork>>();
  List<LoadTableDesc> loadTableWork=pCtx.getLoadTableWork();
  List<LoadFileDesc> loadFileWork=pCtx.getLoadFileWork();
  boolean isCStats=qb.isAnalyzeRewrite();
  if (pCtx.getFetchTask() != null) {
    return;
  }
  if (pCtx.getQB().getIsQuery() && !isCStats) {
    if ((!loadTableWork.isEmpty()) || (loadFileWork.size() != 1)) {
      throw new SemanticException(ErrorMsg.GENERIC_ERROR.getMsg());
    }
    LoadFileDesc loadFileDesc=loadFileWork.get(0);
    String cols=loadFileDesc.getColumns();
    String colTypes=loadFileDesc.getColumnTypes();
    TableDesc resultTab=pCtx.getFetchTabledesc();
    if (resultTab == null) {
      String resFileFormat=HiveConf.getVar(conf,HiveConf.ConfVars.HIVEQUERYRESULTFILEFORMAT);
      resultTab=PlanUtils.getDefaultQueryOutputTableDesc(cols,colTypes,resFileFormat);
    }
    FetchWork fetch=new FetchWork(new Path(loadFileDesc.getSourceDir()).toString(),resultTab,qb.getParseInfo().getOuterQueryLimit());
    fetch.setSource(pCtx.getFetchSource());
    fetch.setSink(pCtx.getFetchSink());
    pCtx.setFetchTask((FetchTask)TaskFactory.get(fetch,conf));
    int fetchLimit=HiveConf.getIntVar(conf,HiveConf.ConfVars.HIVELIMITOPTMAXFETCH);
    if (globalLimitCtx.isEnable() && globalLimitCtx.getGlobalLimit() > fetchLimit) {
      LOG.info("For FetchTask, LIMIT " + globalLimitCtx.getGlobalLimit() + " > "+ fetchLimit+ ". Doesn't qualify limit optimiztion.");
      globalLimitCtx.disableOpt();
    }
  }
 else   if (!isCStats) {
    for (    LoadTableDesc ltd : loadTableWork) {
      Task<MoveWork> tsk=TaskFactory.get(new MoveWork(null,null,ltd,null,false),conf);
      mvTask.add(tsk);
      if (HiveConf.getBoolVar(conf,HiveConf.ConfVars.HIVEINDEXAUTOUPDATE)) {
        IndexUpdater indexUpdater=new IndexUpdater(loadTableWork,inputs,conf);
        try {
          List<Task<? extends Serializable>> indexUpdateTasks=indexUpdater.generateUpdateTasks();
          for (          Task<? extends Serializable> updateTask : indexUpdateTasks) {
            tsk.addDependentTask(updateTask);
          }
        }
 catch (        HiveException e) {
          console.printInfo("WARNING: could not auto-update stale indexes, which are not in sync");
        }
      }
    }
    boolean oneLoadFile=true;
    for (    LoadFileDesc lfd : loadFileWork) {
      if (qb.isCTAS()) {
        assert(oneLoadFile);
        String location=qb.getTableDesc().getLocation();
        if (location == null) {
          Table dumpTable;
          Path targetPath;
          try {
            dumpTable=db.newTable(qb.getTableDesc().getTableName());
            if (!db.databaseExists(dumpTable.getDbName())) {
              throw new SemanticException("ERROR: The database " + dumpTable.getDbName() + " does not exist.");
            }
            Warehouse wh=new Warehouse(conf);
            targetPath=wh.getTablePath(db.getDatabase(dumpTable.getDbName()),dumpTable.getTableName());
          }
 catch (          HiveException e) {
            throw new SemanticException(e);
          }
catch (          MetaException e) {
            throw new SemanticException(e);
          }
          location=targetPath.toString();
        }
        lfd.setTargetDir(location);
        oneLoadFile=false;
      }
      mvTask.add(TaskFactory.get(new MoveWork(null,null,null,lfd,false),conf));
    }
  }
  ParseContext tempParseContext=getParseContext(pCtx,rootTasks);
  GenMRProcContext procCtx=new GenMRProcContext(conf,new HashMap<Operator<? extends OperatorDesc>,Task<? extends Serializable>>(),tempParseContext,mvTask,rootTasks,new LinkedHashMap<Operator<? extends OperatorDesc>,GenMapRedCtx>(),inputs,outputs);
  Map<Rule,NodeProcessor> opRules=new LinkedHashMap<Rule,NodeProcessor>();
  opRules.put(new RuleRegExp(new String("R1"),TableScanOperator.getOperatorName() + "%"),new GenMRTableScan1());
  opRules.put(new RuleRegExp(new String("R2"),TableScanOperator.getOperatorName() + "%.*" + ReduceSinkOperator.getOperatorName()+ "%"),new GenMRRedSink1());
  opRules.put(new RuleRegExp(new String("R3"),ReduceSinkOperator.getOperatorName() + "%.*" + ReduceSinkOperator.getOperatorName()+ "%"),new GenMRRedSink2());
  opRules.put(new RuleRegExp(new String("R4"),FileSinkOperator.getOperatorName() + "%"),new GenMRFileSink1());
  opRules.put(new RuleRegExp(new String("R5"),UnionOperator.getOperatorName() + "%"),new GenMRUnion1());
  opRules.put(new RuleRegExp(new String("R6"),UnionOperator.getOperatorName() + "%.*" + ReduceSinkOperator.getOperatorName()+ "%"),new GenMRRedSink3());
  opRules.put(new RuleRegExp(new String("R7"),MapJoinOperator.getOperatorName() + "%"),MapJoinFactory.getTableScanMapJoin());
  Dispatcher disp=new DefaultRuleDispatcher(new GenMROperator(),opRules,procCtx);
  GraphWalker ogw=new GenMapRedWalker(disp);
  ArrayList<Node> topNodes=new ArrayList<Node>();
  topNodes.addAll(pCtx.getTopOps().values());
  ogw.startWalking(topNodes,null);
  if (isCStats) {
    genColumnStatsTask(qb,loadTableWork,loadFileWork,rootTasks);
  }
  for (  Task<? extends Serializable> rootTask : rootTasks) {
    breakTaskTree(rootTask);
  }
  for (  Task<? extends Serializable> rootTask : rootTasks) {
    GenMapRedUtils.setKeyAndValueDescForTaskTree(rootTask);
  }
  for (  Task<? extends Serializable> rootTask : rootTasks) {
    setInputFormat(rootTask);
  }
  PhysicalContext physicalContext=new PhysicalContext(conf,getParseContext(pCtx,rootTasks),ctx,rootTasks,pCtx.getFetchTask());
  PhysicalOptimizer physicalOptimizer=new PhysicalOptimizer(physicalContext,conf);
  physicalOptimizer.optimize();
  if (HiveConf.getBoolVar(conf,HiveConf.ConfVars.HIVEJOBPROGRESS)) {
    for (    Task<? extends Serializable> rootTask : rootTasks) {
      generateCountersTask(rootTask);
    }
  }
  decideExecMode(rootTasks,ctx,globalLimitCtx);
  if (qb.isCTAS()) {
    CreateTableDesc crtTblDesc=qb.getTableDesc();
    crtTblDesc.validate();
    outputs.clear();
    Task<? extends Serializable> crtTblTask=TaskFactory.get(new DDLWork(inputs,outputs,crtTblDesc),conf);
    HashSet<Task<? extends Serializable>> leaves=new HashSet<Task<? extends Serializable>>();
    getLeafTasks(rootTasks,leaves);
    assert(leaves.size() > 0);
    for (    Task<? extends Serializable> task : leaves) {
      if (task instanceof StatsTask) {
        for (        Task<? extends Serializable> parentOfStatsTask : task.getParentTasks()) {
          parentOfStatsTask.addDependentTask(crtTblTask);
        }
        for (        Task<? extends Serializable> parentOfCrtTblTask : crtTblTask.getParentTasks()) {
          parentOfCrtTblTask.removeDependentTask(task);
        }
        crtTblTask.addDependentTask(task);
      }
 else {
        task.addDependentTask(crtTblTask);
      }
    }
  }
  if (globalLimitCtx.isEnable() && pCtx.getFetchTask() != null) {
    LOG.info("set least row check for FetchTask: " + globalLimitCtx.getGlobalLimit());
    pCtx.getFetchTask().getWork().setLeastNumRows(globalLimitCtx.getGlobalLimit());
  }
  if (globalLimitCtx.isEnable() && globalLimitCtx.getLastReduceLimitDesc() != null) {
    LOG.info("set least row check for LimitDesc: " + globalLimitCtx.getGlobalLimit());
    globalLimitCtx.getLastReduceLimitDesc().setLeastRows(globalLimitCtx.getGlobalLimit());
    List<ExecDriver> mrTasks=Utilities.getMRTasks(rootTasks);
    for (    ExecDriver tsk : mrTasks) {
      tsk.setRetryCmdWhenFail(true);
    }
  }
}
