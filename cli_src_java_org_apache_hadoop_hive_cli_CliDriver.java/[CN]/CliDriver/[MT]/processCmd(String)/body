{
  CliSessionState ss=(CliSessionState)SessionState.get();
  ss.setLastCommand(cmd);
  ss.err.flush();
  String cmd_trimmed=cmd.trim();
  String[] tokens=tokenizeCmd(cmd_trimmed);
  int ret=0;
  if (cmd_trimmed.toLowerCase().equals("quit") || cmd_trimmed.toLowerCase().equals("exit")) {
    ss.close();
    System.exit(0);
  }
 else   if (tokens[0].equalsIgnoreCase("source")) {
    String cmd_1=getFirstCmd(cmd_trimmed,tokens[0].length());
    cmd_1=new VariableSubstitution().substitute(ss.getConf(),cmd_1);
    File sourceFile=new File(cmd_1);
    if (!sourceFile.isFile()) {
      console.printError("File: " + cmd_1 + " is not a file.");
      ret=1;
    }
 else {
      try {
        this.processFile(cmd_1);
      }
 catch (      IOException e) {
        console.printError("Failed processing file " + cmd_1 + " "+ e.getLocalizedMessage(),stringifyException(e));
        ret=1;
      }
    }
  }
 else   if (cmd_trimmed.startsWith("!")) {
    String shell_cmd=cmd_trimmed.substring(1);
    shell_cmd=new VariableSubstitution().substitute(ss.getConf(),shell_cmd);
    try {
      Process executor=Runtime.getRuntime().exec(shell_cmd);
      StreamPrinter outPrinter=new StreamPrinter(executor.getInputStream(),null,ss.out);
      StreamPrinter errPrinter=new StreamPrinter(executor.getErrorStream(),null,ss.err);
      outPrinter.start();
      errPrinter.start();
      ret=executor.waitFor();
      if (ret != 0) {
        console.printError("Command failed with exit code = " + ret);
      }
    }
 catch (    Exception e) {
      console.printError("Exception raised from Shell command " + e.getLocalizedMessage(),stringifyException(e));
      ret=1;
    }
  }
 else   if (tokens[0].toLowerCase().equals("list")) {
    SessionState.ResourceType t;
    if (tokens.length < 2 || (t=SessionState.find_resource_type(tokens[1])) == null) {
      console.printError("Usage: list [" + StringUtils.join(SessionState.ResourceType.values(),"|") + "] [<value> [<value>]*]");
      ret=1;
    }
 else {
      List<String> filter=null;
      if (tokens.length >= 3) {
        System.arraycopy(tokens,2,tokens,0,tokens.length - 2);
        filter=Arrays.asList(tokens);
      }
      Set<String> s=ss.list_resource(t,filter);
      if (s != null && !s.isEmpty()) {
        ss.out.println(StringUtils.join(s,"\n"));
      }
    }
  }
 else   if (ss.isRemoteMode()) {
    HiveClient client=ss.getClient();
    PrintStream out=ss.out;
    PrintStream err=ss.err;
    try {
      client.execute(cmd_trimmed);
      List<String> results;
      do {
        results=client.fetchN(LINES_TO_FETCH);
        for (        String line : results) {
          out.println(line);
        }
      }
 while (results.size() == LINES_TO_FETCH);
    }
 catch (    HiveServerException e) {
      ret=e.getErrorCode();
      if (ret != 0) {
        String errMsg=e.getMessage();
        if (errMsg == null) {
          errMsg=e.toString();
        }
        ret=e.getErrorCode();
        err.println("[Hive Error]: " + errMsg);
      }
    }
catch (    TException e) {
      String errMsg=e.getMessage();
      if (errMsg == null) {
        errMsg=e.toString();
      }
      ret=-10002;
      err.println("[Thrift Error]: " + errMsg);
    }
 finally {
      try {
        client.clean();
      }
 catch (      TException e) {
        String errMsg=e.getMessage();
        if (errMsg == null) {
          errMsg=e.toString();
        }
        err.println("[Thrift Error]: Hive server is not cleaned due to thrift exception: " + errMsg);
      }
    }
  }
 else {
    try {
      CommandProcessor proc=CommandProcessorFactory.get(tokens,(HiveConf)conf);
      ret=processLocalCmd(cmd,proc,ss);
    }
 catch (    SQLException e) {
      console.printError("Failed processing command " + tokens[0] + " "+ e.getLocalizedMessage(),org.apache.hadoop.util.StringUtils.stringifyException(e));
      ret=1;
    }
  }
  return ret;
}
