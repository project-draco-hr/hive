{
  Context ctx=pCtx.getContext();
  GlobalLimitCtx globalLimitCtx=pCtx.getGlobalLimitCtx();
  List<Task<MoveWork>> mvTask=new ArrayList<Task<MoveWork>>();
  List<LoadTableDesc> loadTableWork=pCtx.getLoadTableWork();
  List<LoadFileDesc> loadFileWork=pCtx.getLoadFileWork();
  boolean isCStats=pCtx.getQueryProperties().isAnalyzeRewrite();
  int outerQueryLimit=pCtx.getQueryProperties().getOuterQueryLimit();
  if (pCtx.getFetchTask() != null) {
    return;
  }
  optimizeOperatorPlan(pCtx,inputs,outputs);
  if (pCtx.getQueryProperties().isQuery() && !isCStats) {
    if ((!loadTableWork.isEmpty()) || (loadFileWork.size() != 1)) {
      throw new SemanticException(ErrorMsg.INVALID_LOAD_TABLE_FILE_WORK.getMsg());
    }
    LoadFileDesc loadFileDesc=loadFileWork.get(0);
    String cols=loadFileDesc.getColumns();
    String colTypes=loadFileDesc.getColumnTypes();
    TableDesc resultTab=pCtx.getFetchTableDesc();
    if (resultTab == null) {
      String resFileFormat=HiveConf.getVar(conf,HiveConf.ConfVars.HIVEQUERYRESULTFILEFORMAT);
      resultTab=PlanUtils.getDefaultQueryOutputTableDesc(cols,colTypes,resFileFormat);
    }
    FetchWork fetch=new FetchWork(loadFileDesc.getSourcePath(),resultTab,outerQueryLimit);
    fetch.setSource(pCtx.getFetchSource());
    fetch.setSink(pCtx.getFetchSink());
    pCtx.setFetchTask((FetchTask)TaskFactory.get(fetch,conf));
    int fetchLimit=HiveConf.getIntVar(conf,HiveConf.ConfVars.HIVELIMITOPTMAXFETCH);
    if (globalLimitCtx.isEnable() && globalLimitCtx.getGlobalLimit() > fetchLimit) {
      LOG.info("For FetchTask, LIMIT " + globalLimitCtx.getGlobalLimit() + " > "+ fetchLimit+ ". Doesn't qualify limit optimiztion.");
      globalLimitCtx.disableOpt();
    }
    if (outerQueryLimit == 0) {
      LOG.info("Limit 0. No query execution needed.");
      return;
    }
  }
 else   if (!isCStats) {
    for (    LoadTableDesc ltd : loadTableWork) {
      Task<MoveWork> tsk=TaskFactory.get(new MoveWork(null,null,ltd,null,false),conf);
      mvTask.add(tsk);
      if (HiveConf.getBoolVar(conf,HiveConf.ConfVars.HIVEINDEXAUTOUPDATE)) {
        IndexUpdater indexUpdater=new IndexUpdater(loadTableWork,inputs,conf);
        try {
          List<Task<? extends Serializable>> indexUpdateTasks=indexUpdater.generateUpdateTasks();
          for (          Task<? extends Serializable> updateTask : indexUpdateTasks) {
            tsk.addDependentTask(updateTask);
          }
        }
 catch (        HiveException e) {
          console.printInfo("WARNING: could not auto-update stale indexes, which are not in sync");
        }
      }
    }
    boolean oneLoadFile=true;
    for (    LoadFileDesc lfd : loadFileWork) {
      if (pCtx.getQueryProperties().isCTAS()) {
        assert(oneLoadFile);
        Path location;
        String loc=pCtx.getCreateTable().getLocation();
        if (loc == null) {
          Path targetPath;
          try {
            String[] names=Utilities.getDbTableName(pCtx.getCreateTable().getTableName());
            if (!db.databaseExists(names[0])) {
              throw new SemanticException("ERROR: The database " + names[0] + " does not exist.");
            }
            Warehouse wh=new Warehouse(conf);
            targetPath=wh.getTablePath(db.getDatabase(names[0]),names[1]);
          }
 catch (          HiveException e) {
            throw new SemanticException(e);
          }
catch (          MetaException e) {
            throw new SemanticException(e);
          }
          location=targetPath;
        }
 else {
          location=new Path(loc);
        }
        lfd.setTargetDir(location);
        oneLoadFile=false;
      }
      mvTask.add(TaskFactory.get(new MoveWork(null,null,null,lfd,false),conf));
    }
  }
  generateTaskTree(rootTasks,pCtx,mvTask,inputs,outputs);
  if (isCStats) {
    genColumnStatsTask(pCtx.getAnalyzeRewrite(),loadTableWork,loadFileWork,rootTasks,outerQueryLimit);
  }
  for (  Task<? extends Serializable> rootTask : rootTasks) {
    GenMapRedUtils.setKeyAndValueDescForTaskTree(rootTask);
  }
  for (  Task<? extends Serializable> rootTask : rootTasks) {
    setInputFormat(rootTask);
  }
  optimizeTaskPlan(rootTasks,pCtx,ctx);
  decideExecMode(rootTasks,ctx,globalLimitCtx);
  if (pCtx.getQueryProperties().isCTAS()) {
    CreateTableDesc crtTblDesc=pCtx.getCreateTable();
    crtTblDesc.validate(conf);
    Iterator<WriteEntity> outIter=outputs.iterator();
    while (outIter.hasNext()) {
switch (outIter.next().getType()) {
case DFS_DIR:
case LOCAL_DIR:
        outIter.remove();
      break;
default :
    break;
}
}
Task<? extends Serializable> crtTblTask=TaskFactory.get(new DDLWork(inputs,outputs,crtTblDesc),conf);
HashSet<Task<? extends Serializable>> leaves=new LinkedHashSet<Task<? extends Serializable>>();
getLeafTasks(rootTasks,leaves);
assert(leaves.size() > 0);
for (Task<? extends Serializable> task : leaves) {
if (task instanceof StatsTask) {
  for (  Task<? extends Serializable> parentOfStatsTask : task.getParentTasks()) {
    parentOfStatsTask.addDependentTask(crtTblTask);
  }
  for (  Task<? extends Serializable> parentOfCrtTblTask : crtTblTask.getParentTasks()) {
    parentOfCrtTblTask.removeDependentTask(task);
  }
  crtTblTask.addDependentTask(task);
}
 else {
  task.addDependentTask(crtTblTask);
}
}
}
if (globalLimitCtx.isEnable() && pCtx.getFetchTask() != null) {
LOG.info("set least row check for FetchTask: " + globalLimitCtx.getGlobalLimit());
pCtx.getFetchTask().getWork().setLeastNumRows(globalLimitCtx.getGlobalLimit());
}
if (globalLimitCtx.isEnable() && globalLimitCtx.getLastReduceLimitDesc() != null) {
LOG.info("set least row check for LimitDesc: " + globalLimitCtx.getGlobalLimit());
globalLimitCtx.getLastReduceLimitDesc().setLeastRows(globalLimitCtx.getGlobalLimit());
List<ExecDriver> mrTasks=Utilities.getMRTasks(rootTasks);
for (ExecDriver tsk : mrTasks) {
tsk.setRetryCmdWhenFail(true);
}
List<SparkTask> sparkTasks=Utilities.getSparkTasks(rootTasks);
for (SparkTask sparkTask : sparkTasks) {
sparkTask.setRetryCmdWhenFail(true);
}
}
Interner<TableDesc> interner=Interners.newStrongInterner();
for (Task<? extends Serializable> rootTask : rootTasks) {
GenMapRedUtils.internTableDesc(rootTask,interner);
GenMapRedUtils.deriveFinalExplainAttributes(rootTask,pCtx.getConf());
}
}
