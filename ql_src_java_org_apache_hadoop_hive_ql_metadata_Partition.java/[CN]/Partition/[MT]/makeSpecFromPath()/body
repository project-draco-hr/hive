{
  Path currPath=this.partPath;
  LinkedHashMap<String,String> partSpec=new LinkedHashMap<String,String>();
  List<FieldSchema> pcols=this.table.getPartCols();
  for (int i=0; i < pcols.size(); i++) {
    FieldSchema col=pcols.get(pcols.size() - i - 1);
    if (currPath == null) {
      throw new HiveException("Out of path components while expecting key: " + col.getName());
    }
    String component=currPath.getName();
    Matcher m=pat.matcher(component);
    if (m.matches()) {
      String k=m.group(1);
      String v=m.group(2);
      if (!k.equals(col.getName())) {
        throw new HiveException("Key mismatch expected: " + col.getName() + " and got: "+ k);
      }
      if (partSpec.containsKey(k)) {
        throw new HiveException("Key " + k + " defined at two levels");
      }
      partSpec.put(k,v);
    }
 else {
      throw new HiveException("Path " + currPath.toString() + " not a valid path");
    }
    currPath=currPath.getParent();
  }
  LinkedHashMap<String,String> newSpec=new LinkedHashMap<String,String>();
  for (int i=0; i < table.getPartCols().size(); i++) {
    FieldSchema field=table.getPartCols().get(i);
    String val=partSpec.get(field.getName());
    newSpec.put(field.getName(),val);
  }
  return newSpec;
}
