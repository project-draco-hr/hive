{
  ArrayList<OrcStripeMetadata> result=new ArrayList<OrcStripeMetadata>(readState.length);
  boolean hasFileId=this.fileId != null;
  long fileId=hasFileId ? this.fileId : 0;
  OrcBatchKey stripeKey=hasFileId ? new OrcBatchKey(fileId,0,0) : null;
  for (int stripeIxMod=0; stripeIxMod < readState.length; ++stripeIxMod) {
    OrcStripeMetadata value=null;
    int stripeIx=stripeIxMod + stripeIxFrom;
    if (hasFileId && metadataCache != null) {
      stripeKey.stripeIx=stripeIx;
      value=metadataCache.getStripeMetadata(stripeKey);
    }
    if (value == null || !value.hasAllIndexes(globalInc)) {
      counters.incrCounter(LlapIOCounters.METADATA_CACHE_MISS);
      ensureMetadataReader();
      StripeInformation si=fileMetadata.getStripes().get(stripeIx);
      if (value == null) {
        long startTime=counters.startTimeCounter();
        value=new OrcStripeMetadata(new OrcBatchKey(fileId,stripeIx,0),metadataReader,si,globalInc,sargColumns);
        counters.incrTimeCounter(LlapIOCounters.HDFS_TIME_NS,startTime);
        if (hasFileId && metadataCache != null) {
          value=metadataCache.putStripeMetadata(value);
          if (DebugUtils.isTraceOrcEnabled()) {
            LlapIoImpl.LOG.info("Caching stripe " + stripeKey.stripeIx + " metadata with includes: "+ DebugUtils.toString(globalInc));
          }
        }
      }
      if (!value.hasAllIndexes(globalInc)) {
        if (DebugUtils.isTraceOrcEnabled()) {
          LlapIoImpl.LOG.info("Updating indexes in stripe " + stripeKey.stripeIx + " metadata for includes: "+ DebugUtils.toString(globalInc));
        }
        updateLoadedIndexes(value,si,globalInc,sargColumns);
      }
    }
 else {
      counters.incrCounter(LlapIOCounters.METADATA_CACHE_HIT);
    }
    result.add(value);
    consumer.setStripeMetadata(value);
  }
  return result;
}
