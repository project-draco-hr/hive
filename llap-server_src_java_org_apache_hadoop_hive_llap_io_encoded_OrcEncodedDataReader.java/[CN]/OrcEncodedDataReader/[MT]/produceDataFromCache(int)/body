{
  OrcCacheKey key=new OrcCacheKey(fileId,-1,-1,-1);
  @SuppressWarnings("unchecked") List<Integer>[] stripeColsNotInCache=new List[readState.length];
  for (int stripeIxMod=0; stripeIxMod < readState.length; ++stripeIxMod) {
    key.stripeIx=stripeIxFrom + stripeIxMod;
    boolean[][] cols=readState[stripeIxMod];
    boolean[] isMissingAnyRgs=new boolean[cols.length];
    int totalRgCount=getRgCount(fileMetadata.getStripes().get(key.stripeIx),rowIndexStride);
    for (int rgIx=0; rgIx < totalRgCount; ++rgIx) {
      OrcEncodedColumnBatch col=ECB_POOL.take();
      col.init(fileId,key.stripeIx,rgIx,cols.length);
      boolean hasAnyCached=false;
      try {
        key.rgIx=rgIx;
        for (int colIxMod=0; colIxMod < cols.length; ++colIxMod) {
          boolean[] readMask=cols[colIxMod];
          if ((readMask == SargApplier.READ_NO_RGS) || (readMask != SargApplier.READ_ALL_RGS && (readMask.length <= rgIx || !readMask[rgIx])))           continue;
          key.colIx=columnIds.get(colIxMod);
          ColumnStreamData[] cached=cache.get(key);
          if (cached == null) {
            isMissingAnyRgs[colIxMod]=true;
            continue;
          }
          col.setAllStreamsData(colIxMod,key.colIx,cached);
          hasAnyCached=true;
          if (readMask == SargApplier.READ_ALL_RGS) {
            cols[colIxMod]=readMask=new boolean[totalRgCount];
            Arrays.fill(readMask,true);
          }
          readMask[rgIx]=false;
        }
      }
 catch (      Throwable t) {
        throw (t instanceof IOException) ? (IOException)t : new IOException(t);
      }
      if (hasAnyCached) {
        consumer.consumeData(col);
      }
    }
    boolean makeStripeColList=false;
    for (int colIxMod=0; colIxMod < cols.length; ++colIxMod) {
      if (isMissingAnyRgs[colIxMod]) {
        if (makeStripeColList) {
          stripeColsNotInCache[stripeIxMod].add(columnIds.get(colIxMod));
        }
      }
 else       if (!makeStripeColList) {
        makeStripeColList=true;
        stripeColsNotInCache[stripeIxMod]=new ArrayList<Integer>(cols.length - 1);
        for (int i=0; i < colIxMod; ++i) {
          stripeColsNotInCache[stripeIxMod].add(columnIds.get(i));
        }
      }
    }
  }
  return stripeColsNotInCache;
}
