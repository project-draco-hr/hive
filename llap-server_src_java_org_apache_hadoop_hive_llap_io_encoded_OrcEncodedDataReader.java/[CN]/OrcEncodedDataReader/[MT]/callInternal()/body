{
  if (LlapIoImpl.LOGL.isInfoEnabled()) {
    LlapIoImpl.LOG.info("Processing split for " + split.getPath());
  }
  if (isStopped)   return null;
  orcReader=null;
  fs=split.getPath().getFileSystem(conf);
  this.fileId=RecordReaderUtils.getFileId(fs,split.getPath());
  try {
    fileMetadata=getOrReadFileMetadata();
    consumer.setFileMetadata(fileMetadata);
    int bufferSize=fileMetadata.getCompressionBufferSize();
    int minAllocSize=HiveConf.getIntVar(conf,HiveConf.ConfVars.LLAP_ORC_CACHE_MIN_ALLOC);
    if (bufferSize < minAllocSize) {
      throw new IOException("ORC compression buffer size (" + bufferSize + ") is smaller than"+ " LLAP low-level cache minimum allocation size ("+ minAllocSize+ "). Decrease the"+ " value for "+ HiveConf.ConfVars.LLAP_ORC_CACHE_MIN_ALLOC.toString());
    }
    if (columnIds == null) {
      columnIds=createColumnIds(fileMetadata);
    }
    determineStripesToRead();
  }
 catch (  Throwable t) {
    consumer.setError(t);
    return null;
  }
  if (readState.length == 0) {
    consumer.setDone();
    return null;
  }
  int stride=fileMetadata.getRowIndexStride();
  ArrayList<OrcStripeMetadata> stripeMetadatas=null;
  boolean[] globalIncludes=null;
  boolean[] sargColumns=null;
  try {
    globalIncludes=OrcInputFormat.genIncludedColumns(fileMetadata.getTypes(),columnIds,true);
    if (sarg != null && stride != 0) {
      int[] filterColumns=RecordReaderImpl.mapSargColumns(sarg.getLeaves(),columnNames,0);
      sargColumns=new boolean[globalIncludes.length];
      for (      int i : filterColumns) {
        if (i > 0) {
          sargColumns[i]=true;
        }
      }
      stripeMetadatas=readStripesMetadata(globalIncludes,sargColumns);
    }
    determineRgsToRead(globalIncludes,stride,stripeMetadatas);
  }
 catch (  Throwable t) {
    cleanupReaders(null);
    consumer.setError(t);
    return null;
  }
  if (isStopped) {
    cleanupReaders(null);
    return null;
  }
  List<Integer>[] stripeColsToRead=null;
  if (cache != null) {
    try {
      stripeColsToRead=produceDataFromCache(stride);
    }
 catch (    Throwable t) {
      consumer.setError(t);
      cleanupReaders(null);
      return null;
    }
  }
  Consumer<EncodedColumnBatch<OrcBatchKey>> dataConsumer=(cache == null) ? this.consumer : this;
  EncodedReader stripeReader=null;
  try {
    ensureOrcReader();
    stripeReader=orcReader.encodedReader(lowLevelCache,dataConsumer);
  }
 catch (  Throwable t) {
    consumer.setError(t);
    cleanupReaders(null);
    return null;
  }
  OrcBatchKey stripeKey=new OrcBatchKey(fileId,-1,0);
  for (int stripeIxMod=0; stripeIxMod < readState.length; ++stripeIxMod) {
    try {
      List<Integer> cols=stripeColsToRead == null ? null : stripeColsToRead[stripeIxMod];
      if (cols != null && cols.isEmpty())       continue;
      int stripeIx=stripeIxFrom + stripeIxMod;
      StripeInformation si=fileMetadata.getStripes().get(stripeIx);
      if (DebugUtils.isTraceOrcEnabled()) {
        LlapIoImpl.LOG.info("Reading stripe " + stripeIx + ": "+ si.getOffset()+ ", "+ si.getLength());
      }
      boolean[] stripeIncludes=null;
      boolean[][] colRgs=readState[stripeIxMod];
      if (cols == null || cols.size() == colRgs.length) {
        cols=columnIds;
        stripeIncludes=globalIncludes;
      }
 else {
        stripeIncludes=OrcInputFormat.genIncludedColumns(fileMetadata.getTypes(),cols,true);
        boolean[][] colRgs2=new boolean[cols.size()][];
        for (int i=0, i2=-1; i < colRgs.length; ++i) {
          if (colRgs[i] == null)           continue;
          colRgs2[i2]=colRgs[i];
          ++i2;
        }
        colRgs=colRgs2;
      }
      OrcStripeMetadata stripeMetadata;
      if (stripeMetadatas != null) {
        stripeMetadata=stripeMetadatas.get(stripeIxMod);
      }
 else {
        stripeKey.stripeIx=stripeIx;
        stripeMetadata=metadataCache.getStripeMetadata(stripeKey);
        if (stripeMetadata == null) {
          ensureMetadataReader();
          stripeMetadata=new OrcStripeMetadata(stripeKey,metadataReader,si,stripeIncludes,sargColumns);
          if (DebugUtils.isTraceOrcEnabled()) {
            LlapIoImpl.LOG.info("Caching stripe " + stripeKey.stripeIx + " metadata with includes: "+ DebugUtils.toString(stripeIncludes));
          }
          metadataCache.putStripeMetadata(stripeMetadata);
          stripeKey=new OrcBatchKey(fileId,-1,0);
        }
        consumer.setStripeMetadata(stripeMetadata);
      }
      if (!stripeMetadata.hasAllIndexes(stripeIncludes)) {
        if (DebugUtils.isTraceOrcEnabled()) {
          LlapIoImpl.LOG.info("Updating indexes in stripe " + stripeKey.stripeIx + " metadata for includes: "+ DebugUtils.toString(stripeIncludes));
        }
        ensureMetadataReader();
        updateLoadedIndexes(stripeMetadata,si,stripeIncludes,sargColumns);
      }
      stripeReader.readEncodedColumns(stripeIx,si,stripeMetadata.getRowIndexes(),stripeMetadata.getEncodings(),stripeMetadata.getStreams(),stripeIncludes,colRgs);
    }
 catch (    Throwable t) {
      consumer.setError(t);
      cleanupReaders(stripeReader);
      return null;
    }
  }
  dataConsumer.setDone();
  if (DebugUtils.isTraceMttEnabled()) {
    LlapIoImpl.LOG.info("done processing " + split);
  }
  stripeReader.close();
  return null;
}
