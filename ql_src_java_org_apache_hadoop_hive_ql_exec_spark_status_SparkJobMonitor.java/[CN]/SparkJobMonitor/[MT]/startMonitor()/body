{
  completed=new HashSet<String>();
  boolean running=false;
  boolean done=false;
  int failedCounter=0;
  int rc=0;
  JobExecutionStatus lastState=null;
  Map<String,SparkStageProgress> lastProgressMap=null;
  long startTime=0;
  while (true) {
    try {
      JobExecutionStatus state=sparkJobStatus.getState();
      if (state != null && (state != lastState || state == JobExecutionStatus.RUNNING)) {
        lastState=state;
        Map<String,SparkStageProgress> progressMap=sparkJobStatus.getSparkStageProgress();
switch (state) {
case RUNNING:
          if (!running) {
            console.printInfo("\nQuery Hive on Spark job[" + sparkJobStatus.getJobId() + "] stages:");
            for (            int stageId : sparkJobStatus.getStageIds()) {
              console.printInfo(Integer.toString(stageId));
            }
            console.printInfo("\nStatus: Running (Hive on Spark job[" + sparkJobStatus.getJobId() + "])");
            startTime=System.currentTimeMillis();
            running=true;
            console.printInfo("Job Progress Format\nCurrentTime StageId_StageAttemptId: " + "SucceededTasksCount(+RunningTasksCount-FailedTasksCount)/TotalTasksCount [StageCost]");
          }
        printStatus(progressMap,lastProgressMap);
      lastProgressMap=progressMap;
    break;
case SUCCEEDED:
  printStatus(progressMap,lastProgressMap);
lastProgressMap=progressMap;
double duration=(System.currentTimeMillis() - startTime) / 1000.0;
console.printInfo("Status: Finished successfully in " + String.format("%.2f seconds",duration));
running=false;
done=true;
break;
case FAILED:
console.printError("Status: Failed");
running=false;
done=true;
rc=2;
break;
}
}
if (!done) {
Thread.sleep(checkInterval);
}
}
 catch (Exception e) {
console.printInfo("Exception: " + e.getMessage());
if (++failedCounter % maxRetryInterval / checkInterval == 0 || e instanceof InterruptedException) {
console.printInfo("Killing Job...");
console.printError("Execution has failed.");
rc=1;
done=true;
}
 else {
console.printInfo("Retrying...");
}
}
 finally {
if (done) {
break;
}
}
}
return rc;
}
