{
  if (value == null) {
    return;
  }
switch (inspector.getPrimitiveCategory()) {
case VOID:
    return;
case DOUBLE:
  recordConsumer.addDouble(((DoubleObjectInspector)inspector).get(value));
break;
case BOOLEAN:
recordConsumer.addBoolean(((BooleanObjectInspector)inspector).get(value));
break;
case FLOAT:
recordConsumer.addFloat(((FloatObjectInspector)inspector).get(value));
break;
case BYTE:
recordConsumer.addInteger(((ByteObjectInspector)inspector).get(value));
break;
case INT:
recordConsumer.addInteger(((IntObjectInspector)inspector).get(value));
break;
case LONG:
recordConsumer.addLong(((LongObjectInspector)inspector).get(value));
break;
case SHORT:
recordConsumer.addInteger(((ShortObjectInspector)inspector).get(value));
break;
case STRING:
String v=((StringObjectInspector)inspector).getPrimitiveJavaObject(value);
recordConsumer.addBinary(Binary.fromString(v));
break;
case CHAR:
String vChar=((HiveCharObjectInspector)inspector).getPrimitiveJavaObject(value).getStrippedValue();
recordConsumer.addBinary(Binary.fromString(vChar));
break;
case VARCHAR:
String vVarchar=((HiveVarcharObjectInspector)inspector).getPrimitiveJavaObject(value).getValue();
recordConsumer.addBinary(Binary.fromString(vVarchar));
break;
case BINARY:
byte[] vBinary=((BinaryObjectInspector)inspector).getPrimitiveJavaObject(value);
recordConsumer.addBinary(Binary.fromByteArray(vBinary));
break;
case TIMESTAMP:
Timestamp ts=((TimestampObjectInspector)inspector).getPrimitiveJavaObject(value);
recordConsumer.addBinary(NanoTimeUtils.getNanoTime(ts,false).toBinary());
break;
case DECIMAL:
HiveDecimal vDecimal=((HiveDecimal)inspector.getPrimitiveJavaObject(value));
DecimalTypeInfo decTypeInfo=(DecimalTypeInfo)inspector.getTypeInfo();
recordConsumer.addBinary(decimalToBinary(vDecimal,decTypeInfo));
break;
default :
throw new IllegalArgumentException("Unsupported primitive data type: " + inspector.getPrimitiveCategory());
}
}
