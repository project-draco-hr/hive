{
  Text rowText=(Text)blob;
  Matcher m=inputPattern.matcher(rowText.toString());
  if (m.groupCount() != numColumns) {
    throw new SerDeException("Number of matching groups doesn't match the number of columns");
  }
  if (!m.matches()) {
    unmatchedRowsCount++;
    if (!alreadyLoggedNoMatch) {
      LOG.warn("" + unmatchedRowsCount + " unmatched rows are found: "+ rowText);
      alreadyLoggedNoMatch=true;
    }
    return null;
  }
  for (int c=0; c < numColumns; c++) {
    try {
      String t=m.group(c + 1);
      TypeInfo typeInfo=columnTypes.get(c);
      PrimitiveTypeInfo pti=(PrimitiveTypeInfo)typeInfo;
switch (pti.getPrimitiveCategory()) {
case STRING:
        row.set(c,t);
      break;
case BYTE:
    Byte b;
  b=Byte.valueOf(t);
row.set(c,b);
break;
case SHORT:
Short s;
s=Short.valueOf(t);
row.set(c,s);
break;
case INT:
Integer i;
i=Integer.valueOf(t);
row.set(c,i);
break;
case LONG:
Long l;
l=Long.valueOf(t);
row.set(c,l);
break;
case FLOAT:
Float f;
f=Float.valueOf(t);
row.set(c,f);
break;
case DOUBLE:
Double d;
d=Double.valueOf(t);
row.set(c,d);
break;
case BOOLEAN:
Boolean bool;
bool=Boolean.valueOf(t);
row.set(c,bool);
break;
case TIMESTAMP:
Timestamp ts;
ts=Timestamp.valueOf(t);
row.set(c,ts);
break;
case DATE:
Date date;
date=Date.valueOf(t);
row.set(c,date);
break;
case DECIMAL:
HiveDecimal bd=HiveDecimal.create(t);
row.set(c,bd);
break;
case CHAR:
HiveChar hc=new HiveChar(t,((CharTypeInfo)typeInfo).getLength());
row.set(c,hc);
break;
case VARCHAR:
HiveVarchar hv=new HiveVarchar(t,((VarcharTypeInfo)typeInfo).getLength());
row.set(c,hv);
break;
default :
throw new SerDeException("Unsupported type " + typeInfo);
}
}
 catch (RuntimeException e) {
partialMatchedRowsCount++;
if (!alreadyLoggedPartialMatch) {
LOG.warn("" + partialMatchedRowsCount + " partially unmatched rows are found, "+ " cannot find group "+ c+ ": "+ rowText);
alreadyLoggedPartialMatch=true;
}
row.set(c,null);
}
}
return row;
}
