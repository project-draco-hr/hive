{
  boolean ret=false;
switch (op.getType()) {
case MAPJOIN:
    if (op instanceof MapJoinOperator) {
      ret=validateMapJoinOperator((MapJoinOperator)op);
    }
 else     if (op instanceof SMBMapJoinOperator) {
      ret=validateSMBMapJoinOperator((SMBMapJoinOperator)op);
    }
  break;
case GROUPBY:
if (HiveConf.getBoolVar(hiveConf,HiveConf.ConfVars.HIVE_VECTORIZATION_REDUCE_GROUPBY_ENABLED)) {
  ret=validateGroupByOperator((GroupByOperator)op,true,true);
}
 else {
  ret=false;
}
break;
case FILTER:
ret=validateFilterOperator((FilterOperator)op);
break;
case SELECT:
ret=validateSelectOperator((SelectOperator)op);
break;
case REDUCESINK:
ret=validateReduceSinkOperator((ReduceSinkOperator)op);
break;
case FILESINK:
ret=validateFileSinkOperator((FileSinkOperator)op);
break;
case LIMIT:
case EVENT:
case SPARKPRUNINGSINK:
ret=true;
break;
case HASHTABLESINK:
ret=op instanceof SparkHashTableSinkOperator && validateSparkHashTableSinkOperator((SparkHashTableSinkOperator)op);
break;
default :
ret=false;
break;
}
return ret;
}
