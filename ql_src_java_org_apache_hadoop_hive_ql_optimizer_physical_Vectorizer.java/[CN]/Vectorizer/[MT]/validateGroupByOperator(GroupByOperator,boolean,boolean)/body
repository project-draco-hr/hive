{
  GroupByDesc desc=op.getConf();
  VectorGroupByDesc vectorDesc=desc.getVectorDesc();
  if (desc.isGroupingSetsPresent()) {
    LOG.info("Grouping sets not supported in vector mode");
    return false;
  }
  if (desc.pruneGroupingSetId()) {
    LOG.info("Pruning grouping set id not supported in vector mode");
    return false;
  }
  boolean ret=validateExprNodeDesc(desc.getKeys());
  if (!ret) {
    LOG.info("Cannot vectorize groupby key expression");
    return false;
  }
  boolean isMergePartial=(desc.getMode() != GroupByDesc.Mode.HASH);
  if (!isReduce) {
    ret=validateHashAggregationDesc(desc.getAggregators());
    if (!ret) {
      return false;
    }
  }
 else {
    if (isMergePartial) {
      if (desc.isDistinct()) {
        LOG.info("Vectorized Reduce MergePartial GROUP BY does not support DISTINCT");
        return false;
      }
      boolean hasKeys=(desc.getKeys().size() > 0);
      ret=validateReduceMergePartialAggregationDesc(desc.getAggregators(),hasKeys);
      if (!ret) {
        return false;
      }
      if (hasKeys) {
        if (op.getParentOperators().size() > 0) {
          LOG.info("Vectorized Reduce MergePartial GROUP BY keys can only handle a key group when it is fed by reduce-shuffle");
          return false;
        }
        LOG.info("Vectorized Reduce MergePartial GROUP BY will process key groups");
        vectorDesc.setVectorOutput(true);
      }
 else {
        LOG.info("Vectorized Reduce MergePartial GROUP BY will do global aggregation");
      }
      vectorDesc.setIsReduceMergePartial(true);
    }
 else {
      ret=validateHashAggregationDesc(desc.getAggregators());
      if (!ret) {
        return false;
      }
    }
  }
  return true;
}
