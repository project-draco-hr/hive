{
  if (vector.isRepeating) {
    row=0;
  }
  if (vector.noNulls || !vector.isNull[row]) {
switch (schema.getCategory()) {
case BOOLEAN:
      writer.value(((LongColumnVector)vector).vector[row] != 0);
    break;
case BYTE:
case SHORT:
case INT:
case LONG:
  writer.value(((LongColumnVector)vector).vector[row]);
break;
case FLOAT:
case DOUBLE:
writer.value(((DoubleColumnVector)vector).vector[row]);
break;
case STRING:
case CHAR:
case VARCHAR:
writer.value(((BytesColumnVector)vector).toString(row));
break;
case BINARY:
printBinary(writer,(BytesColumnVector)vector,row);
break;
case DECIMAL:
writer.value(((DecimalColumnVector)vector).vector[row].toString());
break;
case DATE:
writer.value(new DateWritable((int)((LongColumnVector)vector).vector[row]).toString());
break;
case TIMESTAMP:
writer.value(((TimestampColumnVector)vector).asScratchTimestamp(row).toString());
break;
case LIST:
printList(writer,(ListColumnVector)vector,schema,row);
break;
case MAP:
printMap(writer,(MapColumnVector)vector,schema,row);
break;
case STRUCT:
printStruct(writer,(StructColumnVector)vector,schema,row);
break;
case UNION:
printUnion(writer,(UnionColumnVector)vector,schema,row);
break;
default :
throw new IllegalArgumentException("Unknown type " + schema.toString());
}
}
 else {
writer.value(null);
}
}
