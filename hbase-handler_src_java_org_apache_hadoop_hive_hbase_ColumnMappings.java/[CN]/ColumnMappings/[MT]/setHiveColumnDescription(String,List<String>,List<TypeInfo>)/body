{
  if (columnsMapping.length != columnNames.size()) {
    throw new SerDeException(serdeName + ": columns has " + columnNames.size()+ " elements while hbase.columns.mapping has "+ columnsMapping.length+ " elements"+ " (counting the key if implicit)");
  }
  for (int i=0; i < columnNames.size(); i++) {
    ColumnMapping colMap=columnsMapping[i];
    if (colMap.qualifierName == null && !colMap.hbaseRowKey) {
      TypeInfo typeInfo=columnTypes.get(i);
      if ((typeInfo.getCategory() != ObjectInspector.Category.MAP) || (((MapTypeInfo)typeInfo).getMapKeyTypeInfo().getCategory() != ObjectInspector.Category.PRIMITIVE)) {
        throw new SerDeException(serdeName + ": hbase column family '" + colMap.familyName+ "' should be mapped to Map<? extends LazyPrimitive<?, ?>,?>, that is "+ "the Key for the map should be of primitive type, but is mapped to "+ typeInfo.getTypeName());
      }
    }
    colMap.columnName=columnNames.get(i);
    colMap.columnType=columnTypes.get(i);
  }
}
