{
  if (columnsMapping.length != columnNames.size()) {
    throw new SerDeException(serdeName + ": columns has " + columnNames.size()+ " elements while hbase.columns.mapping has "+ columnsMapping.length+ " elements"+ " (counting the key if implicit)");
  }
  for (int i=0; i < columnNames.size(); i++) {
    ColumnMapping colMap=columnsMapping[i];
    colMap.columnName=columnNames.get(i);
    colMap.columnType=columnTypes.get(i);
    if (colMap.qualifierName == null && !colMap.hbaseRowKey && !colMap.hbaseTimestamp) {
      TypeInfo typeInfo=columnTypes.get(i);
      if ((typeInfo.getCategory() != ObjectInspector.Category.MAP) || (((MapTypeInfo)typeInfo).getMapKeyTypeInfo().getCategory() != ObjectInspector.Category.PRIMITIVE)) {
        throw new SerDeException(serdeName + ": hbase column family '" + colMap.familyName+ "' should be mapped to Map<? extends LazyPrimitive<?, ?>,?>, that is "+ "the Key for the map should be of primitive type, but is mapped to "+ typeInfo.getTypeName());
      }
    }
    if (colMap.hbaseTimestamp) {
      TypeInfo typeInfo=columnTypes.get(i);
      if (!colMap.isCategory(PrimitiveCategory.TIMESTAMP) && !colMap.isCategory(PrimitiveCategory.LONG)) {
        throw new SerDeException(serdeName + ": timestamp columns should be of " + "timestamp or bigint type, but is mapped to "+ typeInfo.getTypeName());
      }
    }
  }
}
