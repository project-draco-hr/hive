{
  for (  Map.Entry<String,FetchWork> entry : work.getAliasToFetchWork().entrySet()) {
    JobConf jobClone=new JobConf(job);
    Operator<? extends Serializable> tableScan=work.getAliasToWork().get(entry.getKey());
    boolean setColumnsNeeded=false;
    if (tableScan instanceof TableScanOperator) {
      ArrayList<Integer> list=((TableScanOperator)tableScan).getNeededColumnIDs();
      if (list != null) {
        ColumnProjectionUtils.appendReadColumnIDs(jobClone,list);
        setColumnsNeeded=true;
      }
    }
    if (!setColumnsNeeded) {
      ColumnProjectionUtils.setFullyReadColumns(jobClone);
    }
    FetchOperator fetchOp=new FetchOperator(entry.getValue(),jobClone);
    fetchOpJobConfMap.put(fetchOp,jobClone);
    fetchOperators.put(entry.getKey(),fetchOp);
    l4j.info("fetchoperator for " + entry.getKey() + " created");
  }
  for (  Map.Entry<String,FetchOperator> entry : fetchOperators.entrySet()) {
    String alias=entry.getKey();
    Operator<? extends Serializable> forwardOp=work.getAliasToWork().get(alias);
    forwardOp.setExecContext(execContext);
    FetchOperator fetchOp=entry.getValue();
    JobConf jobConf=fetchOpJobConfMap.get(fetchOp);
    if (jobConf == null) {
      jobConf=job;
    }
    ObjectInspector objectInspector=fetchOp.getOutputObjectInspector();
    if (objectInspector != null) {
      forwardOp.initialize(jobConf,new ObjectInspector[]{objectInspector});
      l4j.info("fetchoperator for " + entry.getKey() + " initialized");
    }
 else {
      fetchOp.setEmptyTable(true);
    }
  }
}
