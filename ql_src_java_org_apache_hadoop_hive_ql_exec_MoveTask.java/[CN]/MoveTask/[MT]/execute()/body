{
  try {
    FileSystem fs=FileSystem.get(conf);
    for (    loadFileDesc lfd : work.getLoadFileWork()) {
      Path targetPath=new Path(lfd.getTargetDir());
      Path sourcePath=new Path(lfd.getSourceDir());
      cleanseSource(fs,sourcePath);
      if (lfd.getIsDfsDir()) {
        String mesg="Moving data to: " + lfd.getTargetDir();
        String mesg_detail=" from " + lfd.getSourceDir();
        console.printInfo(mesg,mesg_detail);
        fs.delete(targetPath,true);
        if (fs.exists(sourcePath))         fs.rename(sourcePath,targetPath);
 else         fs.mkdirs(targetPath);
      }
 else {
        String mesg="Copying data to local directory " + lfd.getTargetDir();
        String mesg_detail=" from " + lfd.getSourceDir();
        console.printInfo(mesg,mesg_detail);
        LocalFileSystem dstFs=FileSystem.getLocal(fs.getConf());
        if (dstFs.delete(targetPath,true) || !dstFs.exists(targetPath)) {
          console.printInfo(mesg,mesg_detail);
          if (fs.exists(sourcePath))           fs.copyToLocalFile(sourcePath,targetPath);
 else           dstFs.mkdirs(targetPath);
        }
 else {
          console.printInfo("Unable to delete the existing destination directory: " + targetPath);
        }
      }
    }
    for (    loadTableDesc tbd : work.getLoadTableWork()) {
      String mesg="Loading data to table " + tbd.getTable().getTableName() + ((tbd.getPartitionSpec().size() > 0) ? " partition " + tbd.getPartitionSpec().toString() : "");
      String mesg_detail=" from " + tbd.getSourceDir();
      console.printInfo(mesg,mesg_detail);
      boolean tableIsSequenceFile=tbd.getTable().getInputFileFormatClass().equals(SequenceFileInputFormat.class);
      FileStatus[] dirs;
      ArrayList<FileStatus> files;
      try {
        fs=FileSystem.get(db.getTable(tbd.getTable().getTableName()).getDataLocation(),Hive.get().getConf());
        dirs=fs.globStatus(new Path(tbd.getSourceDir()));
        files=new ArrayList<FileStatus>();
        for (int i=0; (dirs != null && i < dirs.length); i++) {
          files.addAll(Arrays.asList(fs.listStatus(dirs[i].getPath())));
          if (files.size() > 0)           break;
        }
      }
 catch (      IOException e) {
        throw new HiveException("addFiles: filesystem error in check phase",e);
      }
      if (files.size() > 0) {
        int fileId=0;
        boolean fileIsSequenceFile=true;
        try {
          SequenceFile.Reader reader=new SequenceFile.Reader(fs,files.get(fileId).getPath(),conf);
          reader.close();
        }
 catch (        IOException e) {
          fileIsSequenceFile=false;
        }
        if (!fileIsSequenceFile && tableIsSequenceFile) {
          throw new HiveException("Cannot load text files into a table stored as SequenceFile.");
        }
        if (fileIsSequenceFile && !tableIsSequenceFile) {
          throw new HiveException("Cannot load SequenceFiles into a table stored as TextFile.");
        }
      }
      if (tbd.getPartitionSpec().size() == 0) {
        db.loadTable(new Path(tbd.getSourceDir()),tbd.getTable().getTableName(),tbd.getReplace());
      }
 else {
        LOG.info("Partition is: " + tbd.getPartitionSpec().toString());
        db.loadPartition(new Path(tbd.getSourceDir()),tbd.getTable().getTableName(),tbd.getPartitionSpec(),tbd.getReplace());
      }
    }
    return 0;
  }
 catch (  Exception e) {
    console.printError("Failed with exception " + e.getMessage(),"\n" + StringUtils.stringifyException(e));
    return (1);
  }
}
