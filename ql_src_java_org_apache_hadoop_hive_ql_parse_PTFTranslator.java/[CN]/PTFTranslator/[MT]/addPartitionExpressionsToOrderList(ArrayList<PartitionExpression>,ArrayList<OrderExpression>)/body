{
  int numOfPartColumns=0;
  int chkSize=partCols.size();
  chkSize=chkSize > orderCols.size() ? orderCols.size() : chkSize;
  for (int i=0; i < chkSize; i++) {
    if (orderCols.get(i).getExpression().toStringTree().equals(partCols.get(i).getExpression().toStringTree())) {
      numOfPartColumns++;
    }
 else {
      break;
    }
  }
  if (numOfPartColumns != 0 && numOfPartColumns != partCols.size()) {
    List<String> partitionColumnNames=new ArrayList<String>();
    for (    PartitionExpression partitionExpression : partCols) {
      ASTNode column=partitionExpression.getExpression();
      if (column != null && column.getChildCount() > 0) {
        partitionColumnNames.add(column.getChild(0).getText());
      }
    }
    throw new SemanticException(String.format("all partition columns %s must be in order clause or none should be specified",partitionColumnNames.toString()));
  }
  ArrayList<OrderExpression> combinedOrdExprs=new ArrayList<OrderExpression>();
  if (numOfPartColumns == 0) {
    for (    PartitionExpression partCol : partCols) {
      OrderExpression orderCol=new OrderExpression(partCol);
      combinedOrdExprs.add(orderCol);
    }
  }
  combinedOrdExprs.addAll(orderCols);
  return combinedOrdExprs;
}
