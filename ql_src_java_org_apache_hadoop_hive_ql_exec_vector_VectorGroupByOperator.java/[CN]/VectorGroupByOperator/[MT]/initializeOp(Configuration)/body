{
  super.initializeOp(hconf);
  List<ObjectInspector> objectInspectors=new ArrayList<ObjectInspector>();
  List<ExprNodeDesc> keysDesc=conf.getKeys();
  try {
    List<String> outputFieldNames=conf.getOutputColumnNames();
    outputKeyLength=conf.pruneGroupingSetId() ? keyExpressions.length - 1 : keyExpressions.length;
    keyOutputWriters=new VectorExpressionWriter[outputKeyLength];
    for (int i=0; i < outputKeyLength; ++i) {
      keyOutputWriters[i]=VectorExpressionWriterFactory.genVectorExpressionWritable(keysDesc.get(i));
      objectInspectors.add(keyOutputWriters[i].getObjectInspector());
    }
    for (int i=0; i < aggregators.length; ++i) {
      aggregators[i].init(conf.getAggregators().get(i));
      objectInspectors.add(aggregators[i].getOutputObjectInspector());
    }
    keyWrappersBatch=VectorHashKeyWrapperBatch.compileKeyWrapperBatch(keyExpressions);
    aggregationBatchInfo=new VectorAggregationBufferBatch();
    aggregationBatchInfo.compileAggregationBatchInfo(aggregators);
    LOG.info("VectorGroupByOperator is vector output {}",isVectorOutput);
    outputObjInspector=ObjectInspectorFactory.getStandardStructObjectInspector(outputFieldNames,objectInspectors);
    if (isVectorOutput) {
      vrbCtx=new VectorizedRowBatchCtx();
      vrbCtx.init((StructObjectInspector)outputObjInspector,vOutContext.getScratchColumnTypeNames());
      outputBatch=vrbCtx.createVectorizedRowBatch();
      vectorAssignRow=new VectorAssignRow();
      vectorAssignRow.init((StructObjectInspector)outputObjInspector,vOutContext.getProjectedColumns());
    }
  }
 catch (  HiveException he) {
    throw he;
  }
catch (  Throwable e) {
    throw new HiveException(e);
  }
  forwardCache=new Object[outputKeyLength + aggregators.length];
switch (conf.getVectorDesc().getProcessingMode()) {
case GLOBAL:
    Preconditions.checkState(outputKeyLength == 0);
  processingMode=this.new ProcessingModeGlobalAggregate();
break;
case HASH:
processingMode=this.new ProcessingModeHashAggregate();
break;
case MERGE_PARTIAL:
processingMode=this.new ProcessingModeReduceMergePartial();
break;
case STREAMING:
processingMode=this.new ProcessingModeStreaming();
break;
default :
throw new RuntimeException("Unsupported vector GROUP BY processing mode " + conf.getVectorDesc().getProcessingMode().name());
}
processingMode.initialize(hconf);
}
