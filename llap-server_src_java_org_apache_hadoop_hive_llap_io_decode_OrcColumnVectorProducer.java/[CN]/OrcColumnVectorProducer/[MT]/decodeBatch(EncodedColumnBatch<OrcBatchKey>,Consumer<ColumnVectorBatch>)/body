{
  String fileName=batch.batchKey.file;
  try {
    OrcFileMetadata fileMetadata=metadataCache.getFileMetadata(fileName);
    OrcBatchKey stripeKey=batch.batchKey.clone();
    stripeKey.rgIx=0;
    OrcStripeMetadata stripeMetadata=metadataCache.getStripeMetadata(stripeKey);
    int rgIdx=batch.batchKey.rgIx;
    OrcProto.RowIndexEntry rowIndex=stripeMetadata.getRowIndexes()[0].getEntry(rgIdx);
    long nonNullRowCount=getRowCount(rowIndex);
    int maxBatchesRG=(int)((nonNullRowCount / VectorizedRowBatch.DEFAULT_SIZE) + 1);
    int batchSize=VectorizedRowBatch.DEFAULT_SIZE;
    int numCols=batch.columnIxs.length;
    RecordReaderImpl.TreeReader[] columnStreams=createTreeReaders(numCols,batch,fileMetadata,stripeMetadata);
    for (int i=0; i < maxBatchesRG; i++) {
      ColumnVectorBatch cvb=new ColumnVectorBatch(batch.columnIxs.length);
      if (i == maxBatchesRG - 1) {
        batchSize=(int)(nonNullRowCount % VectorizedRowBatch.DEFAULT_SIZE);
        cvb.size=batchSize;
      }
      for (int idx=0; idx < batch.columnIxs.length; idx++) {
        cvb.cols[idx]=(ColumnVector)columnStreams[idx].nextVector(null,batchSize);
      }
      downstreamConsumer.consumeData(cvb);
    }
  }
 catch (  IOException|CloneNotSupportedException e) {
    downstreamConsumer.setError(e);
  }
}
