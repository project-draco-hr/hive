{
  String file=batch.batchKey.file;
  RecordReaderImpl.TreeReader[] treeReaders=new RecordReaderImpl.TreeReader[numCols];
  for (int i=0; i < numCols; i++) {
    int colIx=batch.columnIxs[i];
    int rgIdx=batch.batchKey.rgIx;
    EncodedColumnBatch.StreamBuffer[] streamBuffers=batch.columnData[i];
    OrcProto.Type colType=fileMetadata.getTypes().get(colIx);
    CompressionCodec codec=fileMetadata.getCompressionCodec();
    int bufferSize=fileMetadata.getCompressionBufferSize();
    OrcProto.ColumnEncoding columnEncoding=stripeMetadata.getEncodings().get(colIx);
    OrcProto.RowIndex rowIndex=stripeMetadata.getRowIndexes()[colIx];
    OrcProto.RowIndexEntry rowIndexEntry=rowIndex.getEntry(rgIdx);
    EncodedColumnBatch.StreamBuffer present=null;
    EncodedColumnBatch.StreamBuffer data=null;
    EncodedColumnBatch.StreamBuffer dictionary=null;
    EncodedColumnBatch.StreamBuffer lengths=null;
    EncodedColumnBatch.StreamBuffer secondary=null;
    for (    EncodedColumnBatch.StreamBuffer streamBuffer : streamBuffers) {
switch (streamBuffer.streamKind) {
case 0:
        present=streamBuffer;
      break;
case 1:
    data=streamBuffer;
  break;
case 2:
lengths=streamBuffer;
break;
case 3:
dictionary=streamBuffer;
break;
case 5:
secondary=streamBuffer;
break;
default :
throw new IOException("Unexpected stream kind: " + streamBuffer.streamKind);
}
}
switch (colType.getKind()) {
case BINARY:
treeReaders[i]=BinaryStreamReader.builder().setFileName(file).setColumnIndex(colIx).setPresentStream(present).setDataStream(data).setLengthStream(lengths).setCompressionCodec(codec).setBufferSize(bufferSize).setRowIndex(rowIndexEntry).setColumnEncoding(columnEncoding).build();
break;
case BOOLEAN:
treeReaders[i]=BooleanStreamReader.builder().setFileName(file).setColumnIndex(colIx).setPresentStream(present).setDataStream(data).setCompressionCodec(codec).setBufferSize(bufferSize).setRowIndex(rowIndexEntry).build();
break;
case BYTE:
treeReaders[i]=ByteStreamReader.builder().setFileName(file).setColumnIndex(colIx).setPresentStream(present).setDataStream(data).setCompressionCodec(codec).setBufferSize(bufferSize).setRowIndex(rowIndexEntry).build();
break;
case SHORT:
treeReaders[i]=ShortStreamReader.builder().setFileName(file).setColumnIndex(colIx).setPresentStream(present).setDataStream(data).setCompressionCodec(codec).setBufferSize(bufferSize).setRowIndex(rowIndexEntry).setColumnEncoding(columnEncoding).build();
break;
case INT:
treeReaders[i]=IntStreamReader.builder().setFileName(file).setColumnIndex(colIx).setPresentStream(present).setDataStream(data).setCompressionCodec(codec).setBufferSize(bufferSize).setRowIndex(rowIndexEntry).setColumnEncoding(columnEncoding).build();
break;
case LONG:
treeReaders[i]=LongStreamReader.builder().setFileName(file).setColumnIndex(colIx).setPresentStream(present).setDataStream(data).setCompressionCodec(codec).setBufferSize(bufferSize).setRowIndex(rowIndexEntry).setColumnEncoding(columnEncoding).skipCorrupt(skipCorrupt).build();
break;
case FLOAT:
treeReaders[i]=FloatStreamReader.builder().setFileName(file).setColumnIndex(colIx).setPresentStream(present).setDataStream(data).setCompressionCodec(codec).setBufferSize(bufferSize).setRowIndex(rowIndexEntry).build();
break;
case DOUBLE:
treeReaders[i]=DoubleStreamReader.builder().setFileName(file).setColumnIndex(colIx).setPresentStream(present).setDataStream(data).setCompressionCodec(codec).setBufferSize(bufferSize).setRowIndex(rowIndexEntry).build();
break;
case CHAR:
case VARCHAR:
treeReaders[i]=CharacterStreamReader.builder().setFileName(file).setColumnIndex(colIx).setMaxLength(colType.getMaximumLength()).setCharacterType(colType).setPresentStream(present).setDataStream(data).setLengthStream(lengths).setDictionaryStream(dictionary).setCompressionCodec(codec).setBufferSize(bufferSize).setRowIndex(rowIndexEntry).setColumnEncoding(columnEncoding).build();
break;
case STRING:
treeReaders[i]=StringStreamReader.builder().setFileName(file).setColumnIndex(colIx).setPresentStream(present).setDataStream(data).setLengthStream(lengths).setDictionaryStream(dictionary).setCompressionCodec(codec).setBufferSize(bufferSize).setRowIndex(rowIndexEntry).setColumnEncoding(columnEncoding).build();
break;
case DECIMAL:
treeReaders[i]=DecimalStreamReader.builder().setFileName(file).setColumnIndex(colIx).setPrecision(colType.getPrecision()).setScale(colType.getScale()).setPresentStream(present).setValueStream(data).setScaleStream(secondary).setCompressionCodec(codec).setBufferSize(bufferSize).setRowIndex(rowIndexEntry).setColumnEncoding(columnEncoding).build();
break;
case TIMESTAMP:
treeReaders[i]=TimestampStreamReader.builder().setFileName(file).setColumnIndex(colIx).setPresentStream(present).setSecondsStream(data).setNanosStream(secondary).setCompressionCodec(codec).setBufferSize(bufferSize).setRowIndex(rowIndexEntry).setColumnEncoding(columnEncoding).skipCorrupt(skipCorrupt).build();
break;
case DATE:
treeReaders[i]=DateStreamReader.builder().setFileName(file).setColumnIndex(colIx).setPresentStream(present).setDataStream(data).setCompressionCodec(codec).setBufferSize(bufferSize).setRowIndex(rowIndexEntry).setColumnEncoding(columnEncoding).build();
break;
default :
throw new UnsupportedOperationException("Data type not supported yet! " + colType);
}
}
return treeReaders;
}
