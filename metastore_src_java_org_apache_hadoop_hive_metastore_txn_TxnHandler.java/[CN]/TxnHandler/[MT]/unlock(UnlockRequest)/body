{
  try {
    Connection dbConn=null;
    Statement stmt=null;
    long extLockId=rqst.getLockid();
    try {
      dbConn=getDbConn(Connection.TRANSACTION_READ_COMMITTED);
      stmt=dbConn.createStatement();
      String s="delete from HIVE_LOCKS where hl_lock_ext_id = " + extLockId + " AND hl_txnid = 0";
      LOG.debug("Going to execute update <" + s + ">");
      int rc=stmt.executeUpdate(s);
      if (rc < 1) {
        LOG.debug("Going to rollback");
        dbConn.rollback();
        Long txnid=getTxnIdFromLockId(dbConn,extLockId);
        if (txnid == null) {
          LOG.error("No lock found for unlock(" + rqst + ")");
          throw new NoSuchLockException("No such lock " + JavaUtils.lockIdToString(extLockId));
        }
        if (txnid != 0) {
          String msg="Unlocking locks associated with transaction" + " not permitted.  Lockid " + JavaUtils.lockIdToString(extLockId) + " is associated with "+ "transaction "+ JavaUtils.txnIdToString(txnid);
          LOG.error(msg);
          throw new TxnOpenException(msg);
        }
        if (txnid == 0) {
          String msg="Found lock " + JavaUtils.lockIdToString(extLockId) + " with "+ JavaUtils.txnIdToString(txnid);
          LOG.error(msg);
          throw new MetaException(msg);
        }
      }
      LOG.debug("Going to commit");
      dbConn.commit();
    }
 catch (    SQLException e) {
      LOG.debug("Going to rollback");
      rollbackDBConn(dbConn);
      checkRetryable(dbConn,e,"unlock(" + rqst + ")");
      throw new MetaException("Unable to update transaction database " + JavaUtils.lockIdToString(extLockId) + " "+ StringUtils.stringifyException(e));
    }
 finally {
      closeStmt(stmt);
      closeDbConn(dbConn);
    }
  }
 catch (  RetryException e) {
    unlock(rqst);
  }
}
