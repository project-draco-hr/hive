{
  List<LockInfo> locksBeingChecked=getLockInfoFromLockId(dbConn,extLockId);
  LockResponse response=new LockResponse();
  response.setLockid(extLockId);
  LOG.debug("checkLock(): Setting savepoint. extLockId=" + JavaUtils.lockIdToString(extLockId));
  Savepoint save=dbConn.setSavepoint();
  StringBuilder query=new StringBuilder("select hl_lock_ext_id, " + "hl_lock_int_id, hl_db, hl_table, hl_partition, hl_lock_state, " + "hl_lock_type, hl_txnid from HIVE_LOCKS where hl_db in (");
  Set<String> strings=new HashSet<String>(locksBeingChecked.size());
  for (  LockInfo info : locksBeingChecked) {
    strings.add(info.db);
  }
  boolean first=true;
  for (  String s : strings) {
    if (first)     first=false;
 else     query.append(", ");
    query.append('\'');
    query.append(s);
    query.append('\'');
  }
  query.append(")");
  boolean sawNull=false;
  strings.clear();
  for (  LockInfo info : locksBeingChecked) {
    if (info.table == null) {
      sawNull=true;
      break;
    }
 else {
      strings.add(info.table);
    }
  }
  if (!sawNull) {
    query.append(" and (hl_table is null or hl_table in(");
    first=true;
    for (    String s : strings) {
      if (first)       first=false;
 else       query.append(", ");
      query.append('\'');
      query.append(s);
      query.append('\'');
    }
    query.append("))");
    sawNull=false;
    strings.clear();
    for (    LockInfo info : locksBeingChecked) {
      if (info.partition == null) {
        sawNull=true;
        break;
      }
 else {
        strings.add(info.partition);
      }
    }
    if (!sawNull) {
      query.append(" and (hl_partition is null or hl_partition in(");
      first=true;
      for (      String s : strings) {
        if (first)         first=false;
 else         query.append(", ");
        query.append('\'');
        query.append(s);
        query.append('\'');
      }
      query.append("))");
    }
  }
  query.append(" and hl_lock_ext_id <= ").append(extLockId);
  LOG.debug("Going to execute query <" + query.toString() + ">");
  Statement stmt=null;
  try {
    stmt=dbConn.createStatement();
    ResultSet rs=stmt.executeQuery(query.toString());
    SortedSet<LockInfo> lockSet=new TreeSet<LockInfo>(new LockInfoComparator());
    while (rs.next()) {
      lockSet.add(new LockInfo(rs));
    }
    LockInfo[] locks=lockSet.toArray(new LockInfo[lockSet.size()]);
    if (LOG.isDebugEnabled()) {
      LOG.debug("Locks to check(full): ");
      for (      LockInfo info : locks) {
        LOG.debug("  " + info);
      }
    }
    for (    LockInfo info : locksBeingChecked) {
      int index=-1;
      for (int i=0; i < locks.length; i++) {
        if (locks[i].equals(info)) {
          index=i;
          break;
        }
      }
      if (index == -1) {
        LOG.debug("Going to rollback");
        dbConn.rollback();
        throw new MetaException("How did we get here, we heartbeated our lock before we started! ( " + info + ")");
      }
      if (locks[index].state == LockState.ACQUIRED) {
        continue;
      }
      boolean acquired=false;
      for (int i=index - 1; i >= 0; i--) {
        if (!locks[index].db.equals(locks[i].db)) {
          continue;
        }
        if (locks[index].table != null && locks[i].table != null && !locks[index].table.equals(locks[i].table)) {
          continue;
        }
        if (locks[index].partition != null && locks[i].partition != null && !locks[index].partition.equals(locks[i].partition)) {
          continue;
        }
        LockAction lockAction=jumpTable.get(locks[index].type).get(locks[i].type).get(locks[i].state);
        LOG.debug("desired Lock: " + info + " checked Lock: "+ locks[i]+ " action: "+ lockAction);
switch (lockAction) {
case WAIT:
          if (!ignoreConflict(info,locks[i])) {
            wait(dbConn,save);
            LOG.debug("Going to commit");
            dbConn.commit();
            response.setState(LockState.WAITING);
            LOG.debug("Lock(" + info + ") waiting for Lock("+ locks[i]+ ")");
            return response;
          }
case ACQUIRE:
        acquire(dbConn,stmt,extLockId,info);
      acquired=true;
    break;
case KEEP_LOOKING:
  continue;
}
if (acquired) break;
}
if (!acquired) acquire(dbConn,stmt,extLockId,info);
}
LOG.debug("Going to commit");
dbConn.commit();
response.setState(LockState.ACQUIRED);
}
  finally {
closeStmt(stmt);
}
return response;
}
