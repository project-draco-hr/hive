{
  boolean success=false;
  Connection dbConn=null;
  try {
    Statement stmt=null;
    ResultSet rs=null;
    ResultSet lockHandle=null;
    try {
      lockInternal();
      dbConn=getDbConn(Connection.TRANSACTION_READ_COMMITTED);
      long txnid=rqst.getTxnid();
      stmt=dbConn.createStatement();
      if (isValidTxn(txnid)) {
        lockHandle=lockTransactionRecord(stmt,txnid,TXN_OPEN);
        if (lockHandle == null) {
          ensureValidTxn(dbConn,txnid,stmt);
          shouldNeverHappen(txnid);
        }
      }
      String s=addForUpdateClause("select nl_next from NEXT_LOCK_ID");
      LOG.debug("Going to execute query <" + s + ">");
      rs=stmt.executeQuery(s);
      if (!rs.next()) {
        LOG.debug("Going to rollback");
        dbConn.rollback();
        throw new MetaException("Transaction tables not properly " + "initialized, no record found in next_lock_id");
      }
      long extLockId=rs.getLong(1);
      s="update NEXT_LOCK_ID set nl_next = " + (extLockId + 1);
      LOG.debug("Going to execute update <" + s + ">");
      stmt.executeUpdate(s);
      if (txnid > 0) {
        for (        LockComponent lc : rqst.getComponent()) {
          if (lc.isSetIsAcid() && !lc.isIsAcid()) {
            continue;
          }
          boolean updateTxnComponents;
          if (!lc.isSetOperationType()) {
            updateTxnComponents=true;
          }
 else {
switch (lc.getOperationType()) {
case INSERT:
case UPDATE:
case DELETE:
              updateTxnComponents=true;
            break;
case SELECT:
          updateTxnComponents=false;
        break;
default :
      throw new IllegalStateException("Unexpected DataOperationType: " + lc.getOperationType() + " agentInfo="+ rqst.getAgentInfo()+ " "+ JavaUtils.txnIdToString(txnid));
  }
}
if (!updateTxnComponents) {
  continue;
}
String dbName=lc.getDbname();
String tblName=lc.getTablename();
String partName=lc.getPartitionname();
s="insert into TXN_COMPONENTS " + "(tc_txnid, tc_database, tc_table, tc_partition, tc_operation_type) " + "values (" + txnid + ", '"+ dbName+ "', "+ (tblName == null ? "null" : "'" + tblName + "'")+ ", "+ (partName == null ? "null" : "'" + partName + "'")+ ","+ quoteString(OpertaionType.fromDataOperationType(lc.getOperationType()).toString())+ ")";
LOG.debug("Going to execute update <" + s + ">");
int modCount=stmt.executeUpdate(s);
}
}
long intLockId=0;
for (LockComponent lc : rqst.getComponent()) {
if (lc.isSetOperationType() && lc.getOperationType() == DataOperationType.UNSET) {
throw new IllegalStateException("Bug: operationType=" + lc.getOperationType() + " for component "+ lc+ " agentInfo="+ rqst.getAgentInfo());
}
intLockId++;
String dbName=lc.getDbname();
String tblName=lc.getTablename();
String partName=lc.getPartitionname();
LockType lockType=lc.getType();
char lockChar='z';
switch (lockType) {
case EXCLUSIVE:
lockChar=LOCK_EXCLUSIVE;
break;
case SHARED_READ:
lockChar=LOCK_SHARED;
break;
case SHARED_WRITE:
lockChar=LOCK_SEMI_SHARED;
break;
}
long now=getDbTime(dbConn);
s="insert into HIVE_LOCKS " + "(hl_lock_ext_id, hl_lock_int_id, hl_txnid, " + "hl_db, "+ "hl_table, "+ "hl_partition, "+ "hl_lock_state, hl_lock_type, "+ "hl_last_heartbeat, "+ "hl_user, "+ "hl_host, "+ "hl_agent_info) values(" + extLockId + ", "+ intLockId+ ","+ txnid+ ", "+ quoteString(dbName)+ ", "+ valueOrNullLiteral(tblName)+ ", "+ valueOrNullLiteral(partName)+ ", "+ quoteChar(LOCK_WAITING)+ ", "+ quoteChar(lockChar)+ ", "+ (isValidTxn(txnid) ? 0 : now)+ ", "+ valueOrNullLiteral(rqst.getUser())+ ", "+ valueOrNullLiteral(rqst.getHostname())+ ", "+ valueOrNullLiteral(rqst.getAgentInfo())+ ")";
LOG.debug("Going to execute update <" + s + ">");
stmt.executeUpdate(s);
}
dbConn.commit();
success=true;
return new ConnectionLockIdPair(dbConn,extLockId);
}
 catch (SQLException e) {
LOG.debug("Going to rollback");
rollbackDBConn(dbConn);
checkRetryable(dbConn,e,"enqueueLockWithRetry(" + rqst + ")");
throw new MetaException("Unable to update transaction database " + StringUtils.stringifyException(e));
}
 finally {
close(lockHandle);
close(rs,stmt,null);
if (!success) {
closeDbConn(dbConn);
}
unlockInternal();
}
}
 catch (RetryException e) {
return enqueueLockWithRetry(rqst);
}
}
