{
  boolean success=false;
  Connection dbConn=null;
  try {
    Statement stmt=null;
    ResultSet rs=null;
    ResultSet lockHandle=null;
    try {
      lockInternal();
      dbConn=getDbConn(Connection.TRANSACTION_READ_COMMITTED);
      long txnid=rqst.getTxnid();
      stmt=dbConn.createStatement();
      if (isValidTxn(txnid)) {
        lockHandle=lockTransactionRecord(stmt,txnid,TXN_OPEN);
        if (lockHandle == null) {
          ensureValidTxn(dbConn,txnid,stmt);
          shouldNeverHappen(txnid);
        }
      }
      String s=addForUpdateClause("select nl_next from NEXT_LOCK_ID");
      LOG.debug("Going to execute query <" + s + ">");
      rs=stmt.executeQuery(s);
      if (!rs.next()) {
        LOG.debug("Going to rollback");
        dbConn.rollback();
        throw new MetaException("Transaction tables not properly " + "initialized, no record found in next_lock_id");
      }
      long extLockId=rs.getLong(1);
      s="update NEXT_LOCK_ID set nl_next = " + (extLockId + 1);
      LOG.debug("Going to execute update <" + s + ">");
      stmt.executeUpdate(s);
      if (txnid > 0) {
        for (        LockComponent lc : rqst.getComponent()) {
          String dbName=lc.getDbname();
          String tblName=lc.getTablename();
          String partName=lc.getPartitionname();
          s="insert into TXN_COMPONENTS " + "(tc_txnid, tc_database, tc_table, tc_partition) " + "values (" + txnid + ", '"+ dbName+ "', "+ (tblName == null ? "null" : "'" + tblName + "'")+ ", "+ (partName == null ? "null" : "'" + partName + "'")+ ")";
          LOG.debug("Going to execute update <" + s + ">");
          stmt.executeUpdate(s);
        }
      }
      long intLockId=0;
      for (      LockComponent lc : rqst.getComponent()) {
        intLockId++;
        String dbName=lc.getDbname();
        String tblName=lc.getTablename();
        String partName=lc.getPartitionname();
        LockType lockType=lc.getType();
        char lockChar='z';
switch (lockType) {
case EXCLUSIVE:
          lockChar=LOCK_EXCLUSIVE;
        break;
case SHARED_READ:
      lockChar=LOCK_SHARED;
    break;
case SHARED_WRITE:
  lockChar=LOCK_SEMI_SHARED;
break;
}
long now=getDbTime(dbConn);
s="insert into HIVE_LOCKS " + " (hl_lock_ext_id, hl_lock_int_id, hl_txnid, hl_db, hl_table, " + "hl_partition, hl_lock_state, hl_lock_type, hl_last_heartbeat, hl_user, hl_host)"+ " values (" + extLockId + ", "+ +intLockId+ ","+ txnid+ ", '"+ dbName+ "', "+ (tblName == null ? "null" : "'" + tblName + "'")+ ", "+ (partName == null ? "null" : "'" + partName + "'")+ ", '"+ LOCK_WAITING+ "', "+ "'"+ lockChar+ "', "+ (isValidTxn(txnid) ? 0 : now)+ ", '"+ rqst.getUser()+ "', '"+ rqst.getHostname()+ "')";
LOG.debug("Going to execute update <" + s + ">");
stmt.executeUpdate(s);
}
dbConn.commit();
success=true;
return new ConnectionLockIdPair(dbConn,extLockId);
}
 catch (SQLException e) {
LOG.debug("Going to rollback");
rollbackDBConn(dbConn);
checkRetryable(dbConn,e,"enqueueLockWithRetry(" + rqst + ")");
throw new MetaException("Unable to update transaction database " + StringUtils.stringifyException(e));
}
 finally {
close(lockHandle);
close(rs,stmt,null);
if (!success) {
closeDbConn(dbConn);
}
unlockInternal();
}
}
 catch (RetryException e) {
return enqueueLockWithRetry(rqst);
}
}
