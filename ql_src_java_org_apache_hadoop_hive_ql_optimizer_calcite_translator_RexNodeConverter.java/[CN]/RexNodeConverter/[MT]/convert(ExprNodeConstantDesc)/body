{
  RexBuilder rexBuilder=cluster.getRexBuilder();
  RelDataTypeFactory dtFactory=rexBuilder.getTypeFactory();
  PrimitiveTypeInfo hiveType=(PrimitiveTypeInfo)literal.getTypeInfo();
  RelDataType calciteDataType=TypeConverter.convert(hiveType,dtFactory);
  PrimitiveCategory hiveTypeCategory=hiveType.getPrimitiveCategory();
  ConstantObjectInspector coi=literal.getWritableObjectInspector();
  Object value=ObjectInspectorUtils.copyToStandardJavaObject(coi.getWritableConstantValue(),coi);
  RexNode calciteLiteral=null;
switch (hiveTypeCategory) {
case BOOLEAN:
    calciteLiteral=rexBuilder.makeLiteral(((Boolean)value).booleanValue());
  break;
case BYTE:
byte[] byteArray=new byte[]{(Byte)value};
ByteString bs=new ByteString(byteArray);
calciteLiteral=rexBuilder.makeBinaryLiteral(bs);
break;
case SHORT:
calciteLiteral=rexBuilder.makeExactLiteral(new BigDecimal((Short)value),calciteDataType);
break;
case INT:
calciteLiteral=rexBuilder.makeExactLiteral(new BigDecimal((Integer)value));
break;
case LONG:
calciteLiteral=rexBuilder.makeBigintLiteral(new BigDecimal((Long)value));
break;
case DECIMAL:
if (value instanceof HiveDecimal) {
value=((HiveDecimal)value).bigDecimalValue();
}
 else if (value instanceof Decimal128) {
value=((Decimal128)value).toBigDecimal();
}
if (value == null) {
throw new CalciteSemanticException("Expression " + literal.getExprString() + " is not a valid decimal");
}
BigDecimal bd=(BigDecimal)value;
BigInteger unscaled=bd.unscaledValue();
if (unscaled.compareTo(MIN_LONG_BI) >= 0 && unscaled.compareTo(MAX_LONG_BI) <= 0) {
calciteLiteral=rexBuilder.makeExactLiteral(bd);
}
 else {
RelDataType relType=cluster.getTypeFactory().createSqlType(SqlTypeName.DECIMAL,bd.scale(),unscaled.toString().length());
calciteLiteral=rexBuilder.makeExactLiteral(bd,relType);
}
break;
case FLOAT:
calciteLiteral=rexBuilder.makeApproxLiteral(new BigDecimal((Float)value),calciteDataType);
break;
case DOUBLE:
calciteLiteral=rexBuilder.makeApproxLiteral(new BigDecimal((Double)value),calciteDataType);
break;
case CHAR:
if (value instanceof HiveChar) value=((HiveChar)value).getValue();
calciteLiteral=rexBuilder.makeLiteral((String)value);
break;
case VARCHAR:
if (value instanceof HiveVarchar) value=((HiveVarchar)value).getValue();
calciteLiteral=rexBuilder.makeLiteral((String)value);
break;
case STRING:
calciteLiteral=rexBuilder.makeLiteral((String)value);
break;
case DATE:
Calendar cal=new GregorianCalendar();
cal.setTime((Date)value);
calciteLiteral=rexBuilder.makeDateLiteral(cal);
break;
case TIMESTAMP:
Calendar c=null;
if (value instanceof Calendar) {
c=(Calendar)value;
}
 else {
c=Calendar.getInstance();
c.setTimeInMillis(((Timestamp)value).getTime());
}
calciteLiteral=rexBuilder.makeTimestampLiteral(c,RelDataType.PRECISION_NOT_SPECIFIED);
break;
case BINARY:
case VOID:
case UNKNOWN:
default :
throw new RuntimeException("UnSupported Literal");
}
return calciteLiteral;
}
