{
  RexBuilder rexBuilder=cluster.getRexBuilder();
  RelDataTypeFactory dtFactory=rexBuilder.getTypeFactory();
  PrimitiveTypeInfo hiveType=(PrimitiveTypeInfo)literal.getTypeInfo();
  RelDataType calciteDataType=TypeConverter.convert(hiveType,dtFactory);
  PrimitiveCategory hiveTypeCategory=hiveType.getPrimitiveCategory();
  ConstantObjectInspector coi=literal.getWritableObjectInspector();
  Object value=ObjectInspectorUtils.copyToStandardJavaObject(coi.getWritableConstantValue(),coi);
  RexNode calciteLiteral=null;
  if (value == null) {
    hiveTypeCategory=PrimitiveCategory.VOID;
  }
switch (hiveTypeCategory) {
case BOOLEAN:
    calciteLiteral=rexBuilder.makeLiteral(((Boolean)value).booleanValue());
  break;
case BYTE:
calciteLiteral=rexBuilder.makeExactLiteral(new BigDecimal((Byte)value),calciteDataType);
break;
case SHORT:
calciteLiteral=rexBuilder.makeExactLiteral(new BigDecimal((Short)value),calciteDataType);
break;
case INT:
calciteLiteral=rexBuilder.makeExactLiteral(new BigDecimal((Integer)value));
break;
case LONG:
calciteLiteral=rexBuilder.makeBigintLiteral(new BigDecimal((Long)value));
break;
case DECIMAL:
if (value instanceof HiveDecimal) {
value=((HiveDecimal)value).bigDecimalValue();
}
 else if (value instanceof Decimal128) {
value=((Decimal128)value).toBigDecimal();
}
if (value == null) {
throw new CalciteSemanticException("Expression " + literal.getExprString() + " is not a valid decimal",UnsupportedFeature.Invalid_decimal);
}
BigDecimal bd=(BigDecimal)value;
BigInteger unscaled=bd.unscaledValue();
if (unscaled.compareTo(MIN_LONG_BI) >= 0 && unscaled.compareTo(MAX_LONG_BI) <= 0) {
calciteLiteral=rexBuilder.makeExactLiteral(bd);
}
 else {
RelDataType relType=cluster.getTypeFactory().createSqlType(SqlTypeName.DECIMAL,unscaled.toString().length(),bd.scale());
calciteLiteral=rexBuilder.makeExactLiteral(bd,relType);
}
break;
case FLOAT:
calciteLiteral=rexBuilder.makeApproxLiteral(new BigDecimal((Float)value),calciteDataType);
break;
case DOUBLE:
if (Double.isNaN((Double)value)) {
throw new CalciteSemanticException("NaN",UnsupportedFeature.Invalid_decimal);
}
calciteLiteral=rexBuilder.makeApproxLiteral(new BigDecimal((Double)value),calciteDataType);
break;
case CHAR:
if (value instanceof HiveChar) {
value=((HiveChar)value).getValue();
}
calciteLiteral=rexBuilder.makeCharLiteral(asUnicodeString((String)value));
break;
case VARCHAR:
if (value instanceof HiveVarchar) {
value=((HiveVarchar)value).getValue();
}
calciteLiteral=rexBuilder.makeCharLiteral(asUnicodeString((String)value));
break;
case STRING:
calciteLiteral=rexBuilder.makeCharLiteral(asUnicodeString((String)value));
break;
case DATE:
Calendar cal=new GregorianCalendar();
cal.setTime((Date)value);
calciteLiteral=rexBuilder.makeDateLiteral(cal);
break;
case TIMESTAMP:
Calendar c=null;
if (value instanceof Calendar) {
c=(Calendar)value;
}
 else {
c=Calendar.getInstance();
c.setTimeInMillis(((Timestamp)value).getTime());
}
calciteLiteral=rexBuilder.makeTimestampLiteral(c,RelDataType.PRECISION_NOT_SPECIFIED);
break;
case INTERVAL_YEAR_MONTH:
BigDecimal totalMonths=BigDecimal.valueOf(((HiveIntervalYearMonth)value).getTotalMonths());
calciteLiteral=rexBuilder.makeIntervalLiteral(totalMonths,new SqlIntervalQualifier(TimeUnit.YEAR,TimeUnit.MONTH,new SqlParserPos(1,1)));
break;
case INTERVAL_DAY_TIME:
throw new CalciteSemanticException("INTERVAL_DAY_TIME is not well supported",UnsupportedFeature.Invalid_interval);
case VOID:
calciteLiteral=cluster.getRexBuilder().makeLiteral(null,cluster.getTypeFactory().createSqlType(SqlTypeName.NULL),true);
break;
case BINARY:
case UNKNOWN:
default :
throw new RuntimeException("UnSupported Literal");
}
return calciteLiteral;
}
