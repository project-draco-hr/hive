{
  final int sysFieldCount=sysFieldList.size();
  final RelOptCluster cluster=inputs.get(0).getCluster();
  final RexBuilder rexBuilder=cluster.getRexBuilder();
  final RelDataTypeFactory typeFactory=cluster.getTypeFactory();
  final ImmutableBitSet[] inputsRange=new ImmutableBitSet[inputs.size()];
  int totalFieldCount=0;
  for (int i=0; i < inputs.size(); i++) {
    final int firstField=totalFieldCount + sysFieldCount;
    totalFieldCount=firstField + inputs.get(i).getRowType().getFieldCount();
    inputsRange[i]=ImmutableBitSet.range(firstField,totalFieldCount);
  }
  int[] adjustments=new int[totalFieldCount];
  for (int i=0; i < inputs.size(); i++) {
    final int adjustment=inputsRange[i].nextSetBit(0);
    for (int j=adjustment; j < inputsRange[i].length(); j++) {
      adjustments[j]=-adjustment;
    }
  }
  if (condition instanceof RexCall) {
    RexCall call=(RexCall)condition;
    if (call.getOperator() == SqlStdOperatorTable.AND) {
      for (      RexNode operand : call.getOperands()) {
        splitJoinCondition(sysFieldList,inputs,operand,joinKeys,filterNulls,rangeOp,nonEquiList);
      }
      return;
    }
    RexNode leftKey=null;
    RexNode rightKey=null;
    int leftInput=0;
    int rightInput=0;
    List<RelDataTypeField> leftFields=null;
    List<RelDataTypeField> rightFields=null;
    boolean reverse=false;
    SqlKind kind=call.getKind();
    if ((kind == SqlKind.EQUALS) || (filterNulls != null && kind == SqlKind.IS_NOT_DISTINCT_FROM) || (rangeOp != null && rangeOp.isEmpty() && (kind == SqlKind.GREATER_THAN || kind == SqlKind.GREATER_THAN_OR_EQUAL || kind == SqlKind.LESS_THAN || kind == SqlKind.LESS_THAN_OR_EQUAL))) {
      final List<RexNode> operands=call.getOperands();
      RexNode op0=operands.get(0);
      RexNode op1=operands.get(1);
      final ImmutableBitSet projRefs0=InputFinder.bits(op0);
      final ImmutableBitSet projRefs1=InputFinder.bits(op1);
      boolean foundBothInputs=false;
      for (int i=0; i < inputs.size() && !foundBothInputs; i++) {
        if (projRefs0.intersects(inputsRange[i]) && projRefs0.union(inputsRange[i]).equals(inputsRange[i])) {
          if (leftKey == null) {
            leftKey=op0;
            leftInput=i;
            leftFields=inputs.get(leftInput).getRowType().getFieldList();
          }
 else {
            rightKey=op0;
            rightInput=i;
            rightFields=inputs.get(rightInput).getRowType().getFieldList();
            reverse=true;
            foundBothInputs=true;
          }
        }
 else         if (projRefs1.intersects(inputsRange[i]) && projRefs1.union(inputsRange[i]).equals(inputsRange[i])) {
          if (leftKey == null) {
            leftKey=op1;
            leftInput=i;
            leftFields=inputs.get(leftInput).getRowType().getFieldList();
          }
 else {
            rightKey=op1;
            rightInput=i;
            rightFields=inputs.get(rightInput).getRowType().getFieldList();
            foundBothInputs=true;
          }
        }
      }
      if ((leftKey != null) && (rightKey != null)) {
        rightKey=rightKey.accept(new RelOptUtil.RexInputConverter(rexBuilder,rightFields,rightFields,adjustments));
        leftKey=leftKey.accept(new RelOptUtil.RexInputConverter(rexBuilder,leftFields,leftFields,adjustments));
        RelDataType leftKeyType=leftKey.getType();
        RelDataType rightKeyType=rightKey.getType();
        if (leftKeyType != rightKeyType) {
          RelDataType targetKeyType=typeFactory.leastRestrictive(ImmutableList.of(leftKeyType,rightKeyType));
          if (targetKeyType == null) {
            throw Util.newInternal("Cannot find common type for join keys " + leftKey + " (type "+ leftKeyType+ ") and "+ rightKey+ " (type "+ rightKeyType+ ")");
          }
          if (leftKeyType != targetKeyType) {
            leftKey=rexBuilder.makeCast(targetKeyType,leftKey);
          }
          if (rightKeyType != targetKeyType) {
            rightKey=rexBuilder.makeCast(targetKeyType,rightKey);
          }
        }
      }
    }
    if ((leftKey != null) && (rightKey != null)) {
      addJoinKey(joinKeys.get(leftInput),leftKey,(rangeOp != null) && !rangeOp.isEmpty());
      addJoinKey(joinKeys.get(rightInput),rightKey,(rangeOp != null) && !rangeOp.isEmpty());
      if (filterNulls != null && kind == SqlKind.EQUALS) {
        filterNulls.add(joinKeys.get(leftInput).size() - 1);
      }
      if (rangeOp != null && kind != SqlKind.EQUALS && kind != SqlKind.IS_DISTINCT_FROM) {
        if (reverse) {
          kind=reverse(kind);
        }
        rangeOp.add(op(kind,call.getOperator()));
      }
      return;
    }
  }
  nonEquiList.add(condition);
}
