{
  final int sysFieldCount=sysFieldList.size();
  final RelOptCluster cluster=inputs.get(0).getCluster();
  final RexBuilder rexBuilder=cluster.getRexBuilder();
  final RelDataTypeFactory typeFactory=cluster.getTypeFactory();
  int[] firstFieldInputs=new int[inputs.size()];
  int totalFieldCount=0;
  for (int i=0; i < inputs.size(); i++) {
    firstFieldInputs[i]=totalFieldCount + sysFieldCount;
    totalFieldCount+=sysFieldCount + inputs.get(i).getRowType().getFieldCount();
  }
  int[] adjustments=new int[totalFieldCount];
  for (int i=0; i < inputs.size(); i++) {
    int limit=i == inputs.size() - 1 ? totalFieldCount : firstFieldInputs[i + 1];
    for (int j=firstFieldInputs[i]; j < limit; j++) {
      adjustments[j]=-firstFieldInputs[i];
    }
  }
  if (condition instanceof RexCall) {
    RexCall call=(RexCall)condition;
    if (call.getOperator() == SqlStdOperatorTable.AND) {
      for (      RexNode operand : call.getOperands()) {
        splitJoinCondition(sysFieldList,inputs,operand,joinKeys,filterNulls,rangeOp,nonEquiList);
      }
      return;
    }
    RexNode leftKey=null;
    RexNode rightKey=null;
    int leftInput=0;
    int rightInput=0;
    List<RelDataTypeField> leftFields=null;
    List<RelDataTypeField> rightFields=null;
    boolean reverse=false;
    SqlKind kind=call.getKind();
    if ((kind == SqlKind.EQUALS) || (filterNulls != null && kind == SqlKind.IS_NOT_DISTINCT_FROM) || (rangeOp != null && rangeOp.isEmpty() && (kind == SqlKind.GREATER_THAN || kind == SqlKind.GREATER_THAN_OR_EQUAL || kind == SqlKind.LESS_THAN || kind == SqlKind.LESS_THAN_OR_EQUAL))) {
      final List<RexNode> operands=call.getOperands();
      RexNode op0=operands.get(0);
      RexNode op1=operands.get(1);
      final ImmutableBitSet projRefs0=InputFinder.bits(op0);
      final ImmutableBitSet projRefs1=InputFinder.bits(op1);
      boolean foundBothInputs=false;
      for (int i=0; i < inputs.size() && !foundBothInputs; i++) {
        final int lowerLimit=firstFieldInputs[i];
        final int upperLimit=i == inputs.size() - 1 ? totalFieldCount : firstFieldInputs[i + 1];
        if (projRefs0.nextSetBit(lowerLimit) != -1 && projRefs0.nextSetBit(upperLimit) == -1 && projRefs0.nextSetBit(0) == projRefs0.nextSetBit(lowerLimit) && projRefs0.nextSetBit(lowerLimit) < upperLimit) {
          if (leftKey == null) {
            leftKey=op0;
            leftInput=i;
            leftFields=inputs.get(leftInput).getRowType().getFieldList();
          }
 else {
            rightKey=op0;
            rightInput=i;
            rightFields=inputs.get(rightInput).getRowType().getFieldList();
            reverse=true;
            foundBothInputs=true;
          }
        }
 else         if (projRefs1.nextSetBit(lowerLimit) != -1 && projRefs1.nextSetBit(upperLimit) == -1 && projRefs1.nextSetBit(0) == projRefs1.nextSetBit(lowerLimit) && projRefs1.nextSetBit(lowerLimit) < upperLimit) {
          if (leftKey == null) {
            leftKey=op1;
            leftInput=i;
            leftFields=inputs.get(leftInput).getRowType().getFieldList();
          }
 else {
            rightKey=op1;
            rightInput=i;
            rightFields=inputs.get(rightInput).getRowType().getFieldList();
            foundBothInputs=true;
          }
        }
      }
      if ((leftKey != null) && (rightKey != null)) {
        rightKey=rightKey.accept(new RelOptUtil.RexInputConverter(rexBuilder,rightFields,rightFields,adjustments));
        leftKey=leftKey.accept(new RelOptUtil.RexInputConverter(rexBuilder,leftFields,leftFields,adjustments));
        RelDataType leftKeyType=leftKey.getType();
        RelDataType rightKeyType=rightKey.getType();
        if (leftKeyType != rightKeyType) {
          RelDataType targetKeyType=typeFactory.leastRestrictive(ImmutableList.of(leftKeyType,rightKeyType));
          if (targetKeyType == null) {
            throw Util.newInternal("Cannot find common type for join keys " + leftKey + " (type "+ leftKeyType+ ") and "+ rightKey+ " (type "+ rightKeyType+ ")");
          }
          if (leftKeyType != targetKeyType) {
            leftKey=rexBuilder.makeCast(targetKeyType,leftKey);
          }
          if (rightKeyType != targetKeyType) {
            rightKey=rexBuilder.makeCast(targetKeyType,rightKey);
          }
        }
      }
    }
    if ((rangeOp == null) && ((leftKey == null) || (rightKey == null))) {
      final ImmutableBitSet projRefs=InputFinder.bits(condition);
      leftKey=null;
      rightKey=null;
      boolean foundInput=false;
      for (int i=0; i < inputs.size() && !foundInput; i++) {
        final int lowerLimit=firstFieldInputs[i];
        final int upperLimit=i == inputs.size() - 1 ? totalFieldCount : firstFieldInputs[i + 1];
        if (projRefs.nextSetBit(lowerLimit) < upperLimit) {
          leftInput=i;
          leftFields=inputs.get(leftInput).getRowType().getFieldList();
          leftKey=condition.accept(new RelOptUtil.RexInputConverter(rexBuilder,leftFields,leftFields,adjustments));
          rightKey=rexBuilder.makeLiteral(true);
          kind=SqlKind.EQUALS;
          foundInput=true;
        }
      }
    }
    if ((leftKey != null) && (rightKey != null)) {
      addJoinKey(joinKeys.get(leftInput),leftKey,(rangeOp != null) && !rangeOp.isEmpty());
      addJoinKey(joinKeys.get(rightInput),rightKey,(rangeOp != null) && !rangeOp.isEmpty());
      if (filterNulls != null && kind == SqlKind.EQUALS) {
        filterNulls.add(joinKeys.get(leftInput).size() - 1);
      }
      if (rangeOp != null && kind != SqlKind.EQUALS && kind != SqlKind.IS_DISTINCT_FROM) {
        if (reverse) {
          kind=reverse(kind);
        }
        rangeOp.add(op(kind,call.getOperator()));
      }
      return;
    }
  }
  nonEquiList.add(condition);
}
