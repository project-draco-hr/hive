{
  super(LlapTaskSchedulerService.class.getName());
  this.appCallbackExecutor=createAppCallbackExecutorService();
  this.appClientDelegate=createAppCallbackDelegate(appClient);
  this.clock=appContext.getClock();
  this.containerFactory=new ContainerFactory(appContext,customAppIdIdentifier);
  this.memoryPerInstance=conf.getInt(LlapConfiguration.LLAP_DAEMON_MEMORY_PER_INSTANCE_MB,LlapConfiguration.LLAP_DAEMON_MEMORY_PER_INSTANCE_MB_DEFAULT);
  this.coresPerInstance=conf.getInt(LlapConfiguration.LLAP_DAEMON_VCPUS_PER_INSTANCE,LlapConfiguration.LLAP_DAEMON_VCPUS_PER_INSTANCE_DEFAULT);
  this.executorsPerInstance=conf.getInt(LlapConfiguration.LLAP_DAEMON_NUM_EXECUTORS,LlapConfiguration.LLAP_DAEMON_NUM_EXECUTORS_DEFAULT);
  this.nodeReEnableTimeout=conf.getLong(LlapConfiguration.LLAP_DAEMON_TASK_SCHEDULER_NODE_REENABLE_TIMEOUT_MILLIS,LlapConfiguration.LLAP_DAEMON_TASK_SCHEDULER_NODE_REENABLE_TIMEOUT_MILLIS_DEFAULT);
  int memoryPerExecutor=(int)(memoryPerInstance / (float)executorsPerInstance);
  int coresPerExecutor=(int)(coresPerInstance / (float)executorsPerInstance);
  this.resourcePerExecutor=Resource.newInstance(memoryPerExecutor,coresPerExecutor);
  String instanceId=conf.getTrimmed(LlapConfiguration.LLAP_DAEMON_SERVICE_HOSTS);
  Preconditions.checkNotNull(instanceId,LlapConfiguration.LLAP_DAEMON_SERVICE_HOSTS + " must be defined");
  if (!instanceId.startsWith("@")) {
    initFromRegistry=false;
    String[] hosts=conf.getTrimmedStrings(LlapConfiguration.LLAP_DAEMON_SERVICE_HOSTS);
    Preconditions.checkState(hosts != null && hosts.length != 0,LlapConfiguration.LLAP_DAEMON_SERVICE_HOSTS + "must be defined");
    for (    String host : hosts) {
      InetAddress inetAddress=null;
      try {
        inetAddress=InetAddress.getByName(host);
        if (NetUtils.isLocalAddress(inetAddress)) {
          InetSocketAddress socketAddress=new InetSocketAddress(0);
          socketAddress=NetUtils.getConnectAddress(socketAddress);
          LOG.info("Adding host identified as local: " + host + " as "+ socketAddress.getHostName());
          host=socketAddress.getHostName();
        }
      }
 catch (      UnknownHostException e) {
        LOG.warn("Ignoring resolution issues for host: " + host,e);
      }
      NodeInfo nodeInfo=new NodeInfo(host,BACKOFF_FACTOR,clock);
      activeHosts.put(host,nodeInfo);
      allHosts.put(host,nodeInfo);
    }
    activeHostList=activeHosts.keySet().toArray(new String[activeHosts.size()]);
  }
 else {
    initFromRegistry=true;
  }
  this.containerPort=conf.getInt(LlapConfiguration.LLAP_DAEMON_RPC_PORT,LlapConfiguration.LLAP_DAEMON_RPC_PORT_DEFAULT);
  ExecutorService executorService=Executors.newFixedThreadPool(1,new ThreadFactoryBuilder().setDaemon(true).setNameFormat("LlapScheduler").build());
  executor=MoreExecutors.listeningDecorator(executorService);
  if (activeHosts.size() > 0) {
    LOG.info("Running with configuration: " + "memoryPerInstance=" + memoryPerInstance + ", vCoresPerInstance="+ coresPerInstance+ ", executorsPerInstance="+ executorsPerInstance+ ", resourcePerInstanceInferred="+ resourcePerExecutor+ ", hosts="+ allHosts.keySet()+ ", rpcPort="+ containerPort+ ", nodeReEnableTimeout="+ nodeReEnableTimeout+ ", nodeReEnableBackOffFactor="+ BACKOFF_FACTOR);
  }
 else {
    LOG.info("Running with configuration: " + "memoryPerInstance=" + memoryPerInstance + ", vCoresPerInstance="+ coresPerInstance+ ", executorsPerInstance="+ executorsPerInstance+ ", resourcePerInstanceInferred="+ resourcePerExecutor+ ", hosts=<pending>"+ ", rpcPort=<pending>"+ ", nodeReEnableTimeout="+ nodeReEnableTimeout+ ", nodeReEnableBackOffFactor="+ BACKOFF_FACTOR);
  }
}
