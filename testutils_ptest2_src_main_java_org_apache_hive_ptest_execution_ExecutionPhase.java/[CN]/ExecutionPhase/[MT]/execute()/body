{
  long start=System.currentTimeMillis();
  List<TestBatch> testBatches=Lists.newArrayList();
  for (  TestBatch batch : testBatchSupplier.get()) {
    testBatches.add(batch);
    if (batch.isParallel()) {
      parallelWorkQueue.add(batch);
    }
 else {
      isolatedWorkQueue.add(batch);
    }
  }
  try {
    int expectedNumHosts=hostExecutors.size();
    initalizeHosts();
    do {
      replaceBadHosts(expectedNumHosts);
      List<ListenableFuture<Void>> results=Lists.newArrayList();
      for (      HostExecutor hostExecutor : ImmutableList.copyOf(hostExecutors)) {
        results.add(hostExecutor.submitTests(parallelWorkQueue,isolatedWorkQueue,failedTestResults));
      }
      Futures.allAsList(results).get();
    }
 while (!(parallelWorkQueue.isEmpty() && isolatedWorkQueue.isEmpty()));
    for (    TestBatch batch : testBatches) {
      File batchLogDir;
      if (failedTestResults.contains(batch)) {
        batchLogDir=new File(failedLogDir,batch.getName());
      }
 else {
        batchLogDir=new File(succeededLogDir,batch.getName());
      }
      JUnitReportParser parser=new JUnitReportParser(logger,batchLogDir);
      executedTests.addAll(parser.getExecutedTests());
      failedTests.addAll(parser.getFailedTests());
    }
  }
  finally {
    long elapsed=System.currentTimeMillis() - start;
    logger.info("PERF: exec phase " + TimeUnit.MINUTES.convert(elapsed,TimeUnit.MILLISECONDS) + " minutes");
  }
}
