{
  checkInputParams(table,families);
  zkUtil.setUpZnodesForTable(table,families);
  long nextId=zkUtil.nextId(table);
  long expireTimestamp=zkUtil.getTimeStamp();
  Transaction transaction=new Transaction(table,families,nextId,expireTimestamp);
  if (keepAlive != -1) {
    transaction.setKeepAlive(keepAlive);
  }
 else {
    transaction.setKeepAlive(DEFAULT_WRITE_TRANSACTION_TIMEOUT);
  }
  refreshTransactionList(transaction.getTableName());
  String lockPath=prepareLockNode(table);
  WriteLock wLock=new WriteLock(zkUtil.getSession(),lockPath,Ids.OPEN_ACL_UNSAFE);
  RMLockListener myLockListener=new RMLockListener();
  wLock.setLockListener(myLockListener);
  try {
    boolean lockGrabbed=wLock.lock();
    if (lockGrabbed == false) {
      throw new IOException("Unable to obtain lock while beginning transaction. " + transaction.toString());
    }
 else {
      List<String> colFamilies=transaction.getColumnFamilies();
      FamilyRevision revisionData=transaction.getFamilyRevisionInfo();
      for (      String cfamily : colFamilies) {
        String path=PathUtil.getRunningTxnInfoPath(baseDir,table,cfamily);
        zkUtil.updateData(path,revisionData,ZKUtil.UpdateMode.APPEND);
      }
    }
  }
 catch (  KeeperException e) {
    throw new IOException("Exception while obtaining lock.",e);
  }
catch (  InterruptedException e) {
    throw new IOException("Exception while obtaining lock.",e);
  }
 finally {
    wLock.unlock();
  }
  return transaction;
}
