{
  String[] requestedHosts=request.requestedHosts;
  if (LOG.isDebugEnabled()) {
    LOG.debug("selectingHost for task={} on hosts={}",request.task,Arrays.toString(requestedHosts));
  }
  long schedulerAttemptTime=clock.getTime();
  readLock.lock();
  try {
    if (getTotalResources().getMemory() <= 0) {
      return SELECT_HOST_RESULT_INADEQUATE_TOTAL_CAPACITY;
    }
    boolean shouldDelayForLocality=request.shouldDelayForLocality(schedulerAttemptTime);
    LOG.debug("ShouldDelayForLocality={} for task={} on hosts={}",shouldDelayForLocality,request.task,Arrays.toString(requestedHosts));
    if (requestedHosts != null && requestedHosts.length > 0) {
      int prefHostCount=-1;
      boolean requestedHostsWillBecomeAvailable=false;
      for (      String host : requestedHosts) {
        prefHostCount++;
        Set<ServiceInstance> instances=activeInstances.getByHost(host);
        if (!instances.isEmpty()) {
          for (          ServiceInstance inst : instances) {
            NodeInfo nodeInfo=instanceToNodeMap.get(inst.getWorkerIdentity());
            if (nodeInfo != null) {
              if (nodeInfo.canAcceptTask()) {
                LOG.info("Assigning " + nodeToString(inst,nodeInfo) + " when looking for "+ host+ ". local=true"+ " FirstRequestedHost="+ (prefHostCount == 0)+ (requestedHosts.length > 1 ? ", #prefLocations=" + requestedHosts.length : ""));
                return new SelectHostResult(inst,nodeInfo);
              }
 else {
                if (shouldDelayForLocality) {
                  if (request.shouldForceLocality()) {
                    requestedHostsWillBecomeAvailable=true;
                  }
 else {
                    if (nodeInfo.getEnableTime() > request.getLocalityDelayTimeout() && nodeInfo.isDisabled() && nodeInfo.hadCommFailure()) {
                      LOG.debug("Host={} will not become available within requested timeout",nodeInfo);
                    }
 else {
                      requestedHostsWillBecomeAvailable=true;
                    }
                  }
                }
              }
            }
 else {
              LOG.warn("Null NodeInfo when attempting to get host with worker identity {}, and host {}",inst.getWorkerIdentity(),host);
            }
          }
        }
      }
      if (shouldDelayForLocality) {
        if (requestedHostsWillBecomeAvailable) {
          if (LOG.isDebugEnabled()) {
            LOG.debug("Delaying local allocation for [" + request.task + "] when trying to allocate on ["+ Arrays.toString(requestedHosts)+ "]"+ ". ScheduleAttemptTime="+ schedulerAttemptTime+ ", taskDelayTimeout="+ request.getLocalityDelayTimeout());
          }
          return SELECT_HOST_RESULT_DELAYED_LOCALITY;
        }
 else {
          if (LOG.isDebugEnabled()) {
            LOG.debug("Skipping local allocation for [" + request.task + "] when trying to allocate on ["+ Arrays.toString(requestedHosts)+ "] since none of these hosts are part of the known list");
          }
        }
      }
    }
    Entry<String,NodeInfo>[] all=instanceToNodeMap.entrySet().toArray(new Entry[0]);
    if (LOG.isDebugEnabled()) {
      LOG.debug("Attempting random allocation for task={}",request.task);
    }
    if (all.length > 0) {
      int n=random.nextInt(all.length);
      for (int i=0; i < all.length; i++) {
        Entry<String,NodeInfo> inst=all[(i + n) % all.length];
        if (inst.getValue().canAcceptTask()) {
          LOG.info("Assigning " + nodeToString(inst.getValue().getServiceInstance(),inst.getValue()) + " when looking for any host, from #hosts="+ all.length+ ", requestedHosts="+ ((requestedHosts == null || requestedHosts.length == 0) ? "null" : Arrays.toString(requestedHosts)));
          return new SelectHostResult(inst.getValue().getServiceInstance(),inst.getValue());
        }
      }
    }
    return SELECT_HOST_RESULT_DELAYED_RESOURCES;
  }
  finally {
    readLock.unlock();
  }
}
