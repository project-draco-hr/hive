{
  writeLock.lock();
  try {
    nodeEnablerFuture=nodeEnabledExecutor.submit(nodeEnablerCallable);
    Futures.addCallback(nodeEnablerFuture,new FutureCallback<Void>(){
      @Override public void onSuccess(      Void result){
        LOG.info("NodeEnabledThread exited");
      }
      @Override public void onFailure(      Throwable t){
        LOG.warn("NodeEnabledThread exited with error",t);
      }
    }
);
    schedulerFuture=schedulerExecutor.submit(schedulerCallable);
    Futures.addCallback(schedulerFuture,new FutureCallback<Void>(){
      @Override public void onSuccess(      Void result){
        LOG.info("SchedulerThread exited");
      }
      @Override public void onFailure(      Throwable t){
        LOG.warn("SchedulerThread exited with error",t);
      }
    }
);
    registry.start();
    registry.registerStateChangeListener(new NodeStateChangeListener());
    activeInstances=registry.getInstances();
    for (    ServiceInstance inst : activeInstances.getAll().values()) {
      addNode(inst,new NodeInfo(inst,nodeBlacklistConf,clock,numSchedulableTasksPerNode));
    }
  }
  finally {
    writeLock.unlock();
  }
}
