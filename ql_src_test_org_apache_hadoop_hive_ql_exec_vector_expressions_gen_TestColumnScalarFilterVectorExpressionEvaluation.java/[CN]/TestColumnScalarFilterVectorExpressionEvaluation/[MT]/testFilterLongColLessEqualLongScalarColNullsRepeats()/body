{
  Random rand=new Random(SEED);
  LongColumnVector inputColumnVector=VectorizedRowGroupGenUtil.generateLongColumnVector(true,true,BATCH_SIZE,rand);
  VectorizedRowBatch rowBatch=new VectorizedRowBatch(1,BATCH_SIZE);
  rowBatch.cols[0]=inputColumnVector;
  long scalarValue=0;
  do {
    scalarValue=rand.nextLong();
  }
 while (scalarValue == 0);
  FilterLongColLessEqualLongScalar vectorExpression=new FilterLongColLessEqualLongScalar(0,scalarValue);
  vectorExpression.evaluate(rowBatch);
  int selectedIndex=0;
  int i=0;
  if (inputColumnVector.isRepeating) {
    selectedIndex=!inputColumnVector.isNull[i] && inputColumnVector.vector[i] <= scalarValue ? BATCH_SIZE : 0;
  }
 else {
    for (i=0; i < BATCH_SIZE; i++) {
      if (!inputColumnVector.isNull[i]) {
        if (inputColumnVector.vector[i] <= scalarValue) {
          assertEquals("Vector index that passes filter " + inputColumnVector.vector[i] + "<="+ scalarValue+ " is not in rowBatch selected index",i,rowBatch.selected[selectedIndex]);
          selectedIndex++;
        }
      }
    }
  }
  assertEquals("Row batch size not set to number of selected rows: " + selectedIndex,selectedIndex,rowBatch.size);
  if (selectedIndex > 0 && selectedIndex < BATCH_SIZE) {
    assertEquals("selectedInUse should be set when > 0 and < entire batch(" + BATCH_SIZE + ") is selected: "+ selectedIndex,true,rowBatch.selectedInUse);
  }
 else   if (selectedIndex == BATCH_SIZE) {
    assertEquals("selectedInUse should not be set when entire batch(" + BATCH_SIZE + ") is selected: "+ selectedIndex,false,rowBatch.selectedInUse);
  }
}
