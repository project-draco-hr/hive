{
  super("LlapDaemon");
  initializeLogging();
  printAsciiArt();
  Preconditions.checkArgument(numExecutors > 0);
  Preconditions.checkArgument(srvPort == 0 || (srvPort > 1024 && srvPort < 65536),"Server RPC Port must be between 1025 and 65535, or 0 automatic selection");
  Preconditions.checkArgument(mngPort == 0 || (mngPort > 1024 && mngPort < 65536),"Management RPC Port must be between 1025 and 65535, or 0 automatic selection");
  Preconditions.checkArgument(localDirs != null && localDirs.length > 0,"Work dirs must be specified");
  Preconditions.checkArgument(shufflePort == 0 || (shufflePort > 1024 && shufflePort < 65536),"Shuffle Port must be betwee 1024 and 65535, or 0 for automatic selection");
  String hosts=HiveConf.getTrimmedVar(daemonConf,ConfVars.LLAP_DAEMON_SERVICE_HOSTS);
  if (hosts.startsWith("@")) {
    String zkHosts=HiveConf.getTrimmedVar(daemonConf,ConfVars.HIVE_ZOOKEEPER_QUORUM);
    LOG.info("Zookeeper Quorum: {}",zkHosts);
    Preconditions.checkArgument(zkHosts != null && !zkHosts.trim().isEmpty(),"LLAP service hosts startswith '@' but hive.zookeeper.quorum is not set." + " hive.zookeeper.quorum must be set.");
  }
  this.maxJvmMemory=getTotalHeapSize();
  this.llapIoEnabled=ioEnabled;
  this.executorMemoryPerInstance=executorMemoryBytes;
  this.ioMemoryPerInstance=ioMemoryBytes;
  this.numExecutors=numExecutors;
  this.localDirs=localDirs;
  int waitQueueSize=HiveConf.getIntVar(daemonConf,ConfVars.LLAP_DAEMON_TASK_SCHEDULER_WAIT_QUEUE_SIZE);
  boolean enablePreemption=HiveConf.getBoolVar(daemonConf,ConfVars.LLAP_DAEMON_TASK_SCHEDULER_ENABLE_PREEMPTION);
  LOG.warn("Attempting to start LlapDaemonConf with the following configuration: " + "numExecutors=" + numExecutors + ", rpcListenerPort="+ srvPort+ ", mngListenerPort="+ mngPort+ ", workDirs="+ Arrays.toString(localDirs)+ ", shufflePort="+ shufflePort+ ", executorMemory="+ executorMemoryBytes+ ", llapIoEnabled="+ ioEnabled+ ", llapIoCacheIsDirect="+ isDirectCache+ ", llapIoCacheSize="+ ioMemoryBytes+ ", jvmAvailableMemory="+ maxJvmMemory+ ", waitQueueSize= "+ waitQueueSize+ ", enablePreemption= "+ enablePreemption);
  long memRequired=executorMemoryBytes + (ioEnabled && isDirectCache == false ? ioMemoryBytes : 0);
  Preconditions.checkState(maxJvmMemory >= memRequired,"Invalid configuration. Xmx value too small. maxAvailable=" + maxJvmMemory + ", configured(exec + io if enabled)="+ memRequired);
  this.shuffleHandlerConf=new Configuration(daemonConf);
  this.shuffleHandlerConf.setInt(ShuffleHandler.SHUFFLE_PORT_CONFIG_KEY,shufflePort);
  this.shuffleHandlerConf.set(ShuffleHandler.SHUFFLE_HANDLER_LOCAL_DIRS,StringUtils.arrayToString(localDirs));
  this.shuffleHandlerConf.setBoolean(ShuffleHandler.SHUFFLE_DIR_WATCHER_ENABLED,HiveConf.getBoolVar(daemonConf,ConfVars.LLAP_DAEMON_SHUFFLE_DIR_WATCHER_ENABLED));
  int numHandlers=HiveConf.getIntVar(daemonConf,ConfVars.LLAP_DAEMON_RPC_NUM_HANDLERS);
  ClassLoader executorClassLoader=null;
  if (HiveConf.getBoolVar(daemonConf,ConfVars.LLAP_DAEMON_ALLOW_PERMANENT_FNS)) {
    this.fnLocalizer=new FunctionLocalizer(daemonConf,localDirs[0]);
    executorClassLoader=fnLocalizer.getClassLoader();
    SerializationUtilities.setGlobalHook(new LlapGlobalUdfChecker(fnLocalizer));
  }
 else {
    this.fnLocalizer=null;
    executorClassLoader=Thread.currentThread().getContextClassLoader();
  }
  LlapMetricsSystem.initialize("LlapDaemon");
  this.pauseMonitor=new JvmPauseMonitor(daemonConf);
  pauseMonitor.start();
  String displayName="LlapDaemonExecutorMetrics-" + MetricsUtils.getHostName();
  String sessionId=MetricsUtils.getUUID();
  daemonConf.set("llap.daemon.metrics.sessionid",sessionId);
  this.metrics=LlapDaemonExecutorMetrics.create(displayName,sessionId,numExecutors);
  metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);
  this.llapDaemonInfoBean=MBeans.register("LlapDaemon","LlapDaemonInfo",this);
  LOG.info("Started LlapMetricsSystem with displayName: " + displayName + " sessionId: "+ sessionId);
  this.amReporter=new AMReporter(srvAddress,new QueryFailedHandlerProxy(),daemonConf);
  this.server=new LlapProtocolServerImpl(numHandlers,this,srvAddress,mngAddress,srvPort,mngPort);
  this.containerRunner=new ContainerRunnerImpl(daemonConf,numExecutors,waitQueueSize,enablePreemption,localDirs,this.shufflePort,srvAddress,executorMemoryBytes,metrics,amReporter,executorClassLoader);
  addIfService(containerRunner);
  this.registry=new LlapRegistryService(true);
  addIfService(registry);
  if (HiveConf.getBoolVar(daemonConf,HiveConf.ConfVars.HIVE_IN_TEST)) {
    this.webServices=null;
  }
 else {
    this.webServices=new LlapWebServices();
    addIfService(webServices);
  }
  addIfService(server);
  addIfService(amReporter);
}
