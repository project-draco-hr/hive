{
  final RexBuilder rexBuilder=join.getCluster().getRexBuilder();
  final List<RelNode> newInputs=Lists.newArrayList();
  final List<RexNode> newJoinFilters=Lists.newArrayList();
  newJoinFilters.add(join.getCondition());
  final List<Pair<Pair<Integer,Integer>,JoinRelType>> joinSpecs=Lists.newArrayList();
  if (left instanceof Join || left instanceof HiveMultiJoin) {
    final RexNode leftCondition;
    final List<Pair<Integer,Integer>> leftJoinInputs;
    final List<JoinRelType> leftJoinTypes;
    if (left instanceof Join) {
      Join hj=(Join)left;
      leftCondition=hj.getCondition();
      leftJoinInputs=ImmutableList.of(Pair.of(0,1));
      leftJoinTypes=ImmutableList.of(hj.getJoinType());
    }
 else {
      HiveMultiJoin hmj=(HiveMultiJoin)left;
      leftCondition=hmj.getCondition();
      leftJoinInputs=hmj.getJoinInputs();
      leftJoinTypes=hmj.getJoinTypes();
    }
    boolean combinable;
    try {
      combinable=isCombinablePredicate(join,join.getCondition(),leftCondition);
    }
 catch (    CalciteSemanticException e) {
      LOG.trace("Failed to merge joins",e);
      combinable=false;
    }
    if (combinable) {
      newJoinFilters.add(leftCondition);
      for (int i=0; i < leftJoinInputs.size(); i++) {
        joinSpecs.add(Pair.of(leftJoinInputs.get(i),leftJoinTypes.get(i)));
      }
      newInputs.addAll(left.getInputs());
    }
 else {
      return null;
    }
  }
 else {
    return null;
  }
  final int numberLeftInputs=newInputs.size();
  newInputs.add(right);
  if (newJoinFilters.size() == 1) {
    return null;
  }
  final List<RelDataTypeField> systemFieldList=ImmutableList.of();
  List<List<RexNode>> joinKeyExprs=new ArrayList<List<RexNode>>();
  List<Integer> filterNulls=new ArrayList<Integer>();
  for (int i=0; i < newInputs.size(); i++) {
    joinKeyExprs.add(new ArrayList<RexNode>());
  }
  RexNode otherCondition;
  try {
    otherCondition=HiveRelOptUtil.splitHiveJoinCondition(systemFieldList,newInputs,join.getCondition(),joinKeyExprs,filterNulls,null);
  }
 catch (  CalciteSemanticException e) {
    LOG.trace("Failed to merge joins",e);
    return null;
  }
  if (!otherCondition.isAlwaysTrue()) {
    return null;
  }
  ImmutableBitSet.Builder keysInInputsBuilder=ImmutableBitSet.builder();
  for (int i=0; i < newInputs.size(); i++) {
    List<RexNode> partialCondition=joinKeyExprs.get(i);
    if (!partialCondition.isEmpty()) {
      keysInInputsBuilder.set(i);
    }
  }
  ImmutableBitSet keysInInputs=keysInInputsBuilder.build();
  ImmutableBitSet leftReferencedInputs=keysInInputs.intersect(ImmutableBitSet.range(numberLeftInputs));
  ImmutableBitSet rightReferencedInputs=keysInInputs.intersect(ImmutableBitSet.range(numberLeftInputs,newInputs.size()));
  if (join.getJoinType() != JoinRelType.INNER && (leftReferencedInputs.cardinality() > 1 || rightReferencedInputs.cardinality() > 1)) {
    return null;
  }
  if (join.getJoinType() != JoinRelType.INNER) {
    int leftInput=keysInInputs.nextSetBit(0);
    int rightInput=keysInInputs.nextSetBit(numberLeftInputs);
    joinSpecs.add(Pair.of(Pair.of(leftInput,rightInput),join.getJoinType()));
  }
 else {
    for (    int i : leftReferencedInputs) {
      for (      int j : rightReferencedInputs) {
        joinSpecs.add(Pair.of(Pair.of(i,j),join.getJoinType()));
      }
    }
  }
  RexNode newCondition=RexUtil.flatten(rexBuilder,RexUtil.composeConjunction(rexBuilder,newJoinFilters,false));
  return new HiveMultiJoin(join.getCluster(),newInputs,newCondition,join.getRowType(),Pair.left(joinSpecs),Pair.right(joinSpecs));
}
