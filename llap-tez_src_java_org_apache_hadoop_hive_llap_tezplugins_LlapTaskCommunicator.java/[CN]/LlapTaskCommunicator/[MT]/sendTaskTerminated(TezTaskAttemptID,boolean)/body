{
  LOG.info("Attempting to send terminateRequest for fragment {} due to internal preemption invoked by {}",taskAttemptId.toString(),invokedByContainerEnd ? "containerEnd" : "taskEnd");
  LlapNodeId nodeId=entityTracker.getNodeIdForTaskAttempt(taskAttemptId);
  if (nodeId != null) {
    TerminateFragmentRequestProto request=TerminateFragmentRequestProto.newBuilder().setQueryIdentifier(constructQueryIdentifierProto(taskAttemptId.getTaskID().getVertexID().getDAGId().getId())).setFragmentIdentifierString(taskAttemptId.toString()).build();
    communicator.sendTerminateFragment(request,nodeId.getHostname(),nodeId.getPort(),new LlapProtocolClientProxy.ExecuteRequestCallback<TerminateFragmentResponseProto>(){
      @Override public void setResponse(      TerminateFragmentResponseProto response){
      }
      @Override public void indicateError(      Throwable t){
        LOG.warn("Failed to send terminate fragment request for {}",taskAttemptId.toString());
        processSendError(t);
      }
    }
);
  }
 else {
    LOG.info("Not sending terminate request for fragment {} since it's node is not known. Already unregistered",taskAttemptId.toString());
  }
}
