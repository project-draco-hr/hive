{
  if (compressed == null || offsetInCompressed >= limitInCompressed) {
    seek(currentOffset);
  }
  if (limitInCompressed - offsetInCompressed > OutStream.HEADER_SIZE) {
    int chunkLength=((0xff & compressed[offsetInCompressed + 2]) << 15) | ((0xff & compressed[offsetInCompressed + 1]) << 7) | ((0xff & compressed[offsetInCompressed]) >> 1);
    if (chunkLength > bufferSize) {
      throw new IllegalArgumentException("Buffer size too small. size = " + bufferSize + " needed = "+ chunkLength);
    }
    boolean isOriginal=(compressed[offsetInCompressed] & 0x01) == 1;
    offsetInCompressed+=OutStream.HEADER_SIZE;
    if (isOriginal) {
      isUncompressedOriginal=true;
      uncompressed=bytes[currentRange].duplicate();
      uncompressed.position(offsetInCompressed - bytes[currentRange].arrayOffset());
      uncompressed.limit(offsetInCompressed + chunkLength);
    }
 else {
      if (isUncompressedOriginal) {
        uncompressed=ByteBuffer.allocate(bufferSize);
        isUncompressedOriginal=false;
      }
 else       if (uncompressed == null) {
        uncompressed=ByteBuffer.allocate(bufferSize);
      }
 else {
        uncompressed.clear();
      }
      codec.decompress(ByteBuffer.wrap(compressed,offsetInCompressed,chunkLength),uncompressed);
    }
    offsetInCompressed+=chunkLength;
    currentOffset+=chunkLength + OutStream.HEADER_SIZE;
  }
 else {
    throw new IllegalStateException("Can't read header at " + this);
  }
}
