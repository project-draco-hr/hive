{
  if (desired == 0 && bytes.isEmpty()) {
    logEmptySeek(name);
    return;
  }
  int i=0;
  for (  DiskRange range : bytes) {
    if (range.offset <= desired && desired < range.end) {
      currentRange=i;
      if (range instanceof BufferChunk) {
        cacheBuffer=null;
        compressed=range.getData().duplicate();
        int pos=compressed.position();
        pos+=(int)(desired - range.offset);
        compressed.position(pos);
      }
 else {
        compressed=null;
        cacheBuffer=((CacheChunk)range).buffer;
        uncompressed=cacheBuffer.byteBuffer.duplicate();
        if (desired != range.offset) {
          throw new IOException("Cannot seek into the middle of uncompressed cached data");
        }
      }
      currentOffset=desired;
      return;
    }
    ++i;
  }
  int segments=bytes.size();
  if (segments != 0 && desired == bytes.get(segments - 1).end) {
    DiskRange range=bytes.get(segments - 1);
    currentRange=segments - 1;
    if (range instanceof BufferChunk) {
      cacheBuffer=null;
      compressed=range.getData().duplicate();
      compressed.position(compressed.limit());
    }
 else {
      compressed=null;
      cacheBuffer=((CacheChunk)range).buffer;
      uncompressed=cacheBuffer.byteBuffer.duplicate();
      uncompressed.position(uncompressed.limit());
      if (desired != range.offset) {
        throw new IOException("Cannot seek into the middle of uncompressed cached data");
      }
      currentOffset=desired;
    }
    return;
  }
  throw new IOException("Seek outside of data in " + this + " to "+ desired);
}
