{
  ByteBuffer slice=null;
  ByteBuffer compressed=current.chunk;
  long cbStartOffset=current.offset;
  int b0=compressed.get() & 0xff;
  int b1=compressed.get() & 0xff;
  int b2=compressed.get() & 0xff;
  int chunkLength=(b2 << 15) | (b1 << 7) | (b0 >> 1);
  if (chunkLength > bufferSize) {
    throw new IllegalArgumentException("Buffer size too small. size = " + bufferSize + " needed = "+ chunkLength);
  }
  int consumedLength=chunkLength + OutStream.HEADER_SIZE;
  long cbEndOffset=cbStartOffset + consumedLength;
  boolean isUncompressed=((b0 & 0x01) == 1);
  if (DebugUtils.isTraceOrcEnabled()) {
    LOG.info("Found CB at " + cbStartOffset + ", chunk length "+ chunkLength+ ", total "+ consumedLength+ ", "+ (isUncompressed ? "not " : "")+ "compressed");
  }
  if (compressed.remaining() >= chunkLength) {
    slice=compressed.slice();
    slice.limit(chunkLength);
    addOneCompressionBlockByteBuffer(slice,isUncompressed,cbStartOffset,cbEndOffset,chunkLength,ranges,current,cache,toDecompress,cacheBuffers);
    if (DebugUtils.isTraceOrcEnabled()) {
      LOG.info("Adjusting " + current + " to consume "+ consumedLength);
    }
    current.offset+=consumedLength;
    if (compressed.remaining() <= 0 && zcr != null) {
      toRelease.add(compressed);
    }
    return consumedLength;
  }
  if (current.end < cbEndOffset && !ranges.hasNext()) {
    return -1;
  }
  ByteBuffer copy=allocateBuffer(chunkLength,compressed.isDirect());
  int remaining=chunkLength - compressed.remaining();
  int originalPos=compressed.position();
  copy.put(compressed);
  ranges.remove();
  if (DebugUtils.isTraceOrcEnabled()) {
    LOG.info("Removing " + current + " from ranges");
  }
  if (zcr != null) {
    if (originalPos == 0) {
      zcr.releaseBuffer(compressed);
    }
 else {
      toRelease.add(compressed);
    }
  }
  DiskRange nextRange=null;
  while (ranges.hasNext()) {
    nextRange=ranges.next();
    if (!(nextRange instanceof BufferChunk)) {
      throw new IOException("Trying to extend compressed block into uncompressed block");
    }
    compressed=nextRange.getData();
    if (compressed.remaining() >= remaining) {
      slice=compressed.slice();
      slice.limit(remaining);
      copy.put(slice);
      addOneCompressionBlockByteBuffer(copy,isUncompressed,cbStartOffset,cbEndOffset,remaining,ranges,current,cache,toDecompress,cacheBuffers);
      if (DebugUtils.isTraceOrcEnabled()) {
        LOG.info("Adjusting " + nextRange + " to consume "+ remaining);
      }
      nextRange.offset+=remaining;
      if (compressed.remaining() <= 0 && zcr != null) {
        zcr.releaseBuffer(compressed);
      }
      return consumedLength;
    }
    remaining-=compressed.remaining();
    copy.put(compressed);
    if (zcr != null) {
      zcr.releaseBuffer(compressed);
    }
    if (DebugUtils.isTraceOrcEnabled()) {
      LOG.info("Removing " + nextRange + " from ranges");
    }
    ranges.remove();
  }
  return -1;
}
