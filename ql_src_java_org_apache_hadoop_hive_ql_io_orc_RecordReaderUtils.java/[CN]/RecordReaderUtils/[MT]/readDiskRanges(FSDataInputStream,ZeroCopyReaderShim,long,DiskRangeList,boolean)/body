{
  if (range == null)   return null;
  DiskRangeList prev=range.prev;
  if (prev == null) {
    prev=new DiskRangeListMutateHelper(range);
  }
  while (range != null) {
    if (range.hasData()) {
      range=range.next;
      continue;
    }
    int len=(int)(range.end - range.offset);
    long off=range.offset;
    file.seek(base + off);
    if (zcr != null) {
      boolean hasReplaced=false;
      while (len > 0) {
        ByteBuffer partial=zcr.readBuffer(len,false);
        BufferChunk bc=new BufferChunk(partial,off);
        if (!hasReplaced) {
          range.replaceSelfWith(bc);
          hasReplaced=true;
        }
 else {
          range.insertAfter(bc);
        }
        range=bc;
        int read=partial.remaining();
        len-=read;
        off+=read;
      }
    }
 else     if (doForceDirect) {
      ByteBuffer directBuf=ByteBuffer.allocateDirect(len);
      int pos=directBuf.position();
      try {
        while (directBuf.remaining() >= 0) {
          int count=file.read(directBuf);
          if (count < 0)           throw new EOFException();
          if (directBuf.position() != pos) {
            RecordReaderImpl.LOG.info("Warning - position mismatch from " + file.getClass() + ": after reading "+ count+ ", expected "+ pos+ " but got "+ directBuf.position());
          }
          pos+=count;
          if (pos > len) {
            throw new AssertionError("Position " + pos + " length "+ len+ " after reading "+ count);
          }
          directBuf.position(pos);
        }
      }
 catch (      UnsupportedOperationException ex) {
        RecordReaderImpl.LOG.error("Stream does not support direct read; we will copy.");
        byte[] buffer=new byte[len];
        file.readFully(buffer,0,buffer.length);
        directBuf.put(buffer);
      }
      directBuf.position(0);
      range=range.replaceSelfWith(new BufferChunk(directBuf,range.offset));
    }
 else {
      byte[] buffer=new byte[len];
      file.readFully(buffer,0,buffer.length);
      range=range.replaceSelfWith(new BufferChunk(ByteBuffer.wrap(buffer),range.offset));
    }
    range=range.next;
  }
  return prev.next;
}
