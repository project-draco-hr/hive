{
  for (int group=0; group < includedRowGroups.length; ++group) {
    if (!includedRowGroups[group])     continue;
    int posn=getIndexPosition(encoding.getKind(),type.getKind(),stream.getKind(),isCompressed,hasNull);
    long start=index.getEntry(group).getPositions(posn);
    final long nextGroupOffset;
    boolean isLast=group == (includedRowGroups.length - 1);
    nextGroupOffset=isLast ? length : index.getEntry(group + 1).getPositions(posn);
    start+=offset;
    long end=offset + estimateRgEndOffset(isCompressed,isLast,nextGroupOffset,length,compressionSize);
    if (lastRange != null && overlap(lastRange.offset,lastRange.end,start,end)) {
      lastRange.offset=Math.min(lastRange.offset,start);
      lastRange.end=Math.max(lastRange.end,end);
    }
 else {
      if (DebugUtils.isTraceOrcEnabled()) {
        RecordReaderImpl.LOG.info("Creating new range for RG read; last range (which can " + "include some previous RGs) was " + lastRange);
      }
      lastRange=new DiskRange(start,end);
      result.add(lastRange);
    }
  }
  return lastRange;
}
