{
  if (oc == null) {
    oc=output;
    rp=reporter;
    reducer.setOutputCollector(oc);
    reducer.setReporter(rp);
  }
  try {
    BytesWritable keyWritable=(BytesWritable)key;
    tag.set((byte)0);
    if (isTagged) {
      int size=keyWritable.getSize() - 1;
      tag.set(keyWritable.get()[size]);
      keyWritable.setSize(size);
    }
    if (!keyWritable.equals(groupKey)) {
      if (groupKey == null) {
        groupKey=new BytesWritable();
      }
 else {
        l4j.trace("End Group");
        reducer.endGroup();
      }
      groupKey.set(keyWritable.get(),0,keyWritable.getSize());
      l4j.trace("Start Group");
      reducer.startGroup();
    }
    try {
      keyObject=inputKeyDeserializer.deserialize(keyWritable);
    }
 catch (    Exception e) {
      throw new HiveException(e);
    }
    while (values.hasNext()) {
      Writable valueWritable=(Writable)values.next();
      try {
        valueObject[tag.get()]=inputValueDeserializer[tag.get()].deserialize(valueWritable);
      }
 catch (      SerDeException e) {
        throw new HiveException(e);
      }
      row.clear();
      row.add(keyObject);
      row.add(valueObject[tag.get()]);
      row.add(tag);
      if (l4j.isInfoEnabled()) {
        cntr++;
        if (cntr == nextCntr) {
          long used_memory=memoryMXBean.getHeapMemoryUsage().getUsed();
          l4j.info("ExecReducer: processing " + cntr + " rows: used memory = "+ used_memory);
          nextCntr=getNextCntr(cntr);
        }
      }
      reducer.process(row,tag.get());
    }
  }
 catch (  Throwable e) {
    abort=true;
    if (e instanceof OutOfMemoryError) {
      throw (OutOfMemoryError)e;
    }
 else {
      throw new IOException(e);
    }
  }
}
