{
  Task<? extends Serializable> task=(Task<? extends Serializable>)nd;
  ParseContext parseContext=physicalContext.getParseContext();
  WalkerCtx walkerCtx=new WalkerCtx();
  Map<Rule,NodeProcessor> opRules=new LinkedHashMap<Rule,NodeProcessor>();
  opRules.put(new RuleRegExp("R1",TableScanOperator.getOperatorName() + "%"),new TableScanProcessor());
  opRules.put(new RuleRegExp("R2",GroupByOperator.getOperatorName() + "%.*" + FileSinkOperator.getOperatorName()+ "%"),new FileSinkProcessor());
  for (  MapWork mapWork : task.getMapWork()) {
    LOG.debug("Looking at: " + mapWork.getName());
    Collection<Operator<? extends OperatorDesc>> topOperators=mapWork.getAliasToWork().values();
    if (topOperators.size() == 0) {
      LOG.debug("No top operators");
      return null;
    }
    LOG.info("Looking for table scans where optimization is applicable");
    Dispatcher disp=new DefaultRuleDispatcher(null,opRules,walkerCtx);
    GraphWalker ogw=new PreOrderWalker(disp);
    ArrayList<Node> topNodes=new ArrayList<Node>();
    for (    Operator<? extends OperatorDesc> workOperator : topOperators) {
      if (parseContext.getTopOps().values().contains(workOperator)) {
        topNodes.add(workOperator);
      }
    }
    Operator<? extends OperatorDesc> reducer=task.getReducer(mapWork);
    if (reducer != null) {
      topNodes.add(reducer);
    }
    ogw.startWalking(topNodes,null);
    LOG.info(String.format("Found %d metadata only table scans",walkerCtx.getMetadataOnlyTableScans().size()));
    Iterator<TableScanOperator> iterator=walkerCtx.getMetadataOnlyTableScans().iterator();
    while (iterator.hasNext()) {
      TableScanOperator tso=iterator.next();
      ((TableScanDesc)tso.getConf()).setIsMetadataOnly(true);
      String alias=getAliasForTableScanOperator(mapWork,tso);
      LOG.info("Metadata only table scan for " + alias);
      processAlias(mapWork,alias);
    }
  }
  return null;
}
