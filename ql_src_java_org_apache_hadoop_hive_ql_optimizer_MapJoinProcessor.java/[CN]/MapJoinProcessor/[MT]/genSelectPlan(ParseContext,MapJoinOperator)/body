{
  List<Operator<? extends OperatorDesc>> childOps=input.getChildOperators();
  input.setChildOperators(null);
  RowSchema inputRS=input.getSchema();
  ArrayList<ExprNodeDesc> exprs=new ArrayList<ExprNodeDesc>();
  ArrayList<String> outputs=new ArrayList<String>();
  List<String> outputCols=input.getConf().getOutputColumnNames();
  ArrayList<ColumnInfo> outputRS=new ArrayList<ColumnInfo>();
  Map<String,ExprNodeDesc> colExprMap=new HashMap<String,ExprNodeDesc>();
  for (int i=0; i < outputCols.size(); i++) {
    String internalName=outputCols.get(i);
    ColumnInfo valueInfo=inputRS.getColumnInfo(internalName);
    ExprNodeDesc colDesc=new ExprNodeColumnDesc(valueInfo.getType(),valueInfo.getInternalName(),valueInfo.getTabAlias(),valueInfo.getIsVirtualCol());
    exprs.add(colDesc);
    outputs.add(internalName);
    ColumnInfo newCol=new ColumnInfo(internalName,valueInfo.getType(),valueInfo.getTabAlias(),valueInfo.getIsVirtualCol(),valueInfo.isHiddenVirtualCol());
    newCol.setAlias(valueInfo.getAlias());
    outputRS.add(newCol);
    colExprMap.put(internalName,colDesc);
  }
  SelectDesc select=new SelectDesc(exprs,outputs,false);
  SelectOperator sel=(SelectOperator)OperatorFactory.getAndMakeChild(select,new RowSchema(outputRS),input);
  sel.setColumnExprMap(colExprMap);
  sel.setChildOperators(childOps);
  for (  Operator<? extends OperatorDesc> ch : childOps) {
    ch.replaceParent(input,sel);
  }
}
